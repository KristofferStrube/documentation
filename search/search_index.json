{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"elmah.io Installation Quick Start Welcome to the quick start installation guide. Here you will find a quick introduction to installing elmah.io. For the full overview, read through the individual guides by clicking a technology below: ASP.NET ASP.NET MVC ASP.NET Web API ASP.NET Core MEL Functions Serilog log4net NLog Logary Umbraco JavaScript ASP.NET / MVC / Web API Install the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key and log ID. For more information, check out the installation guides for WebForms , MVC and Web API . There is a short video tutorial available here: ASP.NET Core Install the Elmah.Io.AspNetCore NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore dotnet add package Elmah.Io.AspNetCore <PackageReference Include=\"Elmah.Io.AspNetCore\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore Once installed, call AddElmahIo in the ConfigureServices -method and UseElmahIo in the Configure -method (both in the Startup.cs file): public void ConfigureServices(IServiceCollection services) { services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); }); // ... } public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory fac) { // ... app.UseElmahIo(); // ... } Make sure to insert your API key and log ID. For more information, check out the installation guides for ASP.NET Core and Microsoft.Extensions.Logging . JavaScript Install the elmah.io.javascript npm package: npm install elmah.io.javascript Reference the installed script and include your API key and log ID as part of the URL: <script src=\"~/node_modules/elmah.io.javascript/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> For more information, check out the installation guide for JavaScript .","title":"Quick start"},{"location":"#elmahio-installation-quick-start","text":"Welcome to the quick start installation guide. Here you will find a quick introduction to installing elmah.io. For the full overview, read through the individual guides by clicking a technology below: ASP.NET ASP.NET MVC ASP.NET Web API ASP.NET Core MEL Functions Serilog log4net NLog Logary Umbraco JavaScript","title":"elmah.io Installation Quick Start"},{"location":"#aspnet-mvc-web-api","text":"Install the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key and log ID. For more information, check out the installation guides for WebForms , MVC and Web API . There is a short video tutorial available here:","title":"ASP.NET / MVC / Web API"},{"location":"#aspnet-core","text":"Install the Elmah.Io.AspNetCore NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore dotnet add package Elmah.Io.AspNetCore <PackageReference Include=\"Elmah.Io.AspNetCore\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore Once installed, call AddElmahIo in the ConfigureServices -method and UseElmahIo in the Configure -method (both in the Startup.cs file): public void ConfigureServices(IServiceCollection services) { services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); }); // ... } public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory fac) { // ... app.UseElmahIo(); // ... } Make sure to insert your API key and log ID. For more information, check out the installation guides for ASP.NET Core and Microsoft.Extensions.Logging .","title":"ASP.NET Core"},{"location":"#javascript","text":"Install the elmah.io.javascript npm package: npm install elmah.io.javascript Reference the installed script and include your API key and log ID as part of the URL: <script src=\"~/node_modules/elmah.io.javascript/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> For more information, check out the installation guide for JavaScript .","title":"JavaScript"},{"location":"adding-version-information/","text":"Adding Version Information Almost every piece of software has some sort of version. Whether it's a nice looking SemVer string or a simple timestamp, being able to distinguish one version from the other is important. elmah.io supports sending version information from your application in every message logged in two ways: By adding the version manually (as explained in this document). By using the Deployment Tracking feature (as explained in Set Up Deployment Tracking ). Version Numbers on the UI Let's start by looking at how version numbers are represented in the elmah.io UI. Every message contains a version property as illustrated below: The error is logged by an application with version number 1.0.0. Looking at another error, the version number may look different: This way, you will be able to see which version of your software that logged each message. Having the version number on the message, opens up some interesting search possibilities. Imagine that you want to search for every message logged by 1.0.* versions of your software, including release candidates, etc. Simply do a search in the search box like this: The example above finds every message logged from 1.0.0, 1.0.0-rc1, 1.0.1, etc. Adding Version Numbers How you choose to represent version numbers in your system is really up to you. elmah.io doesn't require SemVer, even though we strongly recommend you to use it. Version is a simple string in our API , which means that you can send anything from SemVer to a stringified timestamp. Adding a version number to every message logged in elmah.io, is easy as 1-2-3. If you're using our API, there's a property named version where you can put the version of your application. Chances are that you are using one of the integrations like ELMAH, log4net or Serilog. In fact, there's multiple ways to send a version number to elmah.io. Globally using ELMAH You probably want to attach the same version number on every message logged in elmah.io. The easiest way to achieve that, is to create a global event handler for the OnMessage event, which is triggered every time the elmah.io client logs a message to elmah.io: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { args.Message.Version = \"1.2.3\"; // Requires elmah.io.core version >= 2.0.26 } In the example, the message send off to elmah.io is decorated with the version number 1.2.3 You will need to replace this with the value of an app setting, the assembly info or whatever strategy you've used to make the version number available to your code. Try/catch using ELMAH If you're logging errors to elmah.io in catch blocks, logging the version number can be done using a similar approach to the above: try { CallSomeBusinessLogic(inputValue); } catch (Exception e) { e.Data.Add(\"X-ELMAHIO-VERSION\", \"1.2.3\"); ErrorSignal.FromCurrentContext().Raise(e); } In this case, the code at this point doesn't know anything about elmah.io. Luckily, there's an alternative to the Version property, by putting a custom element in the Data dictionary on Exception. The exact name of the key must be X-ELMAHIO-VERSION for elmah.io to interpret this as the version number. Using log4net log4net supports the concept of customer properties in various ways. Since log4net properties are converted to custom properties in elmah.io, the easiest way to add a version number of every message logged through log4net, is by configuring a global property somewhere in your initialization code: log4net.GlobalContext.Properties[\"X-ELMAHIO-VERSION\"] = \"1.2.3\"; The property name is equal to the custom element we used in the last section. log4net supports custom properties in the context of a log call as well. To do that, put the X-ELMAHIO-VERSION property in the ThreadContext before logging to log4net: log4net.ThreadContext.Properties[\"X-ELMAHIO-VERSION\"] = \"1.2.3\"; log4net.Error(\"This is an error message\"); Using NLog The elmah.io NLog target can use the OnMessage action: var elmahIoTarget = new ElmahIoTarget(); // ... elmahIoTarget.OnMessage = msg => { msg.Version = \"1.2.3\"; }; Using Serilog Serilog can decorate all log messages using enrichers: var logger = new LoggerConfiguration() .Enrich.WithProperty(\"version\", \"1.2.3\") .Enrich.FromLogContext() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\"))) .CreateLogger();","title":"Adding version information"},{"location":"adding-version-information/#adding-version-information","text":"Almost every piece of software has some sort of version. Whether it's a nice looking SemVer string or a simple timestamp, being able to distinguish one version from the other is important. elmah.io supports sending version information from your application in every message logged in two ways: By adding the version manually (as explained in this document). By using the Deployment Tracking feature (as explained in Set Up Deployment Tracking ).","title":"Adding Version Information"},{"location":"adding-version-information/#version-numbers-on-the-ui","text":"Let's start by looking at how version numbers are represented in the elmah.io UI. Every message contains a version property as illustrated below: The error is logged by an application with version number 1.0.0. Looking at another error, the version number may look different: This way, you will be able to see which version of your software that logged each message. Having the version number on the message, opens up some interesting search possibilities. Imagine that you want to search for every message logged by 1.0.* versions of your software, including release candidates, etc. Simply do a search in the search box like this: The example above finds every message logged from 1.0.0, 1.0.0-rc1, 1.0.1, etc.","title":"Version Numbers on the UI"},{"location":"adding-version-information/#adding-version-numbers","text":"How you choose to represent version numbers in your system is really up to you. elmah.io doesn't require SemVer, even though we strongly recommend you to use it. Version is a simple string in our API , which means that you can send anything from SemVer to a stringified timestamp. Adding a version number to every message logged in elmah.io, is easy as 1-2-3. If you're using our API, there's a property named version where you can put the version of your application. Chances are that you are using one of the integrations like ELMAH, log4net or Serilog. In fact, there's multiple ways to send a version number to elmah.io.","title":"Adding Version Numbers"},{"location":"adding-version-information/#globally-using-elmah","text":"You probably want to attach the same version number on every message logged in elmah.io. The easiest way to achieve that, is to create a global event handler for the OnMessage event, which is triggered every time the elmah.io client logs a message to elmah.io: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { args.Message.Version = \"1.2.3\"; // Requires elmah.io.core version >= 2.0.26 } In the example, the message send off to elmah.io is decorated with the version number 1.2.3 You will need to replace this with the value of an app setting, the assembly info or whatever strategy you've used to make the version number available to your code.","title":"Globally using ELMAH"},{"location":"adding-version-information/#trycatch-using-elmah","text":"If you're logging errors to elmah.io in catch blocks, logging the version number can be done using a similar approach to the above: try { CallSomeBusinessLogic(inputValue); } catch (Exception e) { e.Data.Add(\"X-ELMAHIO-VERSION\", \"1.2.3\"); ErrorSignal.FromCurrentContext().Raise(e); } In this case, the code at this point doesn't know anything about elmah.io. Luckily, there's an alternative to the Version property, by putting a custom element in the Data dictionary on Exception. The exact name of the key must be X-ELMAHIO-VERSION for elmah.io to interpret this as the version number.","title":"Try/catch using ELMAH"},{"location":"adding-version-information/#using-log4net","text":"log4net supports the concept of customer properties in various ways. Since log4net properties are converted to custom properties in elmah.io, the easiest way to add a version number of every message logged through log4net, is by configuring a global property somewhere in your initialization code: log4net.GlobalContext.Properties[\"X-ELMAHIO-VERSION\"] = \"1.2.3\"; The property name is equal to the custom element we used in the last section. log4net supports custom properties in the context of a log call as well. To do that, put the X-ELMAHIO-VERSION property in the ThreadContext before logging to log4net: log4net.ThreadContext.Properties[\"X-ELMAHIO-VERSION\"] = \"1.2.3\"; log4net.Error(\"This is an error message\");","title":"Using log4net"},{"location":"adding-version-information/#using-nlog","text":"The elmah.io NLog target can use the OnMessage action: var elmahIoTarget = new ElmahIoTarget(); // ... elmahIoTarget.OnMessage = msg => { msg.Version = \"1.2.3\"; };","title":"Using NLog"},{"location":"adding-version-information/#using-serilog","text":"Serilog can decorate all log messages using enrichers: var logger = new LoggerConfiguration() .Enrich.WithProperty(\"version\", \"1.2.3\") .Enrich.FromLogContext() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\"))) .CreateLogger();","title":"Using Serilog"},{"location":"asp-net-core-troubleshooting/","text":"ASP.NET Core Troubleshooting So, your ASP.NET Core application doesn't log errors to elmah.io? Here is a list of things to try out: Make sure to reference the most recent version of the Elmah.Io.AspNetCore NuGet package. Make sure that the Elmah.Io.Client NuGet package is installed and that the major version matches that of Elmah.Io.AspNetCore . Make sure that you are calling both the AddElmahIo - and UseElmahIo -methods in the Startup.cs file, as described on Logging to elmah.io from ASP.NET Core . Make sure that you call the UseElmahIo -method after invoking other Use* methods that in any way inspect exceptions (like UseDeveloperExceptionPage and UseExceptionHandler ). Make sure that you call the UseElmahIo -method before invoking UseMvc . Make sure that your server has an outgoing internet connection and that it can communicate with api.elmah.io on port 443 . The integration for ASP.NET Core support setting up an HTTP proxy if your server doesn't allow outgoing traffic. Check out Logging through a proxy for details. Make sure that you didn't enable any Ignore filters or set up any Rules with an ignore action on the log in question. Make sure that you don't have any code catching all exceptions happening in your system and ignoring them (could be a logging filter, a piece of middleware, or similar). Make sure that you haven't reached the message limit included in your current plan. Your current usage can be viewed on the Subscription tab on organization settings. Some of the bullets above have been implemented as Roslyn analyzers. Check out Roslyn analyzers for elmah.io and ASP.NET Core for details. Common problems and how to fix them Here you will a list of common exceptions and how to solve them. InvalidOperationException Exception [InvalidOperationException: Unable to resolve service for type 'Elmah.Io.AspNetCore.IBackgroundTaskQueue' while attempting to activate 'Elmah.Io.AspNetCore.ElmahIoMiddleware'.] Microsoft.Extensions.Internal.ActivatorUtilities+ConstructorMatcher.CreateInstance(IServiceProvider provider) Microsoft.AspNetCore.Builder.UseMiddlewareExtensions+<>c__DisplayClass4_0.<UseMiddleware>b__0(RequestDelegate next) Microsoft.AspNetCore.Builder.Internal.ApplicationBuilder.Build() Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication() Solution You forgot to call the AddElmahIo -method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(o => { // ... }); // ... } ArgumentException Exception [ArgumentException: Input an API key Parameter name: apiKey] Elmah.Io.AspNetCore.Extensions.StringExtensions.AssertApiKey(string apiKey) Elmah.Io.AspNetCore.ElmahIoMiddleware..ctor(RequestDelegate next, IBackgroundTaskQueue queue, IOptions<ElmahIoOptions> options) Microsoft.Extensions.Internal.ActivatorUtilities+ConstructorMatcher.CreateInstance(IServiceProvider provider) Microsoft.Extensions.Internal.ActivatorUtilities.CreateInstance(IServiceProvider provider, Type instanceType, Object[] parameters) Microsoft.AspNetCore.Builder.UseMiddlewareExtensions+<>c__DisplayClass4_0.<UseMiddleware>b__0(RequestDelegate next) Microsoft.AspNetCore.Builder.Internal.ApplicationBuilder.Build() Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication() Solution You forgot to call the AddElmahIo -method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(o => { // ... }); // ... } or you called AddElmahIo without options and didn't provide these options elsewhere: public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(); // ... } Even though you configure elmah.io through appsettings.json you still need to call AddElmahIo . In this case, you can register ElmahIoOptions manually and use the empty AddElmahIo overload: public void ConfigureServices(IServiceCollection services) { // ... services.Configure<ElmahIoOptions>(Configuration.GetSection(\"ElmahIo\")); services.AddElmahIo(); // ... } An error occurred while starting the application If you see the error An error occurred while starting the application and the exception isn't logged to elmah.io, the error probably happens before hitting the elmah.io middleware. To help find out what is going on, add the following lines to your Program.cs file: public static IWebHostBuilder CreateWebHostBuilder(string[] args) => WebHost.CreateDefaultBuilder(args) .UseSetting(WebHostDefaults.DetailedErrorsKey, \"true\") .CaptureStartupErrors(true) .UseStartup<Startup>();","title":"ASP.NET Core troubleshooting"},{"location":"asp-net-core-troubleshooting/#aspnet-core-troubleshooting","text":"So, your ASP.NET Core application doesn't log errors to elmah.io? Here is a list of things to try out: Make sure to reference the most recent version of the Elmah.Io.AspNetCore NuGet package. Make sure that the Elmah.Io.Client NuGet package is installed and that the major version matches that of Elmah.Io.AspNetCore . Make sure that you are calling both the AddElmahIo - and UseElmahIo -methods in the Startup.cs file, as described on Logging to elmah.io from ASP.NET Core . Make sure that you call the UseElmahIo -method after invoking other Use* methods that in any way inspect exceptions (like UseDeveloperExceptionPage and UseExceptionHandler ). Make sure that you call the UseElmahIo -method before invoking UseMvc . Make sure that your server has an outgoing internet connection and that it can communicate with api.elmah.io on port 443 . The integration for ASP.NET Core support setting up an HTTP proxy if your server doesn't allow outgoing traffic. Check out Logging through a proxy for details. Make sure that you didn't enable any Ignore filters or set up any Rules with an ignore action on the log in question. Make sure that you don't have any code catching all exceptions happening in your system and ignoring them (could be a logging filter, a piece of middleware, or similar). Make sure that you haven't reached the message limit included in your current plan. Your current usage can be viewed on the Subscription tab on organization settings. Some of the bullets above have been implemented as Roslyn analyzers. Check out Roslyn analyzers for elmah.io and ASP.NET Core for details.","title":"ASP.NET Core Troubleshooting"},{"location":"asp-net-core-troubleshooting/#common-problems-and-how-to-fix-them","text":"Here you will a list of common exceptions and how to solve them.","title":"Common problems and how to fix them"},{"location":"asp-net-core-troubleshooting/#invalidoperationexception","text":"Exception [InvalidOperationException: Unable to resolve service for type 'Elmah.Io.AspNetCore.IBackgroundTaskQueue' while attempting to activate 'Elmah.Io.AspNetCore.ElmahIoMiddleware'.] Microsoft.Extensions.Internal.ActivatorUtilities+ConstructorMatcher.CreateInstance(IServiceProvider provider) Microsoft.AspNetCore.Builder.UseMiddlewareExtensions+<>c__DisplayClass4_0.<UseMiddleware>b__0(RequestDelegate next) Microsoft.AspNetCore.Builder.Internal.ApplicationBuilder.Build() Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication() Solution You forgot to call the AddElmahIo -method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(o => { // ... }); // ... }","title":"InvalidOperationException"},{"location":"asp-net-core-troubleshooting/#argumentexception","text":"Exception [ArgumentException: Input an API key Parameter name: apiKey] Elmah.Io.AspNetCore.Extensions.StringExtensions.AssertApiKey(string apiKey) Elmah.Io.AspNetCore.ElmahIoMiddleware..ctor(RequestDelegate next, IBackgroundTaskQueue queue, IOptions<ElmahIoOptions> options) Microsoft.Extensions.Internal.ActivatorUtilities+ConstructorMatcher.CreateInstance(IServiceProvider provider) Microsoft.Extensions.Internal.ActivatorUtilities.CreateInstance(IServiceProvider provider, Type instanceType, Object[] parameters) Microsoft.AspNetCore.Builder.UseMiddlewareExtensions+<>c__DisplayClass4_0.<UseMiddleware>b__0(RequestDelegate next) Microsoft.AspNetCore.Builder.Internal.ApplicationBuilder.Build() Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication() Solution You forgot to call the AddElmahIo -method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(o => { // ... }); // ... } or you called AddElmahIo without options and didn't provide these options elsewhere: public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(); // ... } Even though you configure elmah.io through appsettings.json you still need to call AddElmahIo . In this case, you can register ElmahIoOptions manually and use the empty AddElmahIo overload: public void ConfigureServices(IServiceCollection services) { // ... services.Configure<ElmahIoOptions>(Configuration.GetSection(\"ElmahIo\")); services.AddElmahIo(); // ... }","title":"ArgumentException"},{"location":"asp-net-core-troubleshooting/#an-error-occurred-while-starting-the-application","text":"If you see the error An error occurred while starting the application and the exception isn't logged to elmah.io, the error probably happens before hitting the elmah.io middleware. To help find out what is going on, add the following lines to your Program.cs file: public static IWebHostBuilder CreateWebHostBuilder(string[] args) => WebHost.CreateDefaultBuilder(args) .UseSetting(WebHostDefaults.DetailedErrorsKey, \"true\") .CaptureStartupErrors(true) .UseStartup<Startup>();","title":"An error occurred while starting the application"},{"location":"asp-net-troubleshooting/","text":"ASP.NET Troubleshooting You are probably here because your application doesn't log errors to elmah.io, even though you installed the integration. Before contacting support, there are some things you can try out yourself. Make sure that you are referencing one of the following NuGet packages: Elmah.Io , Elmah.Io.AspNet , Elmah.Io.Mvc or Elmah.Io.WebApi . Make sure that the Elmah.Io.Client NuGet package is installed and that the major version matches that of Elmah.Io , Elmah.Io.AspNet , Elmah.Io.Mvc or Elmah.Io.WebApi . Make sure that your project reference the following assemblies: Elmah , Elmah.Io , and Elmah.Io.Client . Make sure that your web.config file contains valid config as described here . You can validate your web.config file using this Web.config Validator . When installing the Elmah.Io NuGet package, config is automatically added to your web.config file, as long as your Visual Studio allows for running PowerShell scripts as part of the installation. To check if you have the correct execution policy, go to the Package Manager Console and verify that the result of the follow statement is RemoteSigned : Get-ExecutionPolicy Make sure that your server has an outgoing internet connection and that it can communicate with api.elmah.io on port 443 . Most of our integrations support setting up an HTTP proxy if your server doesn't allow outgoing traffic. Make sure that you didn't enable any Ignore filters or set up any Rules with an ignore action on the log in question. Make sure that you don't have any code catching all exceptions happening in your system and ignoring them (could be a logging filter or similar). If you are using custom errors, make sure to configure it correctly. For more details, check out the following posts: Web.config customErrors element with ASP.NET explained and Demystifying ASP.NET MVC 5 Error Pages and Error Logging . Common errors and how to fix them Here you will a list of common errors/exceptions and how to solve them. TypeLoadException Exception [TypeLoadException: Inheritance security rules violated by type: 'System.Net.Http.WebRequestHandler'. Derived types must either match the security accessibility of the base type or be less accessible.] Microsoft.Rest.ServiceClient`1.CreateRootHandler() +0 Microsoft.Rest.ServiceClient`1..ctor(DelegatingHandler[] handlers) +59 Elmah.Io.Client.ElmahioAPI..ctor(DelegatingHandler[] handlers) +96 Elmah.Io.Client.ElmahioAPI..ctor(ServiceClientCredentials credentials, DelegatingHandler[] handlers) +70 Elmah.Io.Client.ElmahioAPI.Create(String apiKey, ElmahIoOptions options) +146 Elmah.Io.Client.ElmahioAPI.Create(String apiKey) +91 Elmah.Io.ErrorLog..ctor(IDictionary config) +109 Solution This is most likely caused by a problem with the System.Net.Http NuGet package. Make sure to upgrade to the newest version ( 4.3.4 as of writing this). The default template for creating a new web application, installs version 4.3.0 which is seriously flawed. AmbiguousMatchException Exception [AmbiguousMatchException: Multiple custom attributes of the same type found.] System.Attribute.GetCustomAttribute(Assembly element, Type attributeType, Boolean inherit) +119 System.Reflection.CustomAttributeExtensions.GetCustomAttribute(Assembly element, Type attributeType) +16 Microsoft.Rest.ServiceClient`1.get_FrameworkVersion() +226 Microsoft.Rest.ServiceClient`1.SetDefaultAgentInfo() +93 Microsoft.Rest.ServiceClient`1.InitializeHttpClient(HttpClient httpClient, HttpClientHandler httpClientHandler, DelegatingHandler[] handlers) +386 Microsoft.Rest.ServiceClient`1..ctor(HttpClient serviceHttpClient, HttpClientHandler rootHandler, Boolean disposeHttpClient, DelegatingHandler[] delHandlers) +82 Microsoft.Rest.ServiceClient`1..ctor(HttpClientHandler rootHandler, DelegatingHandler[] handlers) +66 Elmah.Io.Client.ElmahioAPI..ctor(HttpClientHandler rootHandler, DelegatingHandler[] handlers) +104 Elmah.Io.Client.ElmahioAPI..ctor(ServiceClientCredentials credentials, HttpClientHandler rootHandler, DelegatingHandler[] handlers) +78 Elmah.Io.ErrorLog..ctor(IDictionary config) +225 [TargetInvocationException: Exception has been thrown by the target of an invocation.] System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor) +0 System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) +359 System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark) +1485 System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes) +298 System.Activator.CreateInstance(Type type, Object[] args) +34 Elmah.ErrorLog.GetDefaultImpl(HttpContext context) +178 Elmah.ServiceCenter.GetService(Object context, Type serviceType) +17 Elmah.ErrorLog.GetDefault(HttpContext context) +34 Elmah.ErrorPageBase.get_ErrorLog() +39 Elmah.ErrorLogPage.OnLoad(EventArgs e) +400 System.Web.UI.Control.LoadRecursive() +154 System.Web.UI.Page.ProcessRequestMain(Boolean includeStagesBeforeAsyncPoint, Boolean includeStagesAfterAsyncPoint) +4082 Solution This is most likely caused by some other software installed on the machine hosting your website. Applications like Microsoft Monitoring Agent (Application Insights) are known for creating problems for other software running on the same machine. Pause or stop any other monitoring service to see if the problem goes away. Exceptions aren't logged to elmah.io when adding the HandleError attribute Much like custom errors, the HandleError attribute can swallow exceptions from your website. This means that ASP.NET MVC catches any exceptions and show the Error.cshtml view. To log exceptions with this setup, you will need to extend your Error.cshtml file: @model System.Web.Mvc.HandleErrorInfo @{ if (Model.Exception != null) { Elmah.ErrorLog.GetDefault(HttpContext.Current).Log(new Elmah.Error(Model.Exception, HttpContext.Current)); } } <div> Your error page content goes here </div> Errors are not logged when using update panels ASP.NET Update Panels are great at many things. Unfortunately, one of those things is causing problems when trying to log server-side errors. If errors aren't logged as part of a call made from an update panel, you can try to add the following code to Global.asax.cs : protected void Application_Error(object sender, EventArgs e) { var ex = Server.GetLastError(); var error = new Elmah.Error(ex); error.ServerVariables.Add(\"URL\", HttpContext.Current?.Request?.Url?.AbsolutePath); error.ServerVariables.Add(\"HTTP_USER_AGENT\", HttpContext.Current?.Request?.UserAgent); error.ServerVariables.Add(\"REMOTE_ADDR\", HttpContext.Current?.Request?.UserHostAddress); Elmah.ErrorLog.GetDefault(HttpContext.Current).Log(error); }","title":"ASP.NET troubleshooting"},{"location":"asp-net-troubleshooting/#aspnet-troubleshooting","text":"You are probably here because your application doesn't log errors to elmah.io, even though you installed the integration. Before contacting support, there are some things you can try out yourself. Make sure that you are referencing one of the following NuGet packages: Elmah.Io , Elmah.Io.AspNet , Elmah.Io.Mvc or Elmah.Io.WebApi . Make sure that the Elmah.Io.Client NuGet package is installed and that the major version matches that of Elmah.Io , Elmah.Io.AspNet , Elmah.Io.Mvc or Elmah.Io.WebApi . Make sure that your project reference the following assemblies: Elmah , Elmah.Io , and Elmah.Io.Client . Make sure that your web.config file contains valid config as described here . You can validate your web.config file using this Web.config Validator . When installing the Elmah.Io NuGet package, config is automatically added to your web.config file, as long as your Visual Studio allows for running PowerShell scripts as part of the installation. To check if you have the correct execution policy, go to the Package Manager Console and verify that the result of the follow statement is RemoteSigned : Get-ExecutionPolicy Make sure that your server has an outgoing internet connection and that it can communicate with api.elmah.io on port 443 . Most of our integrations support setting up an HTTP proxy if your server doesn't allow outgoing traffic. Make sure that you didn't enable any Ignore filters or set up any Rules with an ignore action on the log in question. Make sure that you don't have any code catching all exceptions happening in your system and ignoring them (could be a logging filter or similar). If you are using custom errors, make sure to configure it correctly. For more details, check out the following posts: Web.config customErrors element with ASP.NET explained and Demystifying ASP.NET MVC 5 Error Pages and Error Logging .","title":"ASP.NET Troubleshooting"},{"location":"asp-net-troubleshooting/#common-errors-and-how-to-fix-them","text":"Here you will a list of common errors/exceptions and how to solve them.","title":"Common errors and how to fix them"},{"location":"asp-net-troubleshooting/#typeloadexception","text":"Exception [TypeLoadException: Inheritance security rules violated by type: 'System.Net.Http.WebRequestHandler'. Derived types must either match the security accessibility of the base type or be less accessible.] Microsoft.Rest.ServiceClient`1.CreateRootHandler() +0 Microsoft.Rest.ServiceClient`1..ctor(DelegatingHandler[] handlers) +59 Elmah.Io.Client.ElmahioAPI..ctor(DelegatingHandler[] handlers) +96 Elmah.Io.Client.ElmahioAPI..ctor(ServiceClientCredentials credentials, DelegatingHandler[] handlers) +70 Elmah.Io.Client.ElmahioAPI.Create(String apiKey, ElmahIoOptions options) +146 Elmah.Io.Client.ElmahioAPI.Create(String apiKey) +91 Elmah.Io.ErrorLog..ctor(IDictionary config) +109 Solution This is most likely caused by a problem with the System.Net.Http NuGet package. Make sure to upgrade to the newest version ( 4.3.4 as of writing this). The default template for creating a new web application, installs version 4.3.0 which is seriously flawed.","title":"TypeLoadException"},{"location":"asp-net-troubleshooting/#ambiguousmatchexception","text":"Exception [AmbiguousMatchException: Multiple custom attributes of the same type found.] System.Attribute.GetCustomAttribute(Assembly element, Type attributeType, Boolean inherit) +119 System.Reflection.CustomAttributeExtensions.GetCustomAttribute(Assembly element, Type attributeType) +16 Microsoft.Rest.ServiceClient`1.get_FrameworkVersion() +226 Microsoft.Rest.ServiceClient`1.SetDefaultAgentInfo() +93 Microsoft.Rest.ServiceClient`1.InitializeHttpClient(HttpClient httpClient, HttpClientHandler httpClientHandler, DelegatingHandler[] handlers) +386 Microsoft.Rest.ServiceClient`1..ctor(HttpClient serviceHttpClient, HttpClientHandler rootHandler, Boolean disposeHttpClient, DelegatingHandler[] delHandlers) +82 Microsoft.Rest.ServiceClient`1..ctor(HttpClientHandler rootHandler, DelegatingHandler[] handlers) +66 Elmah.Io.Client.ElmahioAPI..ctor(HttpClientHandler rootHandler, DelegatingHandler[] handlers) +104 Elmah.Io.Client.ElmahioAPI..ctor(ServiceClientCredentials credentials, HttpClientHandler rootHandler, DelegatingHandler[] handlers) +78 Elmah.Io.ErrorLog..ctor(IDictionary config) +225 [TargetInvocationException: Exception has been thrown by the target of an invocation.] System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor) +0 System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) +359 System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark) +1485 System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes) +298 System.Activator.CreateInstance(Type type, Object[] args) +34 Elmah.ErrorLog.GetDefaultImpl(HttpContext context) +178 Elmah.ServiceCenter.GetService(Object context, Type serviceType) +17 Elmah.ErrorLog.GetDefault(HttpContext context) +34 Elmah.ErrorPageBase.get_ErrorLog() +39 Elmah.ErrorLogPage.OnLoad(EventArgs e) +400 System.Web.UI.Control.LoadRecursive() +154 System.Web.UI.Page.ProcessRequestMain(Boolean includeStagesBeforeAsyncPoint, Boolean includeStagesAfterAsyncPoint) +4082 Solution This is most likely caused by some other software installed on the machine hosting your website. Applications like Microsoft Monitoring Agent (Application Insights) are known for creating problems for other software running on the same machine. Pause or stop any other monitoring service to see if the problem goes away.","title":"AmbiguousMatchException"},{"location":"asp-net-troubleshooting/#exceptions-arent-logged-to-elmahio-when-adding-the-handleerror-attribute","text":"Much like custom errors, the HandleError attribute can swallow exceptions from your website. This means that ASP.NET MVC catches any exceptions and show the Error.cshtml view. To log exceptions with this setup, you will need to extend your Error.cshtml file: @model System.Web.Mvc.HandleErrorInfo @{ if (Model.Exception != null) { Elmah.ErrorLog.GetDefault(HttpContext.Current).Log(new Elmah.Error(Model.Exception, HttpContext.Current)); } } <div> Your error page content goes here </div>","title":"Exceptions aren't logged to elmah.io when adding the HandleError attribute"},{"location":"asp-net-troubleshooting/#errors-are-not-logged-when-using-update-panels","text":"ASP.NET Update Panels are great at many things. Unfortunately, one of those things is causing problems when trying to log server-side errors. If errors aren't logged as part of a call made from an update panel, you can try to add the following code to Global.asax.cs : protected void Application_Error(object sender, EventArgs e) { var ex = Server.GetLastError(); var error = new Elmah.Error(ex); error.ServerVariables.Add(\"URL\", HttpContext.Current?.Request?.Url?.AbsolutePath); error.ServerVariables.Add(\"HTTP_USER_AGENT\", HttpContext.Current?.Request?.UserAgent); error.ServerVariables.Add(\"REMOTE_ADDR\", HttpContext.Current?.Request?.UserHostAddress); Elmah.ErrorLog.GetDefault(HttpContext.Current).Log(error); }","title":"Errors are not logged when using update panels"},{"location":"authentication/","text":"Authentication All of our integrations communicates with the elmah.io API. In order to request endpoints on the API, each client will need to provide a valid API key. API keys are available on the Organization Settings view, as well as on the Install tab on the Log Settings screen. We wrote a guide to help you find your API key here: Where is my API key? . A default API key is created when you create your organization, but new keys can be added, keys revoked, and more. Sending the API key to the elmah.io API, is typically handled by the Elmah.Io.Client NuGet package. All integrations have a dependency to this package, which means that it will be automatically installed through NuGet. How you provide your API key depends on the integration you are installing. Some integrations expect the API key in a config file, while others, accept the key in C#. For details about how to provide the API key for each integration, click the various installation guides in the left menu. Besides a unique string representing an API key, each key can have a set of permissions. As default, API keys only have the Write Messages permission, which means that the key cannot be used to read data from your logs. In 99% of all scenarios, you will browse through errors using the elmah.io UI, which will require you to sign in using username/password or one of the supported social providers. In the case where you want to enable the /elmah.axd endpoint (ASP.NET only) or you are building a third-party integration to elmah.io, you will need to assign additional permissions to your API key. For details about API key permissions, check out How to configure API key permissions .","title":"Authentication"},{"location":"authentication/#authentication","text":"All of our integrations communicates with the elmah.io API. In order to request endpoints on the API, each client will need to provide a valid API key. API keys are available on the Organization Settings view, as well as on the Install tab on the Log Settings screen. We wrote a guide to help you find your API key here: Where is my API key? . A default API key is created when you create your organization, but new keys can be added, keys revoked, and more. Sending the API key to the elmah.io API, is typically handled by the Elmah.Io.Client NuGet package. All integrations have a dependency to this package, which means that it will be automatically installed through NuGet. How you provide your API key depends on the integration you are installing. Some integrations expect the API key in a config file, while others, accept the key in C#. For details about how to provide the API key for each integration, click the various installation guides in the left menu. Besides a unique string representing an API key, each key can have a set of permissions. As default, API keys only have the Write Messages permission, which means that the key cannot be used to read data from your logs. In 99% of all scenarios, you will browse through errors using the elmah.io UI, which will require you to sign in using username/password or one of the supported social providers. In the case where you want to enable the /elmah.axd endpoint (ASP.NET only) or you are building a third-party integration to elmah.io, you will need to assign additional permissions to your API key. For details about API key permissions, check out How to configure API key permissions .","title":"Authentication"},{"location":"configure-elmah-io-from-code/","text":"Configure elmah.io from code You typically configure elmah.io in your web.config file. With a little help from some custom code, you will be able to configure everything in code as well: using Elmah; using System.Collections.Generic; using System.ComponentModel.Design; [assembly: WebActivatorEx.PreApplicationStartMethod(typeof(ElmahFromCodeExample.ElmahConfig), \"Start\")] namespace ElmahFromCodeExample { public static class ElmahConfig { public static void Start() { ServiceCenter.Current = CreateServiceProviderQueryHandler(ServiceCenter.Current); HttpApplication.RegisterModule(typeof(ErrorLogModule)); } private static ServiceProviderQueryHandler CreateServiceProviderQueryHandler(ServiceProviderQueryHandler sp) { return context => { var container = new ServiceContainer(sp(context)); var config = new Dictionary<string, string>(); config[\"apiKey\"] = \"API_KEY\"; config[\"logId\"] = \"LOG_ID\"; var log = new Elmah.Io.ErrorLog(config); container.AddService(typeof(Elmah.ErrorLog), log); return container; }; } } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with a log ID ( Where is my log ID? ). Let\u2019s look at the code. Our class ElmahConfig is configured as a PreApplicationStartMethod which means, that ASP.NET (MVC) will execute the Start method when the web application starts up. Inside this method we set the ServiceCenter.Current property to the return type of the CreateServiceProviderQueryHandler method. This method is where the magic happens. Besides creating the new ServiceContainer , we actually created the Elmah.Io.ErrorLog class normally configured through XML. The Dictionary should contain the API key and log ID as explained earlier. In the second line of the Start -method we call the RegisterModule -method with ErrorLogModule as parameter. This replaces the need for registering the module in web.config as part of the system.webServer element. That\u2019s it! You no longer need the <elmah> element, config sections or anything else related to ELMAH and elmah.io in your web.config file.","title":"Configure elmah.io from code"},{"location":"configure-elmah-io-from-code/#configure-elmahio-from-code","text":"You typically configure elmah.io in your web.config file. With a little help from some custom code, you will be able to configure everything in code as well: using Elmah; using System.Collections.Generic; using System.ComponentModel.Design; [assembly: WebActivatorEx.PreApplicationStartMethod(typeof(ElmahFromCodeExample.ElmahConfig), \"Start\")] namespace ElmahFromCodeExample { public static class ElmahConfig { public static void Start() { ServiceCenter.Current = CreateServiceProviderQueryHandler(ServiceCenter.Current); HttpApplication.RegisterModule(typeof(ErrorLogModule)); } private static ServiceProviderQueryHandler CreateServiceProviderQueryHandler(ServiceProviderQueryHandler sp) { return context => { var container = new ServiceContainer(sp(context)); var config = new Dictionary<string, string>(); config[\"apiKey\"] = \"API_KEY\"; config[\"logId\"] = \"LOG_ID\"; var log = new Elmah.Io.ErrorLog(config); container.AddService(typeof(Elmah.ErrorLog), log); return container; }; } } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with a log ID ( Where is my log ID? ). Let\u2019s look at the code. Our class ElmahConfig is configured as a PreApplicationStartMethod which means, that ASP.NET (MVC) will execute the Start method when the web application starts up. Inside this method we set the ServiceCenter.Current property to the return type of the CreateServiceProviderQueryHandler method. This method is where the magic happens. Besides creating the new ServiceContainer , we actually created the Elmah.Io.ErrorLog class normally configured through XML. The Dictionary should contain the API key and log ID as explained earlier. In the second line of the Start -method we call the RegisterModule -method with ErrorLogModule as parameter. This replaces the need for registering the module in web.config as part of the system.webServer element. That\u2019s it! You no longer need the <elmah> element, config sections or anything else related to ELMAH and elmah.io in your web.config file.","title":"Configure elmah.io from code"},{"location":"configure-elmah-io-manually/","text":"Configure elmah.io manually The Elmah.Io NuGet package normally adds all of the necessary configuration, in order to get up and running with elmah.io. In fact, this is one of our killer features and our customers tell us, that we have the simplest installer on the market. In some cases, you may experience problems with the automatic configuration, though. Different reasons can cause the configuration not to be added automatically. The most common reason is restrictions to executing PowerShell inside Visual Studio. Start by installing the Elmah.Io package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io If a dialog is shown during the installation, input your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Don't worry if the configuration isn't added, since we will verify this later. Add the following to the <configSections> element in your web.config : <sectionGroup name=\"elmah\"> <section name=\"security\" requirePermission=\"false\" type=\"Elmah.SecuritySectionHandler, Elmah\" /> <section name=\"errorLog\" requirePermission=\"false\" type=\"Elmah.ErrorLogSectionHandler, Elmah\" /> <section name=\"errorMail\" requirePermission=\"false\" type=\"Elmah.ErrorMailSectionHandler, Elmah\" /> <section name=\"errorFilter\" requirePermission=\"false\" type=\"Elmah.ErrorFilterSectionHandler, Elmah\" /> </sectionGroup> Add the following to the <httpModules> element (inside <system.web> ) in your web.config : <add name=\"ErrorLog\" type=\"Elmah.ErrorLogModule, Elmah\" /> <add name=\"ErrorMail\" type=\"Elmah.ErrorMailModule, Elmah\" /> <add name=\"ErrorFilter\" type=\"Elmah.ErrorFilterModule, Elmah\"/> Add the following to the <modules> element (inside <system.webServer> ) in your web.config : <add name=\"ErrorLog\" type=\"Elmah.ErrorLogModule, Elmah\" preCondition=\"managedHandler\" /> <add name=\"ErrorMail\" type=\"Elmah.ErrorMailModule, Elmah\" preCondition=\"managedHandler\" /> <add name=\"ErrorFilter\" type=\"Elmah.ErrorFilterModule, Elmah\" preCondition=\"managedHandler\" /> Add the following as a root element beneath the <configuration> element in your web.config : <elmah> <security allowRemoteAccess=\"false\" /> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> </elmah> Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log ID ( Where is my log ID? ). That's it. You managed to install elmah.io manually and you should go to your LinkedIn profile and update with a new certification called \"Certified elmah.io installer\" :) In case you need to access your error log on /elmah.axd , you need to add the following to the <configuration> element in your web.config : <location path=\"elmah.axd\" inheritInChildApplications=\"false\"> <system.web> <httpHandlers> <add verb=\"POST,GET,HEAD\" path=\"elmah.axd\" type=\"Elmah.ErrorLogPageFactory, Elmah\" /> </httpHandlers> </system.web> <system.webServer> <handlers> <add name=\"ELMAH\" verb=\"POST,GET,HEAD\" path=\"elmah.axd\" type=\"Elmah.ErrorLogPageFactory, Elmah\" preCondition=\"integratedMode\" /> </handlers> </system.webServer> </location>","title":"Configure elmah.io manually"},{"location":"configure-elmah-io-manually/#configure-elmahio-manually","text":"The Elmah.Io NuGet package normally adds all of the necessary configuration, in order to get up and running with elmah.io. In fact, this is one of our killer features and our customers tell us, that we have the simplest installer on the market. In some cases, you may experience problems with the automatic configuration, though. Different reasons can cause the configuration not to be added automatically. The most common reason is restrictions to executing PowerShell inside Visual Studio. Start by installing the Elmah.Io package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io If a dialog is shown during the installation, input your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Don't worry if the configuration isn't added, since we will verify this later. Add the following to the <configSections> element in your web.config : <sectionGroup name=\"elmah\"> <section name=\"security\" requirePermission=\"false\" type=\"Elmah.SecuritySectionHandler, Elmah\" /> <section name=\"errorLog\" requirePermission=\"false\" type=\"Elmah.ErrorLogSectionHandler, Elmah\" /> <section name=\"errorMail\" requirePermission=\"false\" type=\"Elmah.ErrorMailSectionHandler, Elmah\" /> <section name=\"errorFilter\" requirePermission=\"false\" type=\"Elmah.ErrorFilterSectionHandler, Elmah\" /> </sectionGroup> Add the following to the <httpModules> element (inside <system.web> ) in your web.config : <add name=\"ErrorLog\" type=\"Elmah.ErrorLogModule, Elmah\" /> <add name=\"ErrorMail\" type=\"Elmah.ErrorMailModule, Elmah\" /> <add name=\"ErrorFilter\" type=\"Elmah.ErrorFilterModule, Elmah\"/> Add the following to the <modules> element (inside <system.webServer> ) in your web.config : <add name=\"ErrorLog\" type=\"Elmah.ErrorLogModule, Elmah\" preCondition=\"managedHandler\" /> <add name=\"ErrorMail\" type=\"Elmah.ErrorMailModule, Elmah\" preCondition=\"managedHandler\" /> <add name=\"ErrorFilter\" type=\"Elmah.ErrorFilterModule, Elmah\" preCondition=\"managedHandler\" /> Add the following as a root element beneath the <configuration> element in your web.config : <elmah> <security allowRemoteAccess=\"false\" /> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> </elmah> Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log ID ( Where is my log ID? ). That's it. You managed to install elmah.io manually and you should go to your LinkedIn profile and update with a new certification called \"Certified elmah.io installer\" :) In case you need to access your error log on /elmah.axd , you need to add the following to the <configuration> element in your web.config : <location path=\"elmah.axd\" inheritInChildApplications=\"false\"> <system.web> <httpHandlers> <add verb=\"POST,GET,HEAD\" path=\"elmah.axd\" type=\"Elmah.ErrorLogPageFactory, Elmah\" /> </httpHandlers> </system.web> <system.webServer> <handlers> <add name=\"ELMAH\" verb=\"POST,GET,HEAD\" path=\"elmah.axd\" type=\"Elmah.ErrorLogPageFactory, Elmah\" preCondition=\"integratedMode\" /> </handlers> </system.webServer> </location>","title":"Configure elmah.io manually"},{"location":"create-deployments-from-atlassian-bamboo/","text":"Create deployments from Atlassian Bamboo Setting up elmah.io Deployment Tracking on Bamboo, is easy using a bit of PowerShell. Add a new Script Task and select Windows PowerShell in Interpreter . Select Inline in Script location and add the following PowerShell to Script body : $ProgressPreference = \"SilentlyContinue\" Write-Host $bamboo_buildNumber $url = \"https://api.elmah.io/v3/deployments?api_key=API_KEY\" $body = @{ version = $Env:bamboo_buildNumber logId = \"LOG_ID\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace API_KEY and LOG_ID and everything is configured. The script uses the build number of the current build as version number ( $Env:bamboo_buildNumber ). If you prefer another scheme, Bamboo offers a range of variables .","title":"Create deployments from Atlassian Bamboo"},{"location":"create-deployments-from-atlassian-bamboo/#create-deployments-from-atlassian-bamboo","text":"Setting up elmah.io Deployment Tracking on Bamboo, is easy using a bit of PowerShell. Add a new Script Task and select Windows PowerShell in Interpreter . Select Inline in Script location and add the following PowerShell to Script body : $ProgressPreference = \"SilentlyContinue\" Write-Host $bamboo_buildNumber $url = \"https://api.elmah.io/v3/deployments?api_key=API_KEY\" $body = @{ version = $Env:bamboo_buildNumber logId = \"LOG_ID\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace API_KEY and LOG_ID and everything is configured. The script uses the build number of the current build as version number ( $Env:bamboo_buildNumber ). If you prefer another scheme, Bamboo offers a range of variables .","title":"Create deployments from Atlassian Bamboo"},{"location":"create-deployments-from-azure-devops-pipelines/","text":"Create deployments from Azure DevOps Pipelines Create deployments from Azure DevOps Pipelines Using YAML Using Classic editor Notifying elmah.io about new deployments is possible as a build step in Azure DevOps, by adding a bit of PowerShell. Using YAML Edit your build definition YAML file. If not already shown, open the assistant by clicking the Show assistant button. Search for 'powershell'. Click the PowerShell task. Select the Inline radio button and input the following script: $ProgressPreference = \"SilentlyContinue\" $url = \"https://api.elmah.io/v3/deployments?api_key=API_KEY\" $body = @{ version = \"$env:BUILD_BUILDNUMBER\" description = \"$env:BUILD_SOURCEVERSIONMESSAGE\" userName = \"$env:BUILD_REQUESTEDFOR\" userEmail = \"$env:BUILD_REQUESTEDFOREMAIL\" logId = \"LOG_ID\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with the id of the log representing the application deployed by this build configuration. Click the Add button and the new task will be added to your YAML definition. You typically want to move the deployment task to the last placement in tasks . Using Classic editor Edit the build definition currently building your project(s). Click the Add task button and locate the PowerShell task. Click Add . Fill in the details as shown in the screenshot. ... and here's the code from the screenshot above: $ProgressPreference = \"SilentlyContinue\" $url = \"https://api.elmah.io/v3/deployments?api_key=API_KEY\" $body = @{ version = \"$env:BUILD_BUILDNUMBER\" description = \"$env:BUILD_SOURCEVERSIONMESSAGE\" userName = \"$env:BUILD_REQUESTEDFOR\" userEmail = \"$env:BUILD_REQUESTEDFOREMAIL\" logId = \"LOG_ID\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with the id of the log representing the application deployed by this build configuration.","title":"Create deployments from Azure DevOps Pipelines"},{"location":"create-deployments-from-azure-devops-pipelines/#create-deployments-from-azure-devops-pipelines","text":"Create deployments from Azure DevOps Pipelines Using YAML Using Classic editor Notifying elmah.io about new deployments is possible as a build step in Azure DevOps, by adding a bit of PowerShell.","title":"Create deployments from Azure DevOps Pipelines"},{"location":"create-deployments-from-azure-devops-pipelines/#using-yaml","text":"Edit your build definition YAML file. If not already shown, open the assistant by clicking the Show assistant button. Search for 'powershell'. Click the PowerShell task. Select the Inline radio button and input the following script: $ProgressPreference = \"SilentlyContinue\" $url = \"https://api.elmah.io/v3/deployments?api_key=API_KEY\" $body = @{ version = \"$env:BUILD_BUILDNUMBER\" description = \"$env:BUILD_SOURCEVERSIONMESSAGE\" userName = \"$env:BUILD_REQUESTEDFOR\" userEmail = \"$env:BUILD_REQUESTEDFOREMAIL\" logId = \"LOG_ID\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with the id of the log representing the application deployed by this build configuration. Click the Add button and the new task will be added to your YAML definition. You typically want to move the deployment task to the last placement in tasks .","title":"Using YAML"},{"location":"create-deployments-from-azure-devops-pipelines/#using-classic-editor","text":"Edit the build definition currently building your project(s). Click the Add task button and locate the PowerShell task. Click Add . Fill in the details as shown in the screenshot. ... and here's the code from the screenshot above: $ProgressPreference = \"SilentlyContinue\" $url = \"https://api.elmah.io/v3/deployments?api_key=API_KEY\" $body = @{ version = \"$env:BUILD_BUILDNUMBER\" description = \"$env:BUILD_SOURCEVERSIONMESSAGE\" userName = \"$env:BUILD_REQUESTEDFOR\" userEmail = \"$env:BUILD_REQUESTEDFOREMAIL\" logId = \"LOG_ID\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with the id of the log representing the application deployed by this build configuration.","title":"Using Classic editor"},{"location":"create-deployments-from-azure-devops-releases/","text":"Create deployments from Azure DevOps Releases If you are using Releases in Azure DevOps, you should use our extension to notify elmah.io about new deployments. To install and configure the extension, follow the simple steps below: Go to the elmah.io Deployment Tasks extension on the Visual Studio Marketplace and click Install (log in if not already). Select the account to install the extension into and click Confirm : Go to your Azure DevOps project and edit your Release definition. Click Add tasks and locate the elmah.io Deployment Notification task. Click Add . Copy an API key ( Where is my API key? ) with the Deployments | Write permission ( How to configure API key permissions ) from your organization settings page and paste it into the API Key field. In most cases, you want to input the ID of the log new deployments belong to. As default, we use the release name on Azure DevOps as the version number string on elmah.io. If you require a custom naming scheme, change the value in the Version field. All default and custom release variables are available through PowerShell variables. Finally, click Save . That's it! Azure DevOps will now notify elmah.io every time the release definition is executed. Remember to input a specific log ID ( Where is my log ID? ) as well, if you want to support versioning different services .","title":"Create deployments from Azure DevOps Releases"},{"location":"create-deployments-from-azure-devops-releases/#create-deployments-from-azure-devops-releases","text":"If you are using Releases in Azure DevOps, you should use our extension to notify elmah.io about new deployments. To install and configure the extension, follow the simple steps below: Go to the elmah.io Deployment Tasks extension on the Visual Studio Marketplace and click Install (log in if not already). Select the account to install the extension into and click Confirm : Go to your Azure DevOps project and edit your Release definition. Click Add tasks and locate the elmah.io Deployment Notification task. Click Add . Copy an API key ( Where is my API key? ) with the Deployments | Write permission ( How to configure API key permissions ) from your organization settings page and paste it into the API Key field. In most cases, you want to input the ID of the log new deployments belong to. As default, we use the release name on Azure DevOps as the version number string on elmah.io. If you require a custom naming scheme, change the value in the Version field. All default and custom release variables are available through PowerShell variables. Finally, click Save . That's it! Azure DevOps will now notify elmah.io every time the release definition is executed. Remember to input a specific log ID ( Where is my log ID? ) as well, if you want to support versioning different services .","title":"Create deployments from Azure DevOps Releases"},{"location":"create-deployments-from-bitbucket-pipelines/","text":"Create deployments from Bitbucket Pipelines Pipelines uses scripts, embedded in YAML-files, to configure the different steps required to build and deploy software. To notify elmah.io as part of a build/deployment, the first you will need to do, is to add your API key as a secure environment variable. To do so, go to Settings | Pipelines | Environment variables and add a new variable: Where is my API key? Then add a new script to your build YAML-file after building and deploying your software: pipelines: default: - step: script: # ... - curl -X POST -d \"{\\\"version\\\":\\\"$BITBUCKET_BUILD_NUMBER\\\"}\" -H \"Content-Type:application/json\" https://api.elmah.io/v3/deployments?api_key=$ELMAHIO_APIKEY The script uses curl to invoke the elmah.io Deployments endpoint with the API key ( $ELMAHIO_APIKEY ) and a version number ( $BITBUCKET_BUILD_NUMBER ). The posted JSON can be extended to support additional properties like changelog and the name of the person triggering the deployment. Check out the API documentation for details.","title":"Create deployments from Bitbucket Pipelines"},{"location":"create-deployments-from-bitbucket-pipelines/#create-deployments-from-bitbucket-pipelines","text":"Pipelines uses scripts, embedded in YAML-files, to configure the different steps required to build and deploy software. To notify elmah.io as part of a build/deployment, the first you will need to do, is to add your API key as a secure environment variable. To do so, go to Settings | Pipelines | Environment variables and add a new variable: Where is my API key? Then add a new script to your build YAML-file after building and deploying your software: pipelines: default: - step: script: # ... - curl -X POST -d \"{\\\"version\\\":\\\"$BITBUCKET_BUILD_NUMBER\\\"}\" -H \"Content-Type:application/json\" https://api.elmah.io/v3/deployments?api_key=$ELMAHIO_APIKEY The script uses curl to invoke the elmah.io Deployments endpoint with the API key ( $ELMAHIO_APIKEY ) and a version number ( $BITBUCKET_BUILD_NUMBER ). The posted JSON can be extended to support additional properties like changelog and the name of the person triggering the deployment. Check out the API documentation for details.","title":"Create deployments from Bitbucket Pipelines"},{"location":"create-deployments-from-github-actions/","text":"Create deployments from GitHub Actions GitHub Actions is a great platform for building and releasing software. To notify elmah.io when you deploy a new version of your project, you will need an additional step in your build definition. Before you do that, start by creating new secrets: Go to your project on GitHub. Click the Settings tab. Click the Secrets navigation item. Click Add a new secret . Name the secret ELMAH_IO_API_KEY . Insert your elmah.io API key in Value ( Where is my API key? ). Make sure to use an API key that includes the Deployments | Write permission ( How to configure API key permissions ). Click Add secret Do the same for your elmah.io log ID but name it ELMAH_IO_LOG_ID ( Where is my log ID? ). Insert the following step as the last one in your YAML build specification: - name: Notify elmah.io shell: powershell run: | $ProgressPreference = \"SilentlyContinue\" $url = \"https://api.elmah.io/v3/deployments?api_key=${{ secrets.ELMAH_IO_API_KEY }}\" $body = @{ version = \"${{ github.run_number }}\" userName = \"${{ github.actor }}\" logId = \"${{ secrets.ELMAH_IO_LOG_ID }}\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body","title":"Create deployments from GitHub Actions"},{"location":"create-deployments-from-github-actions/#create-deployments-from-github-actions","text":"GitHub Actions is a great platform for building and releasing software. To notify elmah.io when you deploy a new version of your project, you will need an additional step in your build definition. Before you do that, start by creating new secrets: Go to your project on GitHub. Click the Settings tab. Click the Secrets navigation item. Click Add a new secret . Name the secret ELMAH_IO_API_KEY . Insert your elmah.io API key in Value ( Where is my API key? ). Make sure to use an API key that includes the Deployments | Write permission ( How to configure API key permissions ). Click Add secret Do the same for your elmah.io log ID but name it ELMAH_IO_LOG_ID ( Where is my log ID? ). Insert the following step as the last one in your YAML build specification: - name: Notify elmah.io shell: powershell run: | $ProgressPreference = \"SilentlyContinue\" $url = \"https://api.elmah.io/v3/deployments?api_key=${{ secrets.ELMAH_IO_API_KEY }}\" $body = @{ version = \"${{ github.run_number }}\" userName = \"${{ github.actor }}\" logId = \"${{ secrets.ELMAH_IO_LOG_ID }}\" } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body","title":"Create deployments from GitHub Actions"},{"location":"create-deployments-from-kudu/","text":"Create deployments from Kudu Kudu is the engine behind Git deployments on Microsoft Azure. To create a new elmah.io deployment every time you deploy a new app service to Azure, add a new post deployment script by navigating your browser to https://yoursite.scm.azurewebsites.net where yoursite is the name of your Azure website. Click the Debug console and navigate to site\\deployments\\tools\\PostDeploymentActions (create it if it doesn't exist). To create the new PowerShell file, write the following in the prompt: touch CreateDeployment.ps1 With a post deployment script running inside Kudu, we have the possibility to extract some more information about the current deployment. A full deployment PowerShell script for Kudu, would look like this: $version = Get-Date -format u (Get-Content ..\\wwwroot\\web.config).replace('$version', $version) | Set-Content ..\\wwwroot\\web.config $ProgressPreference = \"SilentlyContinue\" $commit = [System.Environment]::GetEnvironmentVariable(\"SCM_COMMIT_MESSAGE\"); $commitId = [System.Environment]::GetEnvironmentVariable(\"SCM_COMMIT_ID\"); $httpHost = [System.Environment]::GetEnvironmentVariable(\"HTTP_HOST\"); $deployUrl = \"https://$httpHost/api/deployments/$commitId\" $username = \"MY_USERNAME\" $password = \"MY_PASSWORD\" $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes((\"{0}:{1}\" -f $username,$password))) $deployInfo = Invoke-RestMethod -Method Get -Uri $deployUrl -Headers @{Authorization=(\"Basic {0}\" -f $base64AuthInfo)} $url = 'https://api.elmah.io/v3/deployments?api_key=API_KEY' $body = @{ version = $version description = $commit userName = $deployInfo.author userEmail = $deployInfo.author_email } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body (replace MY_USERNAME and MY_PASSWORD with your Azure deployment credentials and API_KEY with your elmah.io API key located on your organization settings page) The script generates a new version string from the current date and time. How you want your version string looking, is really up to you. To fetch additional information about the deployment, the Kudu deployments endpoint is requested with the current commit id. Finally, the script creates the deployment using the elmah.io REST API.","title":"Create deployments from Kudu"},{"location":"create-deployments-from-kudu/#create-deployments-from-kudu","text":"Kudu is the engine behind Git deployments on Microsoft Azure. To create a new elmah.io deployment every time you deploy a new app service to Azure, add a new post deployment script by navigating your browser to https://yoursite.scm.azurewebsites.net where yoursite is the name of your Azure website. Click the Debug console and navigate to site\\deployments\\tools\\PostDeploymentActions (create it if it doesn't exist). To create the new PowerShell file, write the following in the prompt: touch CreateDeployment.ps1 With a post deployment script running inside Kudu, we have the possibility to extract some more information about the current deployment. A full deployment PowerShell script for Kudu, would look like this: $version = Get-Date -format u (Get-Content ..\\wwwroot\\web.config).replace('$version', $version) | Set-Content ..\\wwwroot\\web.config $ProgressPreference = \"SilentlyContinue\" $commit = [System.Environment]::GetEnvironmentVariable(\"SCM_COMMIT_MESSAGE\"); $commitId = [System.Environment]::GetEnvironmentVariable(\"SCM_COMMIT_ID\"); $httpHost = [System.Environment]::GetEnvironmentVariable(\"HTTP_HOST\"); $deployUrl = \"https://$httpHost/api/deployments/$commitId\" $username = \"MY_USERNAME\" $password = \"MY_PASSWORD\" $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes((\"{0}:{1}\" -f $username,$password))) $deployInfo = Invoke-RestMethod -Method Get -Uri $deployUrl -Headers @{Authorization=(\"Basic {0}\" -f $base64AuthInfo)} $url = 'https://api.elmah.io/v3/deployments?api_key=API_KEY' $body = @{ version = $version description = $commit userName = $deployInfo.author userEmail = $deployInfo.author_email } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body (replace MY_USERNAME and MY_PASSWORD with your Azure deployment credentials and API_KEY with your elmah.io API key located on your organization settings page) The script generates a new version string from the current date and time. How you want your version string looking, is really up to you. To fetch additional information about the deployment, the Kudu deployments endpoint is requested with the current commit id. Finally, the script creates the deployment using the elmah.io REST API.","title":"Create deployments from Kudu"},{"location":"create-deployments-from-octopus-deploy/","text":"Create deployments from Octopus Deploy Notifying elmah.io of a new deployment from Octopus Deploy, is supported through a custom step template. To install and configure the template, follow the steps below: Go to the elmah.io - Register Deployment step template on the Octopus Deploy Library. Click the Copy to clipboard button. Click Library in the header on your Octopus Deploy instance and go to the Step templates tab. Click the Import link and paste the step template copied from the Library. Then click Import . Go to the Process tab of your project on Octopus Deploy and click the Add step button. The elmah.io step template is available in the bottom of the list. When added to the process, select Octopus Server in Run on and input your API key found on your organization settings page. Optionally input a log ID, to support multiple services . And we're done. On every new deployment, Octopus Deploy will notify elmah.io.","title":"Create deployments from Octopus Deploy"},{"location":"create-deployments-from-octopus-deploy/#create-deployments-from-octopus-deploy","text":"Notifying elmah.io of a new deployment from Octopus Deploy, is supported through a custom step template. To install and configure the template, follow the steps below: Go to the elmah.io - Register Deployment step template on the Octopus Deploy Library. Click the Copy to clipboard button. Click Library in the header on your Octopus Deploy instance and go to the Step templates tab. Click the Import link and paste the step template copied from the Library. Then click Import . Go to the Process tab of your project on Octopus Deploy and click the Add step button. The elmah.io step template is available in the bottom of the list. When added to the process, select Octopus Server in Run on and input your API key found on your organization settings page. Optionally input a log ID, to support multiple services . And we're done. On every new deployment, Octopus Deploy will notify elmah.io.","title":"Create deployments from Octopus Deploy"},{"location":"create-deployments-from-powershell/","text":"Create deployments from PowerShell If you release your software using a build or deployment server, creating the new release is easy using a bit of PowerShell. To request the deployments endpoint, write the following PowerShell script: $version = \"1.42.7\" $ProgressPreference = \"SilentlyContinue\" $url = 'https://api.elmah.io/v3/deployments?api_key=API_KEY' $body = @{ version = $version } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body (replace API_KEY with your API key found on your organization settings page) In the example, a simple version string is sent to the API and elmah.io will automatically put a timestamp on that. Overriding user information and description, makes the experience within the elmah.io UI better. Pulling release notes and the name and email of the deployer, is usually available through environment variables or similar, depending on the technology used for creating the deployment.","title":"Create deployments from PowerShell"},{"location":"create-deployments-from-powershell/#create-deployments-from-powershell","text":"If you release your software using a build or deployment server, creating the new release is easy using a bit of PowerShell. To request the deployments endpoint, write the following PowerShell script: $version = \"1.42.7\" $ProgressPreference = \"SilentlyContinue\" $url = 'https://api.elmah.io/v3/deployments?api_key=API_KEY' $body = @{ version = $version } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body (replace API_KEY with your API key found on your organization settings page) In the example, a simple version string is sent to the API and elmah.io will automatically put a timestamp on that. Overriding user information and description, makes the experience within the elmah.io UI better. Pulling release notes and the name and email of the deployer, is usually available through environment variables or similar, depending on the technology used for creating the deployment.","title":"Create deployments from PowerShell"},{"location":"create-deployments-from-umbraco-cloud/","text":"Create deployments from Umbraco Cloud Umbraco Cloud uses Azure to host Umbraco websites, why supporting deployment tracking pretty much corresponds the steps specified in Using Kudu . Navigate to https://your-umbraco-site.scm.s1.umbraco.io where your-umbraco-site is the name of your Umbraco site. Click the Debug console link and navigate to site\\deployments\\tools\\PostDeploymentActions\\deploymenthooks (create it if it doesn't exist). Notice the folder deploymenthooks , which is required in order for your scripts to run on Umbraco Cloud. Unlike Kudu, Umbraco Cloud only executes cmd and bat files. Create a new cmd file: touch create-deployment.cmd with the following content: echo \"Creating elmah.io deployment\" cd %POST_DEPLOYMENT_ACTIONS_DIR% cd deploymenthooks powershell -command \". .\\create-deployment.ps1\" The script executes a PowerShell script, which we will create next: touch create-deployment.ps1 The content of the PowerShell script looks a lot like in Using Kudu , but with some minor tweaks to support Umbraco Cloud: $version = Get-Date -format u $ProgressPreference = \"SilentlyContinue\" $commitId = [System.Environment]::GetEnvironmentVariable(\"SCM_COMMIT_ID\"); $deployUrl = \"https://your-umbraco-site.scm.s1.umbraco.io/api/deployments/$commitId\" $username = \"MY_USERNAME\" $password = \"MY_PASSWORD\" $logId = \"LOG_ID\" $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes((\"{0}:{1}\" -f $username,$password))) $deployInfo = Invoke-RestMethod -Method Get -Uri $deployUrl -Headers @{Authorization=(\"Basic {0}\" -f $base64AuthInfo)} $url = 'https://api.elmah.io/v3/deployments?api_key=API_KEY' $body = @{ version = $version description = $deployInfo.message userName = $deployInfo.author userEmail = $deployInfo.author_email logId = $logId } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace your-umbraco-site with the name of your site, MY_USERNAME with your Umbraco Cloud username, MY_PASSWORD with your Umbraco Cloud password, LOG_ID with the id if the elmah.io log that should contain the deployments ( Where is my log ID? ) and finally API_KEY with your elmah.io API key, found and your organization settings page. There you go. When deploying changes to your Umbraco Cloud site, a new deployment is automatically created on elmah.io.","title":"Create deployments from Umbraco Cloud"},{"location":"create-deployments-from-umbraco-cloud/#create-deployments-from-umbraco-cloud","text":"Umbraco Cloud uses Azure to host Umbraco websites, why supporting deployment tracking pretty much corresponds the steps specified in Using Kudu . Navigate to https://your-umbraco-site.scm.s1.umbraco.io where your-umbraco-site is the name of your Umbraco site. Click the Debug console link and navigate to site\\deployments\\tools\\PostDeploymentActions\\deploymenthooks (create it if it doesn't exist). Notice the folder deploymenthooks , which is required in order for your scripts to run on Umbraco Cloud. Unlike Kudu, Umbraco Cloud only executes cmd and bat files. Create a new cmd file: touch create-deployment.cmd with the following content: echo \"Creating elmah.io deployment\" cd %POST_DEPLOYMENT_ACTIONS_DIR% cd deploymenthooks powershell -command \". .\\create-deployment.ps1\" The script executes a PowerShell script, which we will create next: touch create-deployment.ps1 The content of the PowerShell script looks a lot like in Using Kudu , but with some minor tweaks to support Umbraco Cloud: $version = Get-Date -format u $ProgressPreference = \"SilentlyContinue\" $commitId = [System.Environment]::GetEnvironmentVariable(\"SCM_COMMIT_ID\"); $deployUrl = \"https://your-umbraco-site.scm.s1.umbraco.io/api/deployments/$commitId\" $username = \"MY_USERNAME\" $password = \"MY_PASSWORD\" $logId = \"LOG_ID\" $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes((\"{0}:{1}\" -f $username,$password))) $deployInfo = Invoke-RestMethod -Method Get -Uri $deployUrl -Headers @{Authorization=(\"Basic {0}\" -f $base64AuthInfo)} $url = 'https://api.elmah.io/v3/deployments?api_key=API_KEY' $body = @{ version = $version description = $deployInfo.message userName = $deployInfo.author userEmail = $deployInfo.author_email logId = $logId } [Net.ServicePointManager]::SecurityProtocol = ` [Net.SecurityProtocolType]::Tls12, [Net.SecurityProtocolType]::Tls11, [Net.SecurityProtocolType]::Tls Invoke-RestMethod -Method Post -Uri $url -Body $body Replace your-umbraco-site with the name of your site, MY_USERNAME with your Umbraco Cloud username, MY_PASSWORD with your Umbraco Cloud password, LOG_ID with the id if the elmah.io log that should contain the deployments ( Where is my log ID? ) and finally API_KEY with your elmah.io API key, found and your organization settings page. There you go. When deploying changes to your Umbraco Cloud site, a new deployment is automatically created on elmah.io.","title":"Create deployments from Umbraco Cloud"},{"location":"creating-apps-for-elmah-io/","text":"Creating Apps for elmah.io Creating Apps for elmah.io Creating manifest.json Creating a NuSpec Building and Publishing the App Testing the Package Creating apps for elmah.io is no longer supported. Get in contact if you need an integration not already available in the app store. Developing custom apps for elmah.io is possible through a bit of JSON and NuGet magic. This document will show you how. Apps on elmah.io are basically a nice wrapper around the Business Rule Engine on elmah.io. Using business rules, users can execute various actions based on full-text and Lucene queries against logged messages. Ignore messages based on a specific user agent or call the Slack API when fatal messages are logged are just a few examples on the possibilities using rules. For this example, we'll create a small app posting requests to RequestBin on every error. Probably not the most usable app, but serves the example well. RequestBin works by creating a bin, which you can then create HTTP requests against. Each bin contains a unique ID, which we will use in a second. Creating manifest.json To start creating the app, create a new file named manifest.json : { \"variables\": [{ \"key\": \"bin\", \"name\": \"Bin\", \"description\": \"The Id of the bin to post to\", \"example\": \"1k5c4qb2\", \"type\": \"text\", \"required\": true }], \"rule\": { \"title\": \"Post a message to RequestBin on all messages\", \"query\": \"severity: Error\", \"then\": { \"type\": \"http\", \"url\": \"https://requestbin.fullcontact.com/$bin\", \"method\": \"post\", \"contentType\": \"application/json\", \"body\": \"{\\\"timestamp\\\": \\\"$time\\\", \\\"message\\\": \\\"$message\\\", \\\"severity\\\": \\\"$severity\\\"}\" } } } The manifest consists of two blocks: variables and rule . Variables serves as input for generating the UI when users add the app to their log on elmah.io. In variables you can ask the user for information needed in order to execute the rule like username and password, access tokens or as in this example, an id of a bin on RequestBin. For now, only text , choice and number variables are available, but we may extend this with other types like bool , ipaddress etc. The rule section tell elmah.io what this app should do. Specifying a rule is optional and makes sense when creating apps that listen for messages matching a query. The two important fields to notice here is query and then . These terms match 1:1 to the same terms in the business rules. query should contain either a full-text query string or a Lucene query. Every message logged, matching this query, triggers the then part of this app. For the simple app, we query messages based on severity . For a complete list of search fields, visit the Rules tab on your log settings. In the then section we tell elmah.io what to do with messages matching the query . In this case, we want it to create a new HTTP request on https://requestbin.fullcontact.com. Notice how the $bin variables from before is used as part of the URL. body contains examples on built-in variables like $message and $time . Built-in variables are documented on the Rules tab of the log settings as well. A final note about then . In this example we use the \"type\": \"http\" to allow elmah.io to make HTTP requests. Types corresponding to other actions available in the rule engine are available as well. These are ignore , hide and email . Creating a NuSpec Apps for elmah.io are distributed as NuGet packages. There's a few requirements you will need to satisfy in order for your app to show up in the elmah.io UI. Let's write a NuSpec for our app named elmah.io.apps.requestbin.nuspec : <?xml version=\"1.0\"?> <package xmlns=\"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\"> <metadata> <version>1.0.0</version> <authors>elmah.io</authors> <owners>elmah.io</owners> <id>elmah.io.apps.requestbin</id> <title>RequestBin Integration</title> <requireLicenseAcceptance>false</requireLicenseAcceptance> <description>Post a new HTTP request to RequestBin when messages are logged in elmah.io.</description> <projectUrl>https://github.com/elmahio/elmah.io.apps.requestbin</projectUrl> <iconUrl>https://secure.gravatar.com/avatar/5c4cb3646528821117abde6d2d5ee22d?s=32</iconUrl> </metadata> <files> <file src=\"manifest.json\" target=\"manifest.json\" /> </files> </package> The configuration is pretty simple. We include a single file ( manifest.json ) in the root of the package and name the package. The name needs to be all-lowercase and prefixed with elmah.io.apps. in order to show up on elmah.io. Building and Publishing the App To build the app, we use nuget.exe : c:\\projects\\elmah.io.apps.requestbin>nuget pack Attempting to build package from 'elmah.io.apps.requestbin.nuspec'. Successfully created package 'c:\\projects\\elmah.io.apps.requestbin\\elmah.io.apps.requestbin.1.0.0.nupkg'. To upload the package to NuGet, use nuget push : c:\\projects\\elmah.io.apps.requestbin>nuget push elmah.io.apps.requestbin.1.0.0.nupkg MyApiKey Pushing elmah.io.apps.requestbin 1.0.0 to the NuGet gallery (https://www.nuget.org)... Your package was pushed. (replace MyApiKey with your API Key located on nuget.org) That's it folks. The app is now public and available on elmah.io. Testing the Package To test that everything is working, we'll start by creating a new bin on RequestBin. Go to RequestBin and click the Create a RequestBin button: In this case, the bin ID is 1chhlvo1 . Log into elmah.io and go to the Apps tab on the log settings. The RequestBin app is available from the list of apps in the bottom. Click the Install button: Observe how the bin variable from manifest.json shows up in the log settings with the description and example as we specified. Input the bin ID and click the Save button. To test that everything is working, you can use elmah.io's API to publish a new message to your log, which should match the query specified in manifest.json : curl -H \"Content-Type: application/json\" -X POST -d '{\"title\": \"Manual error\", \"severity\": \"Error\"}' https://api.elmah.io/v3/messages/LOG_ID (replace LOG_ID with your log ID) Refresh the bin at RequestBin and observe the HTTP request performed by the app: Isn't that just the most awesome thing you have seen all day? The JSON format specified in manifest.json now ends up on RequestBin using a homebrewed elmah.io app.","title":"Creating apps for elmah.io"},{"location":"creating-apps-for-elmah-io/#creating-apps-for-elmahio","text":"Creating Apps for elmah.io Creating manifest.json Creating a NuSpec Building and Publishing the App Testing the Package Creating apps for elmah.io is no longer supported. Get in contact if you need an integration not already available in the app store. Developing custom apps for elmah.io is possible through a bit of JSON and NuGet magic. This document will show you how. Apps on elmah.io are basically a nice wrapper around the Business Rule Engine on elmah.io. Using business rules, users can execute various actions based on full-text and Lucene queries against logged messages. Ignore messages based on a specific user agent or call the Slack API when fatal messages are logged are just a few examples on the possibilities using rules. For this example, we'll create a small app posting requests to RequestBin on every error. Probably not the most usable app, but serves the example well. RequestBin works by creating a bin, which you can then create HTTP requests against. Each bin contains a unique ID, which we will use in a second.","title":"Creating Apps for elmah.io"},{"location":"creating-apps-for-elmah-io/#creating-manifestjson","text":"To start creating the app, create a new file named manifest.json : { \"variables\": [{ \"key\": \"bin\", \"name\": \"Bin\", \"description\": \"The Id of the bin to post to\", \"example\": \"1k5c4qb2\", \"type\": \"text\", \"required\": true }], \"rule\": { \"title\": \"Post a message to RequestBin on all messages\", \"query\": \"severity: Error\", \"then\": { \"type\": \"http\", \"url\": \"https://requestbin.fullcontact.com/$bin\", \"method\": \"post\", \"contentType\": \"application/json\", \"body\": \"{\\\"timestamp\\\": \\\"$time\\\", \\\"message\\\": \\\"$message\\\", \\\"severity\\\": \\\"$severity\\\"}\" } } } The manifest consists of two blocks: variables and rule . Variables serves as input for generating the UI when users add the app to their log on elmah.io. In variables you can ask the user for information needed in order to execute the rule like username and password, access tokens or as in this example, an id of a bin on RequestBin. For now, only text , choice and number variables are available, but we may extend this with other types like bool , ipaddress etc. The rule section tell elmah.io what this app should do. Specifying a rule is optional and makes sense when creating apps that listen for messages matching a query. The two important fields to notice here is query and then . These terms match 1:1 to the same terms in the business rules. query should contain either a full-text query string or a Lucene query. Every message logged, matching this query, triggers the then part of this app. For the simple app, we query messages based on severity . For a complete list of search fields, visit the Rules tab on your log settings. In the then section we tell elmah.io what to do with messages matching the query . In this case, we want it to create a new HTTP request on https://requestbin.fullcontact.com. Notice how the $bin variables from before is used as part of the URL. body contains examples on built-in variables like $message and $time . Built-in variables are documented on the Rules tab of the log settings as well. A final note about then . In this example we use the \"type\": \"http\" to allow elmah.io to make HTTP requests. Types corresponding to other actions available in the rule engine are available as well. These are ignore , hide and email .","title":"Creating manifest.json"},{"location":"creating-apps-for-elmah-io/#creating-a-nuspec","text":"Apps for elmah.io are distributed as NuGet packages. There's a few requirements you will need to satisfy in order for your app to show up in the elmah.io UI. Let's write a NuSpec for our app named elmah.io.apps.requestbin.nuspec : <?xml version=\"1.0\"?> <package xmlns=\"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\"> <metadata> <version>1.0.0</version> <authors>elmah.io</authors> <owners>elmah.io</owners> <id>elmah.io.apps.requestbin</id> <title>RequestBin Integration</title> <requireLicenseAcceptance>false</requireLicenseAcceptance> <description>Post a new HTTP request to RequestBin when messages are logged in elmah.io.</description> <projectUrl>https://github.com/elmahio/elmah.io.apps.requestbin</projectUrl> <iconUrl>https://secure.gravatar.com/avatar/5c4cb3646528821117abde6d2d5ee22d?s=32</iconUrl> </metadata> <files> <file src=\"manifest.json\" target=\"manifest.json\" /> </files> </package> The configuration is pretty simple. We include a single file ( manifest.json ) in the root of the package and name the package. The name needs to be all-lowercase and prefixed with elmah.io.apps. in order to show up on elmah.io.","title":"Creating a NuSpec"},{"location":"creating-apps-for-elmah-io/#building-and-publishing-the-app","text":"To build the app, we use nuget.exe : c:\\projects\\elmah.io.apps.requestbin>nuget pack Attempting to build package from 'elmah.io.apps.requestbin.nuspec'. Successfully created package 'c:\\projects\\elmah.io.apps.requestbin\\elmah.io.apps.requestbin.1.0.0.nupkg'. To upload the package to NuGet, use nuget push : c:\\projects\\elmah.io.apps.requestbin>nuget push elmah.io.apps.requestbin.1.0.0.nupkg MyApiKey Pushing elmah.io.apps.requestbin 1.0.0 to the NuGet gallery (https://www.nuget.org)... Your package was pushed. (replace MyApiKey with your API Key located on nuget.org) That's it folks. The app is now public and available on elmah.io.","title":"Building and Publishing the App"},{"location":"creating-apps-for-elmah-io/#testing-the-package","text":"To test that everything is working, we'll start by creating a new bin on RequestBin. Go to RequestBin and click the Create a RequestBin button: In this case, the bin ID is 1chhlvo1 . Log into elmah.io and go to the Apps tab on the log settings. The RequestBin app is available from the list of apps in the bottom. Click the Install button: Observe how the bin variable from manifest.json shows up in the log settings with the description and example as we specified. Input the bin ID and click the Save button. To test that everything is working, you can use elmah.io's API to publish a new message to your log, which should match the query specified in manifest.json : curl -H \"Content-Type: application/json\" -X POST -d '{\"title\": \"Manual error\", \"severity\": \"Error\"}' https://api.elmah.io/v3/messages/LOG_ID (replace LOG_ID with your log ID) Refresh the bin at RequestBin and observe the HTTP request performed by the app: Isn't that just the most awesome thing you have seen all day? The JSON format specified in manifest.json now ends up on RequestBin using a homebrewed elmah.io app.","title":"Testing the Package"},{"location":"creating-rules-to-perform-actions-on-messages/","text":"Creating Rules to Perform Actions on Messages elmah.io comes with a great rule engine for performing various actions when messages are logged in your log. This guide is also available as a short video tutorial here: The rule engine is located beneath each log on the log settings page: A rule consists of three parts: a title, a query and an action. The title should be a short text explaining what this rule does. We don't use the title for anything, so please write something that helps you identify rules and to keep them apart. The query should contain either a full-text search string or a Lucene query. When new messages are logged, the message is matched up against all queries registered on that log. If and only if a message matches a query, the action registered on the rule is performed. As mentioned above, the action part of a rule is executed when a message matches the query specified in the same rule. An action can be one of four types: Ignore, Hide, Mail and HTTP Request. In order to illustrate how to use each action type, here are four examples on useful rules. Ignore errors with a HTTP status code of 400 To ignore all messages with a HTTP status code of 400, you would need to set-up the following: Title Query Then Ignore 400s statusCode:400 Ignore The rule would look like this in the UI: Hide warnings To hide all messages with a severity of Warning , you would need to set up the following: Title Query Then Hide Warnings severity:Warning Hide The rule would look like this in the UI: Send an email on all messages containing a word To send an email on all messages containing the word billing somewhere, you would need to set up the following: Title Query Then Mail on billing billing Email The rule would look like this in the UI: Make a HTTP request on all new and fatal messages To make a HTTP request on every new message with a severity of Fatal , you would need to set up the following: Title Query Then Request on new fatal isNew:true AND severity:Fatal HTTP The rule would look like this in the UI:","title":"Creating Rules to Perform Actions on Messages"},{"location":"creating-rules-to-perform-actions-on-messages/#creating-rules-to-perform-actions-on-messages","text":"elmah.io comes with a great rule engine for performing various actions when messages are logged in your log. This guide is also available as a short video tutorial here: The rule engine is located beneath each log on the log settings page: A rule consists of three parts: a title, a query and an action. The title should be a short text explaining what this rule does. We don't use the title for anything, so please write something that helps you identify rules and to keep them apart. The query should contain either a full-text search string or a Lucene query. When new messages are logged, the message is matched up against all queries registered on that log. If and only if a message matches a query, the action registered on the rule is performed. As mentioned above, the action part of a rule is executed when a message matches the query specified in the same rule. An action can be one of four types: Ignore, Hide, Mail and HTTP Request. In order to illustrate how to use each action type, here are four examples on useful rules.","title":"Creating Rules to Perform Actions on Messages"},{"location":"creating-rules-to-perform-actions-on-messages/#ignore-errors-with-a-http-status-code-of-400","text":"To ignore all messages with a HTTP status code of 400, you would need to set-up the following: Title Query Then Ignore 400s statusCode:400 Ignore The rule would look like this in the UI:","title":"Ignore errors with a HTTP status code of 400"},{"location":"creating-rules-to-perform-actions-on-messages/#hide-warnings","text":"To hide all messages with a severity of Warning , you would need to set up the following: Title Query Then Hide Warnings severity:Warning Hide The rule would look like this in the UI:","title":"Hide warnings"},{"location":"creating-rules-to-perform-actions-on-messages/#send-an-email-on-all-messages-containing-a-word","text":"To send an email on all messages containing the word billing somewhere, you would need to set up the following: Title Query Then Mail on billing billing Email The rule would look like this in the UI:","title":"Send an email on all messages containing a word"},{"location":"creating-rules-to-perform-actions-on-messages/#make-a-http-request-on-all-new-and-fatal-messages","text":"To make a HTTP request on every new message with a severity of Fatal , you would need to set up the following: Title Query Then Request on new fatal isNew:true AND severity:Fatal HTTP The rule would look like this in the UI:","title":"Make a HTTP request on all new and fatal messages"},{"location":"elmah-and-custom-errors/","text":"ELMAH and custom errors ELMAH and ASP.NET (MVC) custom errors isn't exactly known to be best friends. Question after question have been posted on forums like Stack Overflow, from people having problems with ELMAH, when custom errors are configured. In fact, these problems make perfect sense, since both ELMAH and custom errors are designed to catch errors and do something about them. Before looking at some code, we really recommend you to read Web.config customErrors element with ASP.NET explained and Demystifying ASP.NET MVC 5 Error Pages and Error Logging . Together, the posts are a great introduction to different ways of implementing custom error pages in ASP.NET MVC. Back to ELMAH. In most implementations of custom error pages, ASP.NET actually swallows any uncaught exceptions, putting ELMAH out of play. To overcome this issue, you can utilize MVC's IExceptionFilter to log all exceptions, whether or not it is handled by a custom error page: public class ElmahExceptionLogger : IExceptionFilter { public void OnException (ExceptionContext context) { if (context.ExceptionHandled) { ErrorSignal.FromCurrentContext().Raise(context.Exception); } } } The OnException method on ElmahExceptionLogger is executed every time an error is happening, by registering it in Application_Start : protected void Application_Start() { // ... GlobalConfiguration.Configuration.Filters.Add(new ElmahExceptionLogger()); // ... }","title":"ELMAH and custom errors"},{"location":"elmah-and-custom-errors/#elmah-and-custom-errors","text":"ELMAH and ASP.NET (MVC) custom errors isn't exactly known to be best friends. Question after question have been posted on forums like Stack Overflow, from people having problems with ELMAH, when custom errors are configured. In fact, these problems make perfect sense, since both ELMAH and custom errors are designed to catch errors and do something about them. Before looking at some code, we really recommend you to read Web.config customErrors element with ASP.NET explained and Demystifying ASP.NET MVC 5 Error Pages and Error Logging . Together, the posts are a great introduction to different ways of implementing custom error pages in ASP.NET MVC. Back to ELMAH. In most implementations of custom error pages, ASP.NET actually swallows any uncaught exceptions, putting ELMAH out of play. To overcome this issue, you can utilize MVC's IExceptionFilter to log all exceptions, whether or not it is handled by a custom error page: public class ElmahExceptionLogger : IExceptionFilter { public void OnException (ExceptionContext context) { if (context.ExceptionHandled) { ErrorSignal.FromCurrentContext().Raise(context.Exception); } } } The OnException method on ElmahExceptionLogger is executed every time an error is happening, by registering it in Application_Start : protected void Application_Start() { // ... GlobalConfiguration.Configuration.Filters.Add(new ElmahExceptionLogger()); // ... }","title":"ELMAH and custom errors"},{"location":"elmah-and-elmah-io-differences/","text":"ELMAH and elmah.io differences We receive a lot of questions like these: What is the difference between ELMAH and elmah.io? I though ELMAH was free. Why do you suddenly charge? My ELMAH SQL Server configuration doesn't work. Why not? We totally understand the confusion. The purpose of this article is to give a bit of background of what the differences between ELMAH and elmah.io and why they share similar names. What is ELMAH? ELMAH is an error logging framework originally developed by Atif Aziz able to log all unhandled exceptions from .NET web applications. Errors can be logged to a variety of destinations through ELMAH\u2019s plugin model called error logs. Plugins for XML, SQL Server, MySQL, Elasticsearch and many more exists. ELMAH automatically collects a lot of information from the HTTP context when logging the error, giving you the possibility to inspect request parameters, cookies and much more for the failed request. Custom errors can be logged to ELMAH, by manually calling the error log. What is elmah.io? elmah.io is a cloud-based error management system originally developed on top of ELMAH (see history for details). Besides supporting ELMAH, elmah.io also integrates with popular logging frameworks like log4net , NLog , Serilog and web frameworks like ASP.NET Core . elmah.io offers a superior notification model to ELMAH, with integrations to mail, Slack, HipChat and many others. elmah.io also built a lot of features outside the scope of ELMAH, like a complete uptime monitoring system. Comparison Feature ELMAH elmah.io Error Logging \u2705 \u2705 Self-hosted \u2705 \u274c Cloud-hosted \u274c \u2705 Search \u274c \u2705 New error detection \u274c \u2705 Error grouping \u274c \u2705 Issue tracking \u274c \u2705 log4net / NLog / Serilog \u274c \u2705 Clientside error logging \u274c \u2705 Slack/Teams/HipChat/etc. \u274c \u2705 Deployment tracking \u274c \u2705 Uptime monitoring \u274c \u2705 Heartbeats \u274c \u2705 Discount on popular software \u274c \u2705 History So, why name a service elmah.io, when only a minor part of a client integration uses ELMAH? When elmah.io was introduced back in 2013, the intention was to create a cloud-based error logger for ELMAH. We had some simple search and graphing possibilities, but the platform was meant as an alternative to host your own errors logs in SQL Server or similar. In time, elmah.io grew from being a hobby project to an actual company. During those years, we realized that the potential of the platform exceeded the possibilities with ELMAH in many ways. New features not available in ELMAH have been added constantly. A process that would have been nearly impossible with ELMAH's many storage integrations. Today, elmah.io is a full error management system for everything from console applications to web apps and serverless code hosted on Azure or AWS. We've built an entire uptime monitoring system, able to monitor not only if your website fails but also if it even responds to requests. Why not change the name to something else, you may be thinking? That is our wish as well. But changing your SaaS (software-as-a-service) company name isn't exactly easy. We have tried a couple of times, first time back in 2016. We tried to name the different major features of elmah.io to sea creatures (like Stingray). We failed with the rename and people got confused. In 2017, we started looking at renaming the product again. This time to Unbug. We had learned from our previous mistake and this time silently started changing the name. We quickly realized that the domain change would cause a major risk in regards to SEO (search engine optimization) and confusion. For now, we are elmah.io. The name is not ideal, but it's definitely a lesson learned for another time :)","title":"ELMAH and elmah.io differences"},{"location":"elmah-and-elmah-io-differences/#elmah-and-elmahio-differences","text":"We receive a lot of questions like these: What is the difference between ELMAH and elmah.io? I though ELMAH was free. Why do you suddenly charge? My ELMAH SQL Server configuration doesn't work. Why not? We totally understand the confusion. The purpose of this article is to give a bit of background of what the differences between ELMAH and elmah.io and why they share similar names.","title":"ELMAH and elmah.io differences"},{"location":"elmah-and-elmah-io-differences/#what-is-elmah","text":"ELMAH is an error logging framework originally developed by Atif Aziz able to log all unhandled exceptions from .NET web applications. Errors can be logged to a variety of destinations through ELMAH\u2019s plugin model called error logs. Plugins for XML, SQL Server, MySQL, Elasticsearch and many more exists. ELMAH automatically collects a lot of information from the HTTP context when logging the error, giving you the possibility to inspect request parameters, cookies and much more for the failed request. Custom errors can be logged to ELMAH, by manually calling the error log.","title":"What is ELMAH?"},{"location":"elmah-and-elmah-io-differences/#what-is-elmahio","text":"elmah.io is a cloud-based error management system originally developed on top of ELMAH (see history for details). Besides supporting ELMAH, elmah.io also integrates with popular logging frameworks like log4net , NLog , Serilog and web frameworks like ASP.NET Core . elmah.io offers a superior notification model to ELMAH, with integrations to mail, Slack, HipChat and many others. elmah.io also built a lot of features outside the scope of ELMAH, like a complete uptime monitoring system.","title":"What is elmah.io?"},{"location":"elmah-and-elmah-io-differences/#comparison","text":"Feature ELMAH elmah.io Error Logging \u2705 \u2705 Self-hosted \u2705 \u274c Cloud-hosted \u274c \u2705 Search \u274c \u2705 New error detection \u274c \u2705 Error grouping \u274c \u2705 Issue tracking \u274c \u2705 log4net / NLog / Serilog \u274c \u2705 Clientside error logging \u274c \u2705 Slack/Teams/HipChat/etc. \u274c \u2705 Deployment tracking \u274c \u2705 Uptime monitoring \u274c \u2705 Heartbeats \u274c \u2705 Discount on popular software \u274c \u2705","title":"Comparison"},{"location":"elmah-and-elmah-io-differences/#history","text":"So, why name a service elmah.io, when only a minor part of a client integration uses ELMAH? When elmah.io was introduced back in 2013, the intention was to create a cloud-based error logger for ELMAH. We had some simple search and graphing possibilities, but the platform was meant as an alternative to host your own errors logs in SQL Server or similar. In time, elmah.io grew from being a hobby project to an actual company. During those years, we realized that the potential of the platform exceeded the possibilities with ELMAH in many ways. New features not available in ELMAH have been added constantly. A process that would have been nearly impossible with ELMAH's many storage integrations. Today, elmah.io is a full error management system for everything from console applications to web apps and serverless code hosted on Azure or AWS. We've built an entire uptime monitoring system, able to monitor not only if your website fails but also if it even responds to requests. Why not change the name to something else, you may be thinking? That is our wish as well. But changing your SaaS (software-as-a-service) company name isn't exactly easy. We have tried a couple of times, first time back in 2016. We tried to name the different major features of elmah.io to sea creatures (like Stingray). We failed with the rename and people got confused. In 2017, we started looking at renaming the product again. This time to Unbug. We had learned from our previous mistake and this time silently started changing the name. We quickly realized that the domain change would cause a major risk in regards to SEO (search engine optimization) and confusion. For now, we are elmah.io. The name is not ideal, but it's definitely a lesson learned for another time :)","title":"History"},{"location":"elmah-io-apps-azure-boards/","text":"Install Azure Boards App for elmah.io Get your personal access token In order to create bugs on Azure Boards, you will need to generate a personal access token. Go to Azure DevOps and click your user in the top right corner. Click Security in the dropdown and select the Personal access token item in the left menu. Finally, click the New token button and fill in the details as shown below: For this example, I have picket the longest possible expiration period, but you can decide for a shorter period if you'd like. Remember to enable the Read & write scope. Next, click the Create button and copy the generated token. Bugs created by elmah.io will have the CreatedBy set to the user generating the personal access token. If you want to identify bugs created by elmah.io, you should create the token from a new user (like elmahio@yourdomain.com). Install the Azure Boards App on elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Azure Boards app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Organization textbox, input the name of your organization. For https://dev.azure.com/myorg/myproject, the organization name would be myorg . In the Project textbox, input the name of the project containing your board. For https://dev.azure.com/myorg/myproject, the project name would be myproject . Click Save and the app is added to your log. When new errors are logged, bugs are automatically created in the configured Azure Board.","title":"Azure Boards"},{"location":"elmah-io-apps-azure-boards/#install-azure-boards-app-for-elmahio","text":"","title":"Install Azure Boards App for elmah.io"},{"location":"elmah-io-apps-azure-boards/#get-your-personal-access-token","text":"In order to create bugs on Azure Boards, you will need to generate a personal access token. Go to Azure DevOps and click your user in the top right corner. Click Security in the dropdown and select the Personal access token item in the left menu. Finally, click the New token button and fill in the details as shown below: For this example, I have picket the longest possible expiration period, but you can decide for a shorter period if you'd like. Remember to enable the Read & write scope. Next, click the Create button and copy the generated token. Bugs created by elmah.io will have the CreatedBy set to the user generating the personal access token. If you want to identify bugs created by elmah.io, you should create the token from a new user (like elmahio@yourdomain.com).","title":"Get your personal access token"},{"location":"elmah-io-apps-azure-boards/#install-the-azure-boards-app-on-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Azure Boards app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Organization textbox, input the name of your organization. For https://dev.azure.com/myorg/myproject, the organization name would be myorg . In the Project textbox, input the name of the project containing your board. For https://dev.azure.com/myorg/myproject, the project name would be myproject . Click Save and the app is added to your log. When new errors are logged, bugs are automatically created in the configured Azure Board.","title":"Install the Azure Boards App on elmah.io"},{"location":"elmah-io-apps-bitbucket/","text":"Install Bitbucket App for elmah.io Get your API key In order to allow elmah.io to create issues on Bitbucket, you will need your team's API key. API keys on Bitbucket are only supported om team accounts. Go to your team's settings page (like https://bitbucket.org/account/user/elmahio/groups/) and click API key in the menu: Copy the generated API key. Install the Bitbucket App on elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Bitbucket app and click the Install button: Paste the API key copied in the previous step into the API Key textbox. In the Team textbox, input the name of the team owning the repository you want to create issues in. In the Repository textbox input the name of the repository. Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured Bitbucket repository.","title":"Bitbucket"},{"location":"elmah-io-apps-bitbucket/#install-bitbucket-app-for-elmahio","text":"","title":"Install Bitbucket App for elmah.io"},{"location":"elmah-io-apps-bitbucket/#get-your-api-key","text":"In order to allow elmah.io to create issues on Bitbucket, you will need your team's API key. API keys on Bitbucket are only supported om team accounts. Go to your team's settings page (like https://bitbucket.org/account/user/elmahio/groups/) and click API key in the menu: Copy the generated API key.","title":"Get your API key"},{"location":"elmah-io-apps-bitbucket/#install-the-bitbucket-app-on-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Bitbucket app and click the Install button: Paste the API key copied in the previous step into the API Key textbox. In the Team textbox, input the name of the team owning the repository you want to create issues in. In the Repository textbox input the name of the repository. Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured Bitbucket repository.","title":"Install the Bitbucket App on elmah.io"},{"location":"elmah-io-apps-botbuster/","text":"Install BotBuster App for elmah.io The BotBuster app is deprecated. Enable the Filter Crawlers toggle on the Filters tab to ignore errors generated by crawlers. The BotBuster app for elmah.io, identifies and ignores messages generated by white hat bots like spiders, search engine bots and similar. Under normal circumstances, you want to allow access for white hat bots, but you don't want to get a notification every time one of them tries to request a resource not found on the server. Installing BotBuster couldn't be simpler. Log into elmah.io and go to the log settings. Click the Apps tab. Locate the BotBuster app and click the Install button.","title":"BotBuster"},{"location":"elmah-io-apps-botbuster/#install-botbuster-app-for-elmahio","text":"The BotBuster app is deprecated. Enable the Filter Crawlers toggle on the Filters tab to ignore errors generated by crawlers. The BotBuster app for elmah.io, identifies and ignores messages generated by white hat bots like spiders, search engine bots and similar. Under normal circumstances, you want to allow access for white hat bots, but you don't want to get a notification every time one of them tries to request a resource not found on the server. Installing BotBuster couldn't be simpler. Log into elmah.io and go to the log settings. Click the Apps tab. Locate the BotBuster app and click the Install button.","title":"Install BotBuster App for elmah.io"},{"location":"elmah-io-apps-github/","text":"Install GitHub App for elmah.io Generate Personal Access Token In order to allow elmah.io to create issues on GitHub, you will need to generate a Personal Access Token. To do so, log into GitHub and go to the New personal access token page. Input a token description, click the Generate token button and copy the generated token (colored with a green background). Install the GitHub App on elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the GitHub app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Owner textbox, input the name of the user or organization owning the repository you want to create issues in. In the Repository textbox input the name of the repository. Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured GitHub repository.","title":"GitHub"},{"location":"elmah-io-apps-github/#install-github-app-for-elmahio","text":"","title":"Install GitHub App for elmah.io"},{"location":"elmah-io-apps-github/#generate-personal-access-token","text":"In order to allow elmah.io to create issues on GitHub, you will need to generate a Personal Access Token. To do so, log into GitHub and go to the New personal access token page. Input a token description, click the Generate token button and copy the generated token (colored with a green background).","title":"Generate Personal Access Token"},{"location":"elmah-io-apps-github/#install-the-github-app-on-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the GitHub app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Owner textbox, input the name of the user or organization owning the repository you want to create issues in. In the Repository textbox input the name of the repository. Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured GitHub repository.","title":"Install the GitHub App on elmah.io"},{"location":"elmah-io-apps-gitlab/","text":"Install GitLab App for elmah.io Generate Personal Access Token In order to allow elmah.io to create issues on GitLab, you will need to generate a Personal Access Token. To do so, log into GitLab and go to the Access Tokens page. Input a token name. check the api checkbox, click the Create personal access token button and copy the generated token. Install the GitLab App on elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the GitLab app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Project textbox, input the ID or name of the project you want issues created on. If you are self-hosting GitLab, input your custom URL in the URL textbox (example https://gitlab.hooli.com). Click the Test button and observe it turn green. When clicking Save , the app is added to your log. When new errors are logged, issues are automatically created in the configured GitLab project.","title":"GitLab"},{"location":"elmah-io-apps-gitlab/#install-gitlab-app-for-elmahio","text":"","title":"Install GitLab App for elmah.io"},{"location":"elmah-io-apps-gitlab/#generate-personal-access-token","text":"In order to allow elmah.io to create issues on GitLab, you will need to generate a Personal Access Token. To do so, log into GitLab and go to the Access Tokens page. Input a token name. check the api checkbox, click the Create personal access token button and copy the generated token.","title":"Generate Personal Access Token"},{"location":"elmah-io-apps-gitlab/#install-the-gitlab-app-on-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the GitLab app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Project textbox, input the ID or name of the project you want issues created on. If you are self-hosting GitLab, input your custom URL in the URL textbox (example https://gitlab.hooli.com). Click the Test button and observe it turn green. When clicking Save , the app is added to your log. When new errors are logged, issues are automatically created in the configured GitLab project.","title":"Install the GitLab App on elmah.io"},{"location":"elmah-io-apps-hipchat/","text":"Install HipChat App for elmah.io Generate OAuth 2 Token In order to allow elmah.io to log messages to HipChat, you will need to generate an OAuth 2 token. To do so, log into HipChat and go to the API Access page (replace elmahio with your subdomain). Input a label, click the Create button and copy the generated token. If you want to test your configuration using the Test button on the elmah.io UI, you wiill need to select both Send Notification and View Room in Scopes . Install the HipChat App on elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the HipChat app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Room textbox, input the name of the HipChat chat room you want messages from elmah.io to show up in. Click Save and the app is added to your log. When new errors are logged, messages start appearing in the chat room that you configured. HipChat doesn't allow more than 500 requests per 5 minutes. If you generate more messages to elmah.io, not all of them will show up in HipChat because of this. Finally, if you need more control on what to log, you should read our guide on Integrating elmah.io with HipChat manually .","title":"HipChat"},{"location":"elmah-io-apps-hipchat/#install-hipchat-app-for-elmahio","text":"","title":"Install HipChat App for elmah.io"},{"location":"elmah-io-apps-hipchat/#generate-oauth-2-token","text":"In order to allow elmah.io to log messages to HipChat, you will need to generate an OAuth 2 token. To do so, log into HipChat and go to the API Access page (replace elmahio with your subdomain). Input a label, click the Create button and copy the generated token. If you want to test your configuration using the Test button on the elmah.io UI, you wiill need to select both Send Notification and View Room in Scopes .","title":"Generate OAuth 2 Token"},{"location":"elmah-io-apps-hipchat/#install-the-hipchat-app-on-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the HipChat app and click the Install button: Paste the token copied in the previous step into the Token textbox. In the Room textbox, input the name of the HipChat chat room you want messages from elmah.io to show up in. Click Save and the app is added to your log. When new errors are logged, messages start appearing in the chat room that you configured. HipChat doesn't allow more than 500 requests per 5 minutes. If you generate more messages to elmah.io, not all of them will show up in HipChat because of this. Finally, if you need more control on what to log, you should read our guide on Integrating elmah.io with HipChat manually .","title":"Install the HipChat App on elmah.io"},{"location":"elmah-io-apps-ipfilter/","text":"Install IP Filter App for elmah.io The IP Filter app is deprecated. The IP Filter filter on the Filters tab offers more advanced IP filtering. The IP Filter app for elmah.io, automatically ignores messages from one or more IP addresses. This is a great way to ignore errors generated by both crawlers and errors generated by you. To install IP Filter, click the Install button on the Apps tab. This will show the IP Filter settings page: To ignore messages from a single IP address, input the IP in both the From and To fields. To ignore messages from a range of IP addresses, input the start and end IP address in the From and To fields. Both IP addresses are included in the ignored range. The IP Filter app ignores every message matching the specified IP range. This means that if you are logging something like Information messages through Serilog or similar, these messages are also ignored. In order for a message to have an IP, you will need to specify a server variable named REMOTE_ADDR when creating the message. This variable is automatically added (if available) when using the integration for ELMAH.","title":"IP Filter"},{"location":"elmah-io-apps-ipfilter/#install-ip-filter-app-for-elmahio","text":"The IP Filter app is deprecated. The IP Filter filter on the Filters tab offers more advanced IP filtering. The IP Filter app for elmah.io, automatically ignores messages from one or more IP addresses. This is a great way to ignore errors generated by both crawlers and errors generated by you. To install IP Filter, click the Install button on the Apps tab. This will show the IP Filter settings page: To ignore messages from a single IP address, input the IP in both the From and To fields. To ignore messages from a range of IP addresses, input the start and end IP address in the From and To fields. Both IP addresses are included in the ignored range. The IP Filter app ignores every message matching the specified IP range. This means that if you are logging something like Information messages through Serilog or similar, these messages are also ignored. In order for a message to have an IP, you will need to specify a server variable named REMOTE_ADDR when creating the message. This variable is automatically added (if available) when using the integration for ELMAH.","title":"Install IP Filter App for elmah.io"},{"location":"elmah-io-apps-jira/","text":"Install Jira App for elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Jira app and click the Install button: Input your site name, which is the first part of the URL you use to log into Jira. For the URL https://elmahio.atlassian.net/ , the site parameter would be elmahio . In the Project field, input the key of the project. Note that a project has both a display name and a key. The property we are looking for here is the uppercase identifier of the project. To create issues on Jira, you will need to input the username and password of a user with permission to create issues in the project specified above. You can use your user credentials, but we recommend using a combination of your username and an API token. To generate a new token specific for elmah.io, go to https://id.atlassian.com/manage/api-tokens . Then click the Create API token button and input a label of your choice. Finally, click the Create button and an API token is generated for you. Make sure to copy this token, since you won't be able to access it once the dialog is closed. Go back to elmah.io and input your email in the Username field and the API token from the previous step in the Password field. If you don't like to use an existing user account for the integration, you can create a new Atlassian account for elmah.io and generate the API token from that account instead. Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured Jira project. Troubleshooting If errors aren't showing up in Jira, please check that the following are all true: When clicking the Test button on the Jira app settings screen, the button turns green. There's a message logged in the log where you set up the Jira integration. The message is marked as new (yellow start next to the title on the search result). The message is either of severity Error or Fatal . To trigger an error manually, go to https://api.elmah.io/swagger/ui/index and input an elmah.io API key with the Messages - Write permission enabled. Expand Messages and the POST node with the URL /v3/messages/{logId} . Input your log ID and the following JSON: { \"title\": \"This is a test\", \"severity\": \"Error\" } Finally, click the Try it out! button and verify that the API returns a status code of 201 . The new error should show up in Jira. If testing this multiple times, you will need to make small adjustments to the title field inside the JSON, for additional errors to be marked as new.","title":"Jira"},{"location":"elmah-io-apps-jira/#install-jira-app-for-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Jira app and click the Install button: Input your site name, which is the first part of the URL you use to log into Jira. For the URL https://elmahio.atlassian.net/ , the site parameter would be elmahio . In the Project field, input the key of the project. Note that a project has both a display name and a key. The property we are looking for here is the uppercase identifier of the project. To create issues on Jira, you will need to input the username and password of a user with permission to create issues in the project specified above. You can use your user credentials, but we recommend using a combination of your username and an API token. To generate a new token specific for elmah.io, go to https://id.atlassian.com/manage/api-tokens . Then click the Create API token button and input a label of your choice. Finally, click the Create button and an API token is generated for you. Make sure to copy this token, since you won't be able to access it once the dialog is closed. Go back to elmah.io and input your email in the Username field and the API token from the previous step in the Password field. If you don't like to use an existing user account for the integration, you can create a new Atlassian account for elmah.io and generate the API token from that account instead. Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured Jira project.","title":"Install Jira App for elmah.io"},{"location":"elmah-io-apps-jira/#troubleshooting","text":"If errors aren't showing up in Jira, please check that the following are all true: When clicking the Test button on the Jira app settings screen, the button turns green. There's a message logged in the log where you set up the Jira integration. The message is marked as new (yellow start next to the title on the search result). The message is either of severity Error or Fatal . To trigger an error manually, go to https://api.elmah.io/swagger/ui/index and input an elmah.io API key with the Messages - Write permission enabled. Expand Messages and the POST node with the URL /v3/messages/{logId} . Input your log ID and the following JSON: { \"title\": \"This is a test\", \"severity\": \"Error\" } Finally, click the Try it out! button and verify that the API returns a status code of 201 . The new error should show up in Jira. If testing this multiple times, you will need to make small adjustments to the title field inside the JSON, for additional errors to be marked as new.","title":"Troubleshooting"},{"location":"elmah-io-apps-mailman/","text":"Install Mailman App for elmah.io The Mailman app is deprecated. Use an email rule available on the Rules tab for more a more advanced email integration. The Mailman app for elmah.io sends out an email to an address of your choice, every time a new error is logged. To install Mailman, click the Install button on the Apps tab. This will show the Mailman settings page: Input a valid email address in the Email input box and click Save . The Mailman app will look at new errors only. Errors are defined by messages with a severity of Error or Fatal and with isNew == true . isNew is a field automatically added by elmah.io when indexing each message. isNew is calculated by looking for similarities between the new message and already logged messages.","title":"Mailman"},{"location":"elmah-io-apps-mailman/#install-mailman-app-for-elmahio","text":"The Mailman app is deprecated. Use an email rule available on the Rules tab for more a more advanced email integration. The Mailman app for elmah.io sends out an email to an address of your choice, every time a new error is logged. To install Mailman, click the Install button on the Apps tab. This will show the Mailman settings page: Input a valid email address in the Email input box and click Save . The Mailman app will look at new errors only. Errors are defined by messages with a severity of Error or Fatal and with isNew == true . isNew is a field automatically added by elmah.io when indexing each message. isNew is calculated by looking for similarities between the new message and already logged messages.","title":"Install Mailman App for elmah.io"},{"location":"elmah-io-apps-slack/","text":"Install Slack App for elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Slack app and click the Install button. You will be asked to allow access from elmah.io: Select your team and in the following screen, select the channel you want to show errors on Slack: Click the Authorize button and you will be redirected to elmah.io. The integration to Slack is now installed. Slack doesn't allow more than a single request per second. If you generate more than one message to elmah.io per second, not all of them will show up in Slack because of this. Troubleshooting Errors don't show up in Slack. Here are a few things to try out. Make sure that the Slack app is installed on the log as described above. Only new errors are sent to Slack. New errors are marked with a yellow star on the search tab. We only sent new errors to help you stay out of Slack's API limits. If sending all errors, you could quickly end up in a scenario where the same error gets sent multiple times and then more important errors gets ignored by Slack. Make sure that your token is still valid. The only way to resolve an issue where the token is no longer valid is to re-install the Slack app.","title":"Slack"},{"location":"elmah-io-apps-slack/#install-slack-app-for-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Slack app and click the Install button. You will be asked to allow access from elmah.io: Select your team and in the following screen, select the channel you want to show errors on Slack: Click the Authorize button and you will be redirected to elmah.io. The integration to Slack is now installed. Slack doesn't allow more than a single request per second. If you generate more than one message to elmah.io per second, not all of them will show up in Slack because of this.","title":"Install Slack App for elmah.io"},{"location":"elmah-io-apps-slack/#troubleshooting","text":"Errors don't show up in Slack. Here are a few things to try out. Make sure that the Slack app is installed on the log as described above. Only new errors are sent to Slack. New errors are marked with a yellow star on the search tab. We only sent new errors to help you stay out of Slack's API limits. If sending all errors, you could quickly end up in a scenario where the same error gets sent multiple times and then more important errors gets ignored by Slack. Make sure that your token is still valid. The only way to resolve an issue where the token is no longer valid is to re-install the Slack app.","title":"Troubleshooting"},{"location":"elmah-io-apps-teams/","text":"Install Microsoft Teams App for elmah.io To install the integration with Microsoft Teams, go to teams and click the Store menu item. Search for \"elmah.io\" and click the app: Select your team and click the Install button: Select which channel you want elmah.io messages in and click the Set up button: A new webhook URL is generated. Click the Copy Text button followed by the Save button: The elmah.io integration is now configured on Microsoft Teams and you should see the following screen: The final step is to input the webhook URL that you just copied, into elmah.io. Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Microsoft Teams app and click the Install button. In the overlay, paste the URL from the previous step: Click Save and the app is added to your log. When new errors are logged, messages start appearing in the channel that you configured. The Office 365 API used behind the scenes for this app uses throttling rather than a maximum of allowed requests. This means that you may start experiencing messages not being sent, if you start logging a large amount of messages. We have experienced a lot of weird error codes when communicating with the API. An example of this is an exception while posting data to the API, but the data is successfully shown on Teams. The result of this error is, that elmah.io retries the failing request multiple times, which causes the same message to be shown multiple times on Teams.","title":"Microsoft Teams"},{"location":"elmah-io-apps-teams/#install-microsoft-teams-app-for-elmahio","text":"To install the integration with Microsoft Teams, go to teams and click the Store menu item. Search for \"elmah.io\" and click the app: Select your team and click the Install button: Select which channel you want elmah.io messages in and click the Set up button: A new webhook URL is generated. Click the Copy Text button followed by the Save button: The elmah.io integration is now configured on Microsoft Teams and you should see the following screen: The final step is to input the webhook URL that you just copied, into elmah.io. Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Microsoft Teams app and click the Install button. In the overlay, paste the URL from the previous step: Click Save and the app is added to your log. When new errors are logged, messages start appearing in the channel that you configured. The Office 365 API used behind the scenes for this app uses throttling rather than a maximum of allowed requests. This means that you may start experiencing messages not being sent, if you start logging a large amount of messages. We have experienced a lot of weird error codes when communicating with the API. An example of this is an exception while posting data to the API, but the data is successfully shown on Teams. The result of this error is, that elmah.io retries the failing request multiple times, which causes the same message to be shown multiple times on Teams.","title":"Install Microsoft Teams App for elmah.io"},{"location":"elmah-io-apps-trello/","text":"Install Trello App for elmah.io For elmah.io to communicate with the Trello API, we will need an API key and token. The API key is available here: https://trello.com/app-key . To get the token, visit the following URL in your browser: https://trello.com/1/authorize?expiration=never&scope=read,write,account&response_type=token&name=Server%20Token&key=API_KEY . Remember to replace API_KEY with your Trello API key located in the previous step. When clicking the Allow button, Trello will generate a new token for you and show it in the browser window. elmah.io will create cards on a board list of your choice. Unfortunately, Trello didn't provide a way to obtain list IDs. The easiest way is to open Developer Tools in your browser and click an existing card inside the list you want elmah.io to create new cards in. Locate the request for the card details in the Network tab and click the Preview tab. The list id is in the card details: Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Trello app and click the Install button: Input the API key, token, and list ID, all located in the previous steps. Click the Test button to test that everything works and finally, click Save . New errors now trigger elmah.io to create a card with the details of the error in Trello. Troubleshooting If errors aren't showing up in Trello, please check that the following are all true: When clicking the Test button on the Trello app settings screen, the button turns green. There's a message logged in the log where you set up the Trello integration. The message is marked as new (yellow start next to the title on the search result). The message is either of severity Error or Fatal . To trigger an error manually, go to https://api.elmah.io/swagger/ui/index and input an elmah.io API key with the Messages - Write permission enabled. Expand Messages and the POST node with the URL /v3/messages/{logId} . Input your log ID and the following JSON: { \"title\": \"This is a test\", \"severity\": \"Error\" } Finally, click the Try it out! button and verify that the API returns a status code of 201 . The new error should show up in Trello. If testing this multiple times, you will need to make small adjustments to the title field inside the JSON, for additional errors to be marked as new.","title":"Trello"},{"location":"elmah-io-apps-trello/#install-trello-app-for-elmahio","text":"For elmah.io to communicate with the Trello API, we will need an API key and token. The API key is available here: https://trello.com/app-key . To get the token, visit the following URL in your browser: https://trello.com/1/authorize?expiration=never&scope=read,write,account&response_type=token&name=Server%20Token&key=API_KEY . Remember to replace API_KEY with your Trello API key located in the previous step. When clicking the Allow button, Trello will generate a new token for you and show it in the browser window. elmah.io will create cards on a board list of your choice. Unfortunately, Trello didn't provide a way to obtain list IDs. The easiest way is to open Developer Tools in your browser and click an existing card inside the list you want elmah.io to create new cards in. Locate the request for the card details in the Network tab and click the Preview tab. The list id is in the card details: Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Trello app and click the Install button: Input the API key, token, and list ID, all located in the previous steps. Click the Test button to test that everything works and finally, click Save . New errors now trigger elmah.io to create a card with the details of the error in Trello.","title":"Install Trello App for elmah.io"},{"location":"elmah-io-apps-trello/#troubleshooting","text":"If errors aren't showing up in Trello, please check that the following are all true: When clicking the Test button on the Trello app settings screen, the button turns green. There's a message logged in the log where you set up the Trello integration. The message is marked as new (yellow start next to the title on the search result). The message is either of severity Error or Fatal . To trigger an error manually, go to https://api.elmah.io/swagger/ui/index and input an elmah.io API key with the Messages - Write permission enabled. Expand Messages and the POST node with the URL /v3/messages/{logId} . Input your log ID and the following JSON: { \"title\": \"This is a test\", \"severity\": \"Error\" } Finally, click the Try it out! button and verify that the API returns a status code of 201 . The new error should show up in Trello. If testing this multiple times, you will need to make small adjustments to the title field inside the JSON, for additional errors to be marked as new.","title":"Troubleshooting"},{"location":"elmah-io-apps-twilio/","text":"Install Twilio for elmah.io To send SMS/Text messages with Twilio, you will need to sign up for Twilio first. Twilio provides a range of good tutorials when signing up, why we don't want to duplicate them here. When signed up, you will have access to a Twilio phone number to send messages from, an Account SID and a token needed to authenticate Twilio. These pieces of information will be used below when installing the Twilio app on elmah.io. Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Twilio app and click the Install button: Input your Twilio phone number (available here ) in the From field. Input the phone number you want receiving error reports from elmah.io in the To field. Remember to fully qualify the number with a plus and the language code (US example: +12025550170 - UK example: +441632960775). Copy your Account SID and Auth Token from the Twilio Dashboard and input them in the fields on elmah.io. Click Save and the app is added to your log. When new errors are logged, an SMS/Text message is automatically sent to the configured phone number. Troubleshooting If errors aren't being sent to your phone, verify that the configured variables work. To do so, replace the four variables in the top of this PowerShell script and execute it: $sid = \"INSERT_SID\" $token = \"INSERT_TOKEN\" $from = \"INSERT_FROM\" $to = \"INSERT_TO\" $url = \"https://api.twilio.com/2010-04-01/Accounts/$sid/Messages.json\" $pair = \"$($sid):$($token)\" $encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair)) $basicAuthValue = \"Basic $encodedCreds\" $Headers = @{ Authorization = $basicAuthValue ContentType = \"application/x-www-form-urlencoded\" } $from = $from.Replace(\"+\", \"%2B\") $to = $to.Replace(\"+\", \"%2B\") $response = Invoke-WebRequest -Uri $url -Method POST -Headers $Headers -Body \"Body=Affirmative&From=$from&To=$to\" You should see a text message on your phone. The script will output any errors from Twilio if something isn't working.","title":"Twilio"},{"location":"elmah-io-apps-twilio/#install-twilio-for-elmahio","text":"To send SMS/Text messages with Twilio, you will need to sign up for Twilio first. Twilio provides a range of good tutorials when signing up, why we don't want to duplicate them here. When signed up, you will have access to a Twilio phone number to send messages from, an Account SID and a token needed to authenticate Twilio. These pieces of information will be used below when installing the Twilio app on elmah.io. Log into elmah.io and go to the log settings. Click the Apps tab. Locate the Twilio app and click the Install button: Input your Twilio phone number (available here ) in the From field. Input the phone number you want receiving error reports from elmah.io in the To field. Remember to fully qualify the number with a plus and the language code (US example: +12025550170 - UK example: +441632960775). Copy your Account SID and Auth Token from the Twilio Dashboard and input them in the fields on elmah.io. Click Save and the app is added to your log. When new errors are logged, an SMS/Text message is automatically sent to the configured phone number.","title":"Install Twilio for elmah.io"},{"location":"elmah-io-apps-twilio/#troubleshooting","text":"If errors aren't being sent to your phone, verify that the configured variables work. To do so, replace the four variables in the top of this PowerShell script and execute it: $sid = \"INSERT_SID\" $token = \"INSERT_TOKEN\" $from = \"INSERT_FROM\" $to = \"INSERT_TO\" $url = \"https://api.twilio.com/2010-04-01/Accounts/$sid/Messages.json\" $pair = \"$($sid):$($token)\" $encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair)) $basicAuthValue = \"Basic $encodedCreds\" $Headers = @{ Authorization = $basicAuthValue ContentType = \"application/x-www-form-urlencoded\" } $from = $from.Replace(\"+\", \"%2B\") $to = $to.Replace(\"+\", \"%2B\") $response = Invoke-WebRequest -Uri $url -Method POST -Headers $Headers -Body \"Body=Affirmative&From=$from&To=$to\" You should see a text message on your phone. The script will output any errors from Twilio if something isn't working.","title":"Troubleshooting"},{"location":"elmah-io-apps-webclient/","text":"Install WebClient App for elmah.io The WebClient app is deprecated. Use a HTTP rule available on the Rules tab for more a more advanced web integrations. The WebClient app integrates elmah.io with every system providing a HTTP based API. To install WebClient, click the Install button on the Apps tab. This will show the WebClient settings page: Input a valid URL plus body and content type (if required). Finally hit Save . The WebClient will make a HTTP request on the inputted URL every time a new message is logged. Be aware that this can potentially be a lot of requests, since everything from verbose to fatal message will trigger the HTTP request. Most services (like Slack and HipChat) only allow for a maximum number of requests per minute.","title":"WebClient"},{"location":"elmah-io-apps-webclient/#install-webclient-app-for-elmahio","text":"The WebClient app is deprecated. Use a HTTP rule available on the Rules tab for more a more advanced web integrations. The WebClient app integrates elmah.io with every system providing a HTTP based API. To install WebClient, click the Install button on the Apps tab. This will show the WebClient settings page: Input a valid URL plus body and content type (if required). Finally hit Save . The WebClient will make a HTTP request on the inputted URL every time a new message is logged. Be aware that this can potentially be a lot of requests, since everything from verbose to fatal message will trigger the HTTP request. Most services (like Slack and HipChat) only allow for a maximum number of requests per minute.","title":"Install WebClient App for elmah.io"},{"location":"elmah-io-apps-youtrack/","text":"Install YouTrack App for elmah.io Get your token In order to allow elmah.io to create issues on YouTrack, you will need a permanen token. Go to your profile , click the Update personal information and manage logins link and select the Authentication tab. Here you can generate a new token: Copy the generated token. Install the YouTrack App on elmah.io Log into elmah.io and go to the log settings. Click the Apps tab. Locate the YouTrack app and click the Install button. Input your instance, project and token from the previous step: Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured YouTrack project.","title":"YouTrack"},{"location":"elmah-io-apps-youtrack/#install-youtrack-app-for-elmahio","text":"","title":"Install YouTrack App for elmah.io"},{"location":"elmah-io-apps-youtrack/#get-your-token","text":"In order to allow elmah.io to create issues on YouTrack, you will need a permanen token. Go to your profile , click the Update personal information and manage logins link and select the Authentication tab. Here you can generate a new token: Copy the generated token.","title":"Get your token"},{"location":"elmah-io-apps-youtrack/#install-the-youtrack-app-on-elmahio","text":"Log into elmah.io and go to the log settings. Click the Apps tab. Locate the YouTrack app and click the Install button. Input your instance, project and token from the previous step: Click Save and the app is added to your log. When new errors are logged, issues are automatically created in the configured YouTrack project.","title":"Install the YouTrack App on elmah.io"},{"location":"email-troubleshooting/","text":"Email troubleshooting Email troubleshooting Emails on new errors only Email bounced Invalid email Check your promotional and/or spam folder So, you aren't receiving emails from elmah.io? Here is a collection of things to know/try out. Emails on new errors only The most common reason for not receiving emails when errors are logged is that elmah.io only sends the New Error email when an error that we haven't seen before is logged. New errors are marked with a yellow star next to the log message in the UI and can be searched through either search filters or full-text search: isNew:true The new detection algorithm is implemented by looking at a range of fields like the title, type, and severity. Only severities Error and Fatal marked as isNew trigger an email. Email bounced We use AWS to send out all transactional emails from elmah.io. We get a notification from AWS when an email bounces and we stop sending to that email address, even if any new emails wouldn't cause a bounce. Beneath your profile, you will be able to see if your email caused a bounce: As the error message says, get in contact for us to try and reach the email address again. Invalid email Ok, this may seem obvious. But this happens more often than you would think. Typos are a common cause of invalid emails. Specifying a mailing list or group address doesn't always play nice with elmah.io either. For instance, Office 365 distribution groups block external emails as default. The easiest way to check your inputted email address is to send a new message to that address from an external email provider. Check your promotional and/or spam folder We do a lot to keep our email reputation high. But some email clients may treat similar-looking emails as promotional or spam. Remember to check those folders and mark messages as important if spotting them in the wrong folder.","title":"Email troubleshooting"},{"location":"email-troubleshooting/#email-troubleshooting","text":"Email troubleshooting Emails on new errors only Email bounced Invalid email Check your promotional and/or spam folder So, you aren't receiving emails from elmah.io? Here is a collection of things to know/try out.","title":"Email troubleshooting"},{"location":"email-troubleshooting/#emails-on-new-errors-only","text":"The most common reason for not receiving emails when errors are logged is that elmah.io only sends the New Error email when an error that we haven't seen before is logged. New errors are marked with a yellow star next to the log message in the UI and can be searched through either search filters or full-text search: isNew:true The new detection algorithm is implemented by looking at a range of fields like the title, type, and severity. Only severities Error and Fatal marked as isNew trigger an email.","title":"Emails on new errors only"},{"location":"email-troubleshooting/#email-bounced","text":"We use AWS to send out all transactional emails from elmah.io. We get a notification from AWS when an email bounces and we stop sending to that email address, even if any new emails wouldn't cause a bounce. Beneath your profile, you will be able to see if your email caused a bounce: As the error message says, get in contact for us to try and reach the email address again.","title":"Email bounced"},{"location":"email-troubleshooting/#invalid-email","text":"Ok, this may seem obvious. But this happens more often than you would think. Typos are a common cause of invalid emails. Specifying a mailing list or group address doesn't always play nice with elmah.io either. For instance, Office 365 distribution groups block external emails as default. The easiest way to check your inputted email address is to send a new message to that address from an external email provider.","title":"Invalid email"},{"location":"email-troubleshooting/#check-your-promotional-andor-spam-folder","text":"We do a lot to keep our email reputation high. But some email clients may treat similar-looking emails as promotional or spam. Remember to check those folders and mark messages as important if spotting them in the wrong folder.","title":"Check your promotional and/or spam folder"},{"location":"export-data-from-elmah-io-to-json/","text":"Export data from elmah.io to JSON If you want to export data from elmah.io, we support this through the Elmah.Io.Export tool . The tool is available on GitHub and should be built on an OS of your choice (the tool is implemented in .NET Core). To export all data from a log, run the tool with the minimum number of parameters: dotnet Elmah.Io.Export.dll -ApiKey c7e049966ddf450f8ce6aeded7b581d0 -LogId 9f01ca78-174a-4a96-9f84-a336917a9deb Be sure to use an API key with the Messages > Read permission enabled. The following switches are available: Name Required Default Description -ApiKey Your API key needed to access your subscription ( where is my API key? ). -LogId The ID of the log you want to export from ( where is my log ID? ). -Filename Export-{ticks}.json Name of the output file. -DateFrom DateTime.Min Date and time in ISO8601 to export messages from. -DateTo DateTime.Max Date and time in ISO8601 to export messages to. -Query A lucene query to filter messages by. See Query messages using full-text search for details. -IncludeHeaders false Indicates if the output should include headers like cookies and server variables (runs slower).","title":"Export data from elmah.io to JSON"},{"location":"export-data-from-elmah-io-to-json/#export-data-from-elmahio-to-json","text":"If you want to export data from elmah.io, we support this through the Elmah.Io.Export tool . The tool is available on GitHub and should be built on an OS of your choice (the tool is implemented in .NET Core). To export all data from a log, run the tool with the minimum number of parameters: dotnet Elmah.Io.Export.dll -ApiKey c7e049966ddf450f8ce6aeded7b581d0 -LogId 9f01ca78-174a-4a96-9f84-a336917a9deb Be sure to use an API key with the Messages > Read permission enabled. The following switches are available: Name Required Default Description -ApiKey Your API key needed to access your subscription ( where is my API key? ). -LogId The ID of the log you want to export from ( where is my log ID? ). -Filename Export-{ticks}.json Name of the output file. -DateFrom DateTime.Min Date and time in ISO8601 to export messages from. -DateTo DateTime.Max Date and time in ISO8601 to export messages to. -Query A lucene query to filter messages by. See Query messages using full-text search for details. -IncludeHeaders false Indicates if the output should include headers like cookies and server variables (runs slower).","title":"Export data from elmah.io to JSON"},{"location":"handle-elmah-io-downtime/","text":"Handle elmah.io downtime Like every other SaaS product out there, we cannot promise you 100% uptime on elmah.io. We understand, that your logging data is extremely important for your business and we do everything in our power to secure that elmah.io is running smoothly. To monitor our API's and websites, check out status.elmah.io . But how do you handle the time where you need to log a message in elmah.io and the service is down? You have a few options actually: Subscribe to the OnMessageFail event You can subscribe an event handler to listen for this situation (where communicating with the elmah.io API fails). To hook up an event handler, write this piece of code in your initialization code: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessageFail += (sender, args) => { var message = args.Message; var exception = args.Error; // TODO: log message and/or exception somewhere else. }; The example is for ASP.NET and using the Elmah.Io.Client package. Similar options are available for other web and logging frameworks. Log to multiple logs If you want to be able to rollback to another solution, in case elmah.io goes down, you can actually log to multiple error logs as described here: Logging to multiple ELMAH logs . If you are using one of our integrations for other web and logging framework, various options are available too. This could be logging to a local file or database. We constantly work to improve the uptime of the entire solution. Response explanation Here's an overview of the types of errors you can experience from the API: Response Meaning Timeout Something is very wrong with our API or Azure. You can be sure that we are working 24/7 to fix it. 500 The API is reachable, but we have a problem like communicating with Azure Service bus. Azure has great uptime and all of our resources are dedicated and replicated. Still, we experience short periods of dowmtime from time to time. 429 We allow a maximum (per API key) of 500 requests per minute and 3600 per hour. 429 means that you have crossed that line. This status code doesn't indicate that the API is down. 4xx Something is wrong with the request. Check out the API documentation for details. This status code doesn't indicate that the API is down.","title":"Handle elmah.io downtime"},{"location":"handle-elmah-io-downtime/#handle-elmahio-downtime","text":"Like every other SaaS product out there, we cannot promise you 100% uptime on elmah.io. We understand, that your logging data is extremely important for your business and we do everything in our power to secure that elmah.io is running smoothly. To monitor our API's and websites, check out status.elmah.io . But how do you handle the time where you need to log a message in elmah.io and the service is down? You have a few options actually: Subscribe to the OnMessageFail event You can subscribe an event handler to listen for this situation (where communicating with the elmah.io API fails). To hook up an event handler, write this piece of code in your initialization code: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessageFail += (sender, args) => { var message = args.Message; var exception = args.Error; // TODO: log message and/or exception somewhere else. }; The example is for ASP.NET and using the Elmah.Io.Client package. Similar options are available for other web and logging frameworks. Log to multiple logs If you want to be able to rollback to another solution, in case elmah.io goes down, you can actually log to multiple error logs as described here: Logging to multiple ELMAH logs . If you are using one of our integrations for other web and logging framework, various options are available too. This could be logging to a local file or database. We constantly work to improve the uptime of the entire solution.","title":"Handle elmah.io downtime"},{"location":"handle-elmah-io-downtime/#response-explanation","text":"Here's an overview of the types of errors you can experience from the API: Response Meaning Timeout Something is very wrong with our API or Azure. You can be sure that we are working 24/7 to fix it. 500 The API is reachable, but we have a problem like communicating with Azure Service bus. Azure has great uptime and all of our resources are dedicated and replicated. Still, we experience short periods of dowmtime from time to time. 429 We allow a maximum (per API key) of 500 requests per minute and 3600 per hour. 429 means that you have crossed that line. This status code doesn't indicate that the API is down. 4xx Something is wrong with the request. Check out the API documentation for details. This status code doesn't indicate that the API is down.","title":"Response explanation"},{"location":"heartbeats-troubleshooting/","text":"Heartbeats Troubleshooting Common problems and how to fix them Here you will a list of common problems and how to solve them. Timeout when creating heartbeats through Elmah.Io.Client If you experience a timeout when calling the Healthy , Degraded , or Unhealthy method, you may want to adjust the default HTTP timeout. Elmah.Io.Client has a default timeout of 5 seconds to make sure that logging to elmah.io from a web application won't slow down the web app too much in case of slow response time from the elmah.io API. While 99.9% of the requests to the elmah.io API finishes within this timeout, problems with Azure, the network connection, and a lot of other issues can happen. Since heartbeats typically run outside the scope of a web request, it's safe to increase the default HTTP timeout in this case: var api = (ElmahioAPI)ElmahioAPI.Create(\"API_KEY\"); api.HttpClient.Timeout = new TimeSpan(0, 0, 30); The example set a timeout of 30 seconds.","title":"Heartbeats Troubleshooting"},{"location":"heartbeats-troubleshooting/#heartbeats-troubleshooting","text":"","title":"Heartbeats Troubleshooting"},{"location":"heartbeats-troubleshooting/#common-problems-and-how-to-fix-them","text":"Here you will a list of common problems and how to solve them.","title":"Common problems and how to fix them"},{"location":"heartbeats-troubleshooting/#timeout-when-creating-heartbeats-through-elmahioclient","text":"If you experience a timeout when calling the Healthy , Degraded , or Unhealthy method, you may want to adjust the default HTTP timeout. Elmah.Io.Client has a default timeout of 5 seconds to make sure that logging to elmah.io from a web application won't slow down the web app too much in case of slow response time from the elmah.io API. While 99.9% of the requests to the elmah.io API finishes within this timeout, problems with Azure, the network connection, and a lot of other issues can happen. Since heartbeats typically run outside the scope of a web request, it's safe to increase the default HTTP timeout in this case: var api = (ElmahioAPI)ElmahioAPI.Create(\"API_KEY\"); api.HttpClient.Timeout = new TimeSpan(0, 0, 30); The example set a timeout of 30 seconds.","title":"Timeout when creating heartbeats through Elmah.Io.Client"},{"location":"how-prices-are-calculated/","text":"How prices are calculated When using elmah.io, you may experience the need to switch plan, update your credit card and other tasks which will require changes to your current payment. Every time you change something that requires a new or upcoming charge on your credit card, we reset your subscription. This means that we charge you the difference from what you already paid, to the cost of what you are switching to. Example 1: Switch to a higher plan If you purchased a Small Business ($29) on June 1 and want to upgrade to Business ($49) on June 15, we charge you ~ $35. You already paid $15 for half of June on the Small Business plan, why the remaining amount is deducted from the $49. Your next payment will be on July 15. Example 2: Switch to a lower plan If you purchased a Business plan ($49) on June 15. and downgrade to a Small Business plan ($29) on July 1, you would be charged $49 on June 15, and $29 on July 15. You commit to either a month or a year in advance. When downgrading to a lower plan, you will stay on the current plan until your subscription is renewed. When that happens, you are charged the price of the lower plan. Example 3: Update your credit card A new credit card can be inputted at any time during your subscription. The payment provider will automatically charge the new credit card on the next payment. Example 4: Purchase a top-up If you need additional messages but don't want to upgrade to a larger plan permanently, you can purchase a top-up. The purchase is made on the credit card already configured on the subscription. If you want to buy the top-up on a different credit card, you will need to use the Update credit card feature first. The price of the top-up is always $19, and you can purchase as many top-ups as you want. Example 5: Purchase a subscription from Denmark We are based in Denmark why selling services to another Danish company are required to include 25% VAT (moms). The price on the various dialogs will automatically show the price including VAT as well as the VAT amount. Your invoices will include the amount in VAT to inform SKAT.","title":"How prices are calculated"},{"location":"how-prices-are-calculated/#how-prices-are-calculated","text":"When using elmah.io, you may experience the need to switch plan, update your credit card and other tasks which will require changes to your current payment. Every time you change something that requires a new or upcoming charge on your credit card, we reset your subscription. This means that we charge you the difference from what you already paid, to the cost of what you are switching to. Example 1: Switch to a higher plan If you purchased a Small Business ($29) on June 1 and want to upgrade to Business ($49) on June 15, we charge you ~ $35. You already paid $15 for half of June on the Small Business plan, why the remaining amount is deducted from the $49. Your next payment will be on July 15. Example 2: Switch to a lower plan If you purchased a Business plan ($49) on June 15. and downgrade to a Small Business plan ($29) on July 1, you would be charged $49 on June 15, and $29 on July 15. You commit to either a month or a year in advance. When downgrading to a lower plan, you will stay on the current plan until your subscription is renewed. When that happens, you are charged the price of the lower plan. Example 3: Update your credit card A new credit card can be inputted at any time during your subscription. The payment provider will automatically charge the new credit card on the next payment. Example 4: Purchase a top-up If you need additional messages but don't want to upgrade to a larger plan permanently, you can purchase a top-up. The purchase is made on the credit card already configured on the subscription. If you want to buy the top-up on a different credit card, you will need to use the Update credit card feature first. The price of the top-up is always $19, and you can purchase as many top-ups as you want. Example 5: Purchase a subscription from Denmark We are based in Denmark why selling services to another Danish company are required to include 25% VAT (moms). The price on the various dialogs will automatically show the price including VAT as well as the VAT amount. Your invoices will include the amount in VAT to inform SKAT.","title":"How prices are calculated"},{"location":"how-to-configure-api-key-permissions/","text":"How to configure API key permissions Security on the elmah.io API is handled through the use of API keys. All requests to the API must be accompanied by an API key. When creating your organization, a default API key was automatically created. API keys can be revoked and you can create multiple API keys for different purposes and projects. Much like a user can be awarded different levels of access on elmah.io, API keys also have a set of permissions. The default created API key for your organization, only have permission to write log messages to elmah.io. API key permissions were added in August 2018, why keys created before that have all permissions enabled. We recommend those of you with old API keys to configure the needed permissions. To configure permissions for a new or existing API key, either click the Edit or Add API Key button on the API Keys tab of your organization settings. This will show the API key editor view: Like mentioned previously, new keys have the messages_write permission enabled only. This permission will cover logging from your application to elmah.io. If your application needs to browse messages from elmah.io, create new logs/applications, etc. you will need to enable the corresponding permission. Notice that read permissions don't need to be enabled, in order for you to browse logs and log messages on the elmah.io UI. API keys are used by the range of client integrations only. Your API key shouldn't be shared outside your organization. In some situations, you will need to share your API key (like when logging from JavaScript). In these cases, it's essential that your API key only have the messages_write permission enabled. With all permissions enabled, everyone will be able to browse your logs.","title":"How to configure API key permissions"},{"location":"how-to-configure-api-key-permissions/#how-to-configure-api-key-permissions","text":"Security on the elmah.io API is handled through the use of API keys. All requests to the API must be accompanied by an API key. When creating your organization, a default API key was automatically created. API keys can be revoked and you can create multiple API keys for different purposes and projects. Much like a user can be awarded different levels of access on elmah.io, API keys also have a set of permissions. The default created API key for your organization, only have permission to write log messages to elmah.io. API key permissions were added in August 2018, why keys created before that have all permissions enabled. We recommend those of you with old API keys to configure the needed permissions. To configure permissions for a new or existing API key, either click the Edit or Add API Key button on the API Keys tab of your organization settings. This will show the API key editor view: Like mentioned previously, new keys have the messages_write permission enabled only. This permission will cover logging from your application to elmah.io. If your application needs to browse messages from elmah.io, create new logs/applications, etc. you will need to enable the corresponding permission. Notice that read permissions don't need to be enabled, in order for you to browse logs and log messages on the elmah.io UI. API keys are used by the range of client integrations only. Your API key shouldn't be shared outside your organization. In some situations, you will need to share your API key (like when logging from JavaScript). In these cases, it's essential that your API key only have the messages_write permission enabled. With all permissions enabled, everyone will be able to browse your logs.","title":"How to configure API key permissions"},{"location":"how-to-enable-two-factor-login/","text":"How to enable two-factor login How to enable two-factor login Two-factor with an elmah.io username and password Two-factor with a social provider elmah.io supports two-factor login through either one of the social providers or a two-factor app like Google Authenticator or Authy. Two-factor with an elmah.io username and password When signing into elmah.io with a username and password, two-factor authentication can be enabled on the Security tab on your profile: Follow the instructions on the page to install either Google Authenticator or Authy. Once you have the app installed, scan the on-screen QR code and input the generated token in the field in step 3. Once two-factor authentication has been successfully set up, the following screen is shown: Two-factor authentication can be disabled at any time by inputting a new code from the authenticator app in the text field and clicking the Deactivate two-factor login button. Two-factor with a social provider When using one of the social providers to log in to elmah.io, two-factor authentication can be enabled through either Twitter, Facebook, Microsoft, or Google. Check out the documentation for each authentication mechanism for details on how to enable two-factor authentication.","title":"How to enable two-factor login"},{"location":"how-to-enable-two-factor-login/#how-to-enable-two-factor-login","text":"How to enable two-factor login Two-factor with an elmah.io username and password Two-factor with a social provider elmah.io supports two-factor login through either one of the social providers or a two-factor app like Google Authenticator or Authy.","title":"How to enable two-factor login"},{"location":"how-to-enable-two-factor-login/#two-factor-with-an-elmahio-username-and-password","text":"When signing into elmah.io with a username and password, two-factor authentication can be enabled on the Security tab on your profile: Follow the instructions on the page to install either Google Authenticator or Authy. Once you have the app installed, scan the on-screen QR code and input the generated token in the field in step 3. Once two-factor authentication has been successfully set up, the following screen is shown: Two-factor authentication can be disabled at any time by inputting a new code from the authenticator app in the text field and clicking the Deactivate two-factor login button.","title":"Two-factor with an elmah.io username and password"},{"location":"how-to-enable-two-factor-login/#two-factor-with-a-social-provider","text":"When using one of the social providers to log in to elmah.io, two-factor authentication can be enabled through either Twitter, Facebook, Microsoft, or Google. Check out the documentation for each authentication mechanism for details on how to enable two-factor authentication.","title":"Two-factor with a social provider"},{"location":"include-filename-and-line-number-in-stacktraces/","text":"Include filename and line number in stack traces When deploying your application to the test and production environment, you normally want to use the Release configuration. When doing so, your code is optimized, web.config transformation is running and a few additional things. But, part of running on a Release build is, that you lose the ability to see filenames and line numbers in the stack traces produced by your system. .NET offer the concept of PDB files, which is automatically generated when building your code. The PDB file contains information for the debugger to work, like which file to look up when a breakpoint is reached in your code. Unless you have changed the default settings inside Visual Studio, both the Debug and Release configuration generates a PDB file. So, if both Debug and Release produces a PDB file, why does Debug builds include file name and line number in stack traces, while the Release build doesn't? The reason is most often caused by the fact that PDB files aren't published as part of the deployment. To do so, right click your project in Visual Studio and Select Properties . Click the Package/Publish Web tab and make sure that the Release configuration is selected in the dropdown. Next, remove the check in Exclude generated debug symbols : Also, make sure that the PDB file is generated as part of Release builds. Select the Build tab and click Advanced... . In Debug Info you want to make sure that either pdb-only or full is selected ( pdb-only being the default): On your next deployment, PDB files are published as part of the build. Depending on who you talk to, deploying PDB files as part of your build may be considered a hack. Since PDB file can contain sensitive information about your implementation, publishing these files should only be done, if you have full control of the environment you are deploying to. When releasing software to external users/customers, you don't want to include your PDB files. In this case, you should store the PDB files internally, in a symbol server or similar.","title":"Include filename and line number in stack traces"},{"location":"include-filename-and-line-number-in-stacktraces/#include-filename-and-line-number-in-stack-traces","text":"When deploying your application to the test and production environment, you normally want to use the Release configuration. When doing so, your code is optimized, web.config transformation is running and a few additional things. But, part of running on a Release build is, that you lose the ability to see filenames and line numbers in the stack traces produced by your system. .NET offer the concept of PDB files, which is automatically generated when building your code. The PDB file contains information for the debugger to work, like which file to look up when a breakpoint is reached in your code. Unless you have changed the default settings inside Visual Studio, both the Debug and Release configuration generates a PDB file. So, if both Debug and Release produces a PDB file, why does Debug builds include file name and line number in stack traces, while the Release build doesn't? The reason is most often caused by the fact that PDB files aren't published as part of the deployment. To do so, right click your project in Visual Studio and Select Properties . Click the Package/Publish Web tab and make sure that the Release configuration is selected in the dropdown. Next, remove the check in Exclude generated debug symbols : Also, make sure that the PDB file is generated as part of Release builds. Select the Build tab and click Advanced... . In Debug Info you want to make sure that either pdb-only or full is selected ( pdb-only being the default): On your next deployment, PDB files are published as part of the build. Depending on who you talk to, deploying PDB files as part of your build may be considered a hack. Since PDB file can contain sensitive information about your implementation, publishing these files should only be done, if you have full control of the environment you are deploying to. When releasing software to external users/customers, you don't want to include your PDB files. In this case, you should store the PDB files internally, in a symbol server or similar.","title":"Include filename and line number in stack traces"},{"location":"integrate-elmah-io-with-hipchat/","text":"","title":"Integrate elmah io with hipchat"},{"location":"integrate-elmah-io-with-slack/","text":"","title":"Integrate elmah io with slack"},{"location":"integrate-elmah-io-with-zapier/","text":"Integrate with Zapier Zapier is the place to go if you need to integrate two or more online systems. In this article, we use an integration point provided by elmah.io and Zapier called a trigger. A trigger is (as the name suggest) something that triggers an action in Zapier. In the case of elmah.io, the trigger available is when new errors are logged to your log. Actions exist on the other side of the integration and tell Zapier what to do every time a trigger is fired. This guide will show you how to set up the trigger. What action you want to execute when new errors are logged will depend on the tools and workflows used in your organization. Create a new account on zapier.com. Then click the Make a Zap button. The create new Zap page is shown: Search for elmah.io in the search field and select the app and the New Error trigger: Click Continue and you will be presented with the following screen: Click the Sign in to elmah.io button or select an existing account if you have already set up other zaps using elmah.io. Adding a new account will show a popup asking you to sign in to elmah.io: Sign in with your elmah.io username/password or social provider. On the following screen you will be asked to authorize elmah.io to notify Zapier every time a new error is logged in a log selected on a later stage: Click the Authorize button and your account will be added to the account list on Zapier: Click Continue . In the following step you will select the elmah.io log that you want to integrate with Zapier: The dropdown contains all of the logs you have access to within your organization. Select a log and click Continue . In the following step you will test the trigger: Click Test trigger and Zapier will pull recent errors from the chosen log. Select the error the represents how a typical error in the chosen log looks like. The values from the chosen error will be used when filling in the action, why selecting a good example in this step can make it easier to configure later on. When you are done, click the Continue button. The elmah.io trigger is now configured. Select an app and event of your choice to create actions on the newly created trigger.","title":"Zapier"},{"location":"integrate-elmah-io-with-zapier/#integrate-with-zapier","text":"Zapier is the place to go if you need to integrate two or more online systems. In this article, we use an integration point provided by elmah.io and Zapier called a trigger. A trigger is (as the name suggest) something that triggers an action in Zapier. In the case of elmah.io, the trigger available is when new errors are logged to your log. Actions exist on the other side of the integration and tell Zapier what to do every time a trigger is fired. This guide will show you how to set up the trigger. What action you want to execute when new errors are logged will depend on the tools and workflows used in your organization. Create a new account on zapier.com. Then click the Make a Zap button. The create new Zap page is shown: Search for elmah.io in the search field and select the app and the New Error trigger: Click Continue and you will be presented with the following screen: Click the Sign in to elmah.io button or select an existing account if you have already set up other zaps using elmah.io. Adding a new account will show a popup asking you to sign in to elmah.io: Sign in with your elmah.io username/password or social provider. On the following screen you will be asked to authorize elmah.io to notify Zapier every time a new error is logged in a log selected on a later stage: Click the Authorize button and your account will be added to the account list on Zapier: Click Continue . In the following step you will select the elmah.io log that you want to integrate with Zapier: The dropdown contains all of the logs you have access to within your organization. Select a log and click Continue . In the following step you will test the trigger: Click Test trigger and Zapier will pull recent errors from the chosen log. Select the error the represents how a typical error in the chosen log looks like. The values from the chosen error will be used when filling in the action, why selecting a good example in this step can make it easier to configure later on. When you are done, click the Continue button. The elmah.io trigger is now configured. Select an app and event of your choice to create actions on the newly created trigger.","title":"Integrate with Zapier"},{"location":"integrations-high-level-overview/","text":"Integrations high-level overview elmah.io offers integration with an extensive list of logging- and web-frameworks. Get the full overview here. The table below shows all of the frameworks with official support. The Async column contains a checkmark if the integration is logging asynchronously. The Bulk column contains a checkmark if the integration is logging to elmah.io in bulk. In addition, elmah.io can be installed in a range of different products and services not mentioned (using the integrations below). Look through the menu to the left to see all of the possible integrations. Framework Stable Build Source Samples Async Bulk ASP.NET \u2714\ufe0f ASP.NET MVC \ufe0f\u2714\ufe0f ASP.NET Web API \u2714\ufe0f ASP.NET Core \u2714\ufe0f Microsoft Extensions.Logging \u2714\ufe0f \u2714\ufe0f Serilog \u2714\ufe0f \u2714\ufe0f NLog \u2714\ufe0f \u2714\ufe0f log4net \u2714\ufe0f Logary \u2714\ufe0f Umbraco \u2714\ufe0f Azure Websites \u2714\ufe0f Azure Functions \u2714\ufe0f JavaScript \u2714\ufe0f","title":"Integrations high level overview"},{"location":"integrations-high-level-overview/#integrations-high-level-overview","text":"elmah.io offers integration with an extensive list of logging- and web-frameworks. Get the full overview here. The table below shows all of the frameworks with official support. The Async column contains a checkmark if the integration is logging asynchronously. The Bulk column contains a checkmark if the integration is logging to elmah.io in bulk. In addition, elmah.io can be installed in a range of different products and services not mentioned (using the integrations below). Look through the menu to the left to see all of the possible integrations. Framework Stable Build Source Samples Async Bulk ASP.NET \u2714\ufe0f ASP.NET MVC \ufe0f\u2714\ufe0f ASP.NET Web API \u2714\ufe0f ASP.NET Core \u2714\ufe0f Microsoft Extensions.Logging \u2714\ufe0f \u2714\ufe0f Serilog \u2714\ufe0f \u2714\ufe0f NLog \u2714\ufe0f \u2714\ufe0f log4net \u2714\ufe0f Logary \u2714\ufe0f Umbraco \u2714\ufe0f Azure Websites \u2714\ufe0f Azure Functions \u2714\ufe0f JavaScript \u2714\ufe0f","title":"Integrations high-level overview"},{"location":"logging-custom-data/","text":"Logging custom data ELMAH stores a lot of contextual information when an error occurs. Things like cookies, stack trace, server variables and much more are stored to ease debugging the error at a later point in time. Most error log implementations for ELMAH doesn't support custom variables. Luckily, this is not the case for the elmah.io client. Let\u2019s look at some code. You have two options of decorating your errors with custom variables. Use the Data dictionary on .NET\u2019s Exception type I talk to a lot of developers and not all of them know about the wonderful world of the Data dictionary. All exceptions in .NET contains a property named Data and of type IDictionary . The Data dictionary is intended for user-defined information about the exception. The elmah.io client iterates through key/values in this dictionary and ship it off to elmah.io\u2019s API . To log custom data using Data , just add a new key/value pair to the Data dictionary: try { CallSomeBusinessLogic(inputValue); } catch (Exception e) { e.Data.Add(\"InputValueWas\", inputValue); ErrorSignal.FromCurrentContext().Raise(e); } In the example I add a custom variable named InputValueWas with the value of the inputValue variable. This way I will be able to see which input value caused the exception. Use the OnMessage hook in the elmah.io client You may not use ELMAH\u2019s ErrorSignal feature, but rely on ELMAH to log uncaught exceptions only. In this scenario you probably don\u2019t have access to the thrown exception. The elmah.io client offers a hook for you to be able to execute code every time something is logged: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { if (args.Message.Data == null) args.Message.Data = new List<Item>(); args.Message.Data.Add(new Item { Key = \"SomeOtherVariable\", Value = someVariable }); }; You may not have seen the Logger type of elmah.io before, but what\u2019s important to know right now is, that Logger is responsible for logging messages to the elmah.io API. Another new term here is Message. A message is the type encapsulating all of the information about the thrown exception. In the code example I subscribe a new event handler to the OnMessage event. This tells the elmah.io client to execute your event handler, before actually logging an exception to elmah.io. I use the event to add a custom variable to the Data dictionary of the message logged to elmah.io. Looking at your custom data Custom data are shown on the Data tab on the extended messages details page. To open inspect custom data go to the log search page, extend a log message, click the three bars (hamburger) icon in the upper right corner. The custom data is beneath the Data tab. Like the content in the other tabs of the message details, you will be able to filter results by the variable key. Searching custom data Custom data is not searchable by default. Sometimes it makes sense, that errors can be searched from values logged as part of custom data. For now, this feature is supported through the use of variable naming, but we may extend this to a configuration option through the UI as well. To make a custom variable and its value searchable through the UI (as well as through the API), name the variable with the prefix X-ELMAHIO-SEARCH- . The variable will become searchable through the name added after the prefix. Example: Elmah.ErrorLog.GetDefault(null); var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { if (args.Message.Data == null) args.Message.Data = new List<Item>(); args.Message.Data.Add(new Item { Key = \"X-ELMAHIO-SEARCH-myVariable\", Value = \"Some value\" }); }; would make myVariable searchable using this query: data.myVariable:funky Observe how the X-ELMAHIO-SEARCH- prefix is replaced with the data. prefix when indexed in elmah.io. To avoid someone filling up our cluster with custom data, only the first three variables prefixed with X-ELMAHIO-SEARCH- are made searchable. Also, variables with a value containing more than 256 characters are not indexed.","title":"Logging custom data"},{"location":"logging-custom-data/#logging-custom-data","text":"ELMAH stores a lot of contextual information when an error occurs. Things like cookies, stack trace, server variables and much more are stored to ease debugging the error at a later point in time. Most error log implementations for ELMAH doesn't support custom variables. Luckily, this is not the case for the elmah.io client. Let\u2019s look at some code. You have two options of decorating your errors with custom variables.","title":"Logging custom data"},{"location":"logging-custom-data/#use-the-data-dictionary-on-nets-exception-type","text":"I talk to a lot of developers and not all of them know about the wonderful world of the Data dictionary. All exceptions in .NET contains a property named Data and of type IDictionary . The Data dictionary is intended for user-defined information about the exception. The elmah.io client iterates through key/values in this dictionary and ship it off to elmah.io\u2019s API . To log custom data using Data , just add a new key/value pair to the Data dictionary: try { CallSomeBusinessLogic(inputValue); } catch (Exception e) { e.Data.Add(\"InputValueWas\", inputValue); ErrorSignal.FromCurrentContext().Raise(e); } In the example I add a custom variable named InputValueWas with the value of the inputValue variable. This way I will be able to see which input value caused the exception.","title":"Use the Data dictionary on .NET\u2019s Exception type"},{"location":"logging-custom-data/#use-the-onmessage-hook-in-the-elmahio-client","text":"You may not use ELMAH\u2019s ErrorSignal feature, but rely on ELMAH to log uncaught exceptions only. In this scenario you probably don\u2019t have access to the thrown exception. The elmah.io client offers a hook for you to be able to execute code every time something is logged: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { if (args.Message.Data == null) args.Message.Data = new List<Item>(); args.Message.Data.Add(new Item { Key = \"SomeOtherVariable\", Value = someVariable }); }; You may not have seen the Logger type of elmah.io before, but what\u2019s important to know right now is, that Logger is responsible for logging messages to the elmah.io API. Another new term here is Message. A message is the type encapsulating all of the information about the thrown exception. In the code example I subscribe a new event handler to the OnMessage event. This tells the elmah.io client to execute your event handler, before actually logging an exception to elmah.io. I use the event to add a custom variable to the Data dictionary of the message logged to elmah.io.","title":"Use the OnMessage hook in the elmah.io client"},{"location":"logging-custom-data/#looking-at-your-custom-data","text":"Custom data are shown on the Data tab on the extended messages details page. To open inspect custom data go to the log search page, extend a log message, click the three bars (hamburger) icon in the upper right corner. The custom data is beneath the Data tab. Like the content in the other tabs of the message details, you will be able to filter results by the variable key.","title":"Looking at your custom data"},{"location":"logging-custom-data/#searching-custom-data","text":"Custom data is not searchable by default. Sometimes it makes sense, that errors can be searched from values logged as part of custom data. For now, this feature is supported through the use of variable naming, but we may extend this to a configuration option through the UI as well. To make a custom variable and its value searchable through the UI (as well as through the API), name the variable with the prefix X-ELMAHIO-SEARCH- . The variable will become searchable through the name added after the prefix. Example: Elmah.ErrorLog.GetDefault(null); var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { if (args.Message.Data == null) args.Message.Data = new List<Item>(); args.Message.Data.Add(new Item { Key = \"X-ELMAHIO-SEARCH-myVariable\", Value = \"Some value\" }); }; would make myVariable searchable using this query: data.myVariable:funky Observe how the X-ELMAHIO-SEARCH- prefix is replaced with the data. prefix when indexed in elmah.io. To avoid someone filling up our cluster with custom data, only the first three variables prefixed with X-ELMAHIO-SEARCH- are made searchable. Also, variables with a value containing more than 256 characters are not indexed.","title":"Searching custom data"},{"location":"logging-errors-programmatically/","text":"Logging errors programmatically So you\u2019ve setup a shiny new ELMAH log and all of your un-handled errors are logged to ELMAH. Now you\u2019re wondering: \u201cHow do I log my handled errors to ELMAH programmatically?\u201d You are in luck! ELMAH provides a nice API to do just that through error signaling. Consider the following code: try { int i = 0; int result = 42 / i; } catch (DivideByZeroException e) { // What to do? } Obviously an exception is thrown when trying to divide by zero, but what if we want to catch (and log) that exception instead of throwing it back through the call stack? With ELMAH\u2019s ErrorSignal class we can log the error: try { int i = 0; int result = 42 / i; } catch (DivideByZeroException e) { ErrorSignal.FromCurrentContext().Raise(e); } We call the static method FromCurrentContext on the ErrorSignal class, which returns a new object for doing the actual logging. Logging happens through the Raise method, which logs the exception to the configured ELMAH storage endpoint. In the example above, I use the FromCurrentContext helper to create a new instance of ErrorSignal . ELMAH also works outside the context of a webserver and in this case, you would simply use the default logger with null as the http context: ErrorLog.GetDefault(null).Log(new Error(e)); If you simply want to log text messages and don't need all of the HTTP context information, consider using one of our integrations for popular logging frameworks like log4net , NLog or Serilog . Also, the Elmah.Io.Client package contains a logging API documented here .","title":"Logging errors programmatically"},{"location":"logging-errors-programmatically/#logging-errors-programmatically","text":"So you\u2019ve setup a shiny new ELMAH log and all of your un-handled errors are logged to ELMAH. Now you\u2019re wondering: \u201cHow do I log my handled errors to ELMAH programmatically?\u201d You are in luck! ELMAH provides a nice API to do just that through error signaling. Consider the following code: try { int i = 0; int result = 42 / i; } catch (DivideByZeroException e) { // What to do? } Obviously an exception is thrown when trying to divide by zero, but what if we want to catch (and log) that exception instead of throwing it back through the call stack? With ELMAH\u2019s ErrorSignal class we can log the error: try { int i = 0; int result = 42 / i; } catch (DivideByZeroException e) { ErrorSignal.FromCurrentContext().Raise(e); } We call the static method FromCurrentContext on the ErrorSignal class, which returns a new object for doing the actual logging. Logging happens through the Raise method, which logs the exception to the configured ELMAH storage endpoint. In the example above, I use the FromCurrentContext helper to create a new instance of ErrorSignal . ELMAH also works outside the context of a webserver and in this case, you would simply use the default logger with null as the http context: ErrorLog.GetDefault(null).Log(new Error(e)); If you simply want to log text messages and don't need all of the HTTP context information, consider using one of our integrations for popular logging frameworks like log4net , NLog or Serilog . Also, the Elmah.Io.Client package contains a logging API documented here .","title":"Logging errors programmatically"},{"location":"logging-from-a-custom-http-module/","text":"Logging from a custom HTTP module Some developers like to gather all logging into a single module. An example of this would be to log to multiple log destinations and maybe even enrich log messages to multiple loggers with the same info. We always recommend using the modules and handlers that comes with ELMAH. But in case you want to log from a module manually, here's the recipe: public class CustomLoggingModule : IHttpModule { public void Init(HttpApplication context) { context.Error += Application_Error; } public void Application_Error(object sender, EventArgs messageData) { HttpApplication application = (HttpApplication)sender; var context = application.Context; var error = new Error(application.Server.GetLastError(), context); var log = ErrorLog.GetDefault(context); log.Log(error); } public void Dispose() { } } In the example, I've created a new module named CustomLoggingModule . The module needs to be configured in web.config as explained here . When starting up the application, ASP.NET calls the Init -method. In this method, an Error event handler is set. Every time a new error is happening in your web application, ASP.NET now calls the Application_Error -method. In this method, I wrap the last thrown error in ELMAH's Error object and log it through the ErrorLog class. Be aware that logging errors this way, disables ELMAH's built-in events like filtering.","title":"Logging from a custom HTTP module"},{"location":"logging-from-a-custom-http-module/#logging-from-a-custom-http-module","text":"Some developers like to gather all logging into a single module. An example of this would be to log to multiple log destinations and maybe even enrich log messages to multiple loggers with the same info. We always recommend using the modules and handlers that comes with ELMAH. But in case you want to log from a module manually, here's the recipe: public class CustomLoggingModule : IHttpModule { public void Init(HttpApplication context) { context.Error += Application_Error; } public void Application_Error(object sender, EventArgs messageData) { HttpApplication application = (HttpApplication)sender; var context = application.Context; var error = new Error(application.Server.GetLastError(), context); var log = ErrorLog.GetDefault(context); log.Log(error); } public void Dispose() { } } In the example, I've created a new module named CustomLoggingModule . The module needs to be configured in web.config as explained here . When starting up the application, ASP.NET calls the Init -method. In this method, an Error event handler is set. Every time a new error is happening in your web application, ASP.NET now calls the Application_Error -method. In this method, I wrap the last thrown error in ELMAH's Error object and log it through the ErrorLog class. Be aware that logging errors this way, disables ELMAH's built-in events like filtering.","title":"Logging from a custom HTTP module"},{"location":"logging-heartbeats-from-asp-net-core/","text":"Logging heartbeats from ASP.NET Core Logging heartbeats from ASP.NET Core Additional options Application name Callbacks Period Ignoring heartbeats on localhost, staging, etc. Troubleshooting ASP.NET Core offers a feature called Health Checks from version 2.2 and forward. For more information about health checks, check out our blog post: ASP.NET Core 2.2 Health Checks Explained . The Heartbeats feature on elmah.io support health checks too, by publishing health check results as heartbeats. To publish health checks as elmah.io heartbeats, install the Elmah.Io.AspNetCore.HealthChecks NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.HealthChecks dotnet add package Elmah.Io.AspNetCore.HealthChecks <PackageReference Include=\"Elmah.Io.AspNetCore.HealthChecks\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.HealthChecks Then configure the elmah.io health check publisher: services .AddHealthChecks() .AddElmahIoPublisher(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); options.HeartbeatId = \"HEARTBEAT_ID\"; }); Replace the variables with the correct values as explained in Set up Heartbeats . Remember to use an API key that includes the Heartbeats - Write permission. Additional options Application name Much like the error logging integration with ASP.NET Core, you can set an application name on log messages produced by Heartbeats. To do so, set the Application property when adding the publisher: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.Application = \"My app\"; }); If Application is not set, log messages will receive a default value of Heartbeats to make the messages distinguable from other messages. Callbacks The elmah.io publisher offer callbacks already known from Elmah.Io.AspNetCore . OnHeartbeat The OnHeartbeat callback can be used to set a version number on all log messages produced by a heartbeat and/or trigger your own code every time a heartbeat is logged to elmah.io: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.OnHeartbeat = hb => { hb.Version = \"1.0.0\"; }; }); OnFilter The OnFilter callback can used to ignore one or more heartbeats: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.OnFilter = hb => { return hb.Result == \"Degraded\"; }; }); The example ignores any Degraded heartbeats. OnError The OnError callback can be used to listen for errors communicating with the elmah.io API: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.OnError = (hb, ex) => { // Do something }; }); The elmah.io publisher already logs any internal errors through Microsoft.Extensions.Logging, why you don't need to do that in the OnError handler. If you are using another logging framework and don't have that hooked up on Microsoft.Extensions.Logging, the OnError is a good place to add some additional logging. Period As default, ASP.NET Core runs health checks every 30 seconds when setting up a publisher. To change this interval, add the following code: services.Configure<HealthCheckPublisherOptions>(options => { options.Period = TimeSpan.FromMinutes(5); }); There's a bug in ASP.NET Core 2.2 that requires you to use reflection when setting Period : services.Configure<HealthCheckPublisherOptions>(options => { var prop = options.GetType().GetField(\"_period\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance); prop.SetValue(options, TimeSpan.FromMinutes(5)); }); If setting Period to 5 minutes, you should set the heartbeat interval on elmah.io to 5 minutes and grace to 1 minute. Ignoring heartbeats on localhost, staging, etc. Monitoring hearbeats is important in your production environment. When running locally or even on staging, you probably don't want to monitor heartbeats. ASP.NET Core health checks doesn't seem to support a great deal of configuration through appsettings.json , Azure app settings, etc. The easiest way to tell ASP.NET Core to log heartbeats to elmah.io, is to avoid setting up health checks unless a heartbeat id is configured: if (!string.IsNullOrWhiteSpace(Configuration[\"ElmahIo:HeartbeatId\"])) { services.AddHealthChecks().AddElmahIoPublisher(); } In this example, we only configure health checks and the elmah.io publisher if the ElmahIo:HeartbeatId setting is defined in config. Troubleshooting Here's a list of things to check for if no heartbeats are registered: Did you include both API_KEY , LOG_ID , and HEARTBEAT_ID ? The publisher needs to be called before the AddElmahIo call from Elmah.Io.AspNetCore : services .AddHealthChecks() .AddElmahIoPublisher(); services.AddElmahIo(); If you are using Health Checks UI, it needs to be configured after the AddElmahIoPublisher -method: services .AddHealthChecks() .AddElmahIoPublisher(); service .AddHealthChecksUI();","title":"Logging heartbeats from ASP.NET Core"},{"location":"logging-heartbeats-from-asp-net-core/#logging-heartbeats-from-aspnet-core","text":"Logging heartbeats from ASP.NET Core Additional options Application name Callbacks Period Ignoring heartbeats on localhost, staging, etc. Troubleshooting ASP.NET Core offers a feature called Health Checks from version 2.2 and forward. For more information about health checks, check out our blog post: ASP.NET Core 2.2 Health Checks Explained . The Heartbeats feature on elmah.io support health checks too, by publishing health check results as heartbeats. To publish health checks as elmah.io heartbeats, install the Elmah.Io.AspNetCore.HealthChecks NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.HealthChecks dotnet add package Elmah.Io.AspNetCore.HealthChecks <PackageReference Include=\"Elmah.Io.AspNetCore.HealthChecks\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.HealthChecks Then configure the elmah.io health check publisher: services .AddHealthChecks() .AddElmahIoPublisher(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); options.HeartbeatId = \"HEARTBEAT_ID\"; }); Replace the variables with the correct values as explained in Set up Heartbeats . Remember to use an API key that includes the Heartbeats - Write permission.","title":"Logging heartbeats from ASP.NET Core"},{"location":"logging-heartbeats-from-asp-net-core/#additional-options","text":"","title":"Additional options"},{"location":"logging-heartbeats-from-asp-net-core/#application-name","text":"Much like the error logging integration with ASP.NET Core, you can set an application name on log messages produced by Heartbeats. To do so, set the Application property when adding the publisher: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.Application = \"My app\"; }); If Application is not set, log messages will receive a default value of Heartbeats to make the messages distinguable from other messages.","title":"Application name"},{"location":"logging-heartbeats-from-asp-net-core/#callbacks","text":"The elmah.io publisher offer callbacks already known from Elmah.Io.AspNetCore . OnHeartbeat The OnHeartbeat callback can be used to set a version number on all log messages produced by a heartbeat and/or trigger your own code every time a heartbeat is logged to elmah.io: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.OnHeartbeat = hb => { hb.Version = \"1.0.0\"; }; }); OnFilter The OnFilter callback can used to ignore one or more heartbeats: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.OnFilter = hb => { return hb.Result == \"Degraded\"; }; }); The example ignores any Degraded heartbeats. OnError The OnError callback can be used to listen for errors communicating with the elmah.io API: services .AddHealthChecks() .AddElmahIoPublisher(options => { ... options.OnError = (hb, ex) => { // Do something }; }); The elmah.io publisher already logs any internal errors through Microsoft.Extensions.Logging, why you don't need to do that in the OnError handler. If you are using another logging framework and don't have that hooked up on Microsoft.Extensions.Logging, the OnError is a good place to add some additional logging.","title":"Callbacks"},{"location":"logging-heartbeats-from-asp-net-core/#period","text":"As default, ASP.NET Core runs health checks every 30 seconds when setting up a publisher. To change this interval, add the following code: services.Configure<HealthCheckPublisherOptions>(options => { options.Period = TimeSpan.FromMinutes(5); }); There's a bug in ASP.NET Core 2.2 that requires you to use reflection when setting Period : services.Configure<HealthCheckPublisherOptions>(options => { var prop = options.GetType().GetField(\"_period\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance); prop.SetValue(options, TimeSpan.FromMinutes(5)); }); If setting Period to 5 minutes, you should set the heartbeat interval on elmah.io to 5 minutes and grace to 1 minute.","title":"Period"},{"location":"logging-heartbeats-from-asp-net-core/#ignoring-heartbeats-on-localhost-staging-etc","text":"Monitoring hearbeats is important in your production environment. When running locally or even on staging, you probably don't want to monitor heartbeats. ASP.NET Core health checks doesn't seem to support a great deal of configuration through appsettings.json , Azure app settings, etc. The easiest way to tell ASP.NET Core to log heartbeats to elmah.io, is to avoid setting up health checks unless a heartbeat id is configured: if (!string.IsNullOrWhiteSpace(Configuration[\"ElmahIo:HeartbeatId\"])) { services.AddHealthChecks().AddElmahIoPublisher(); } In this example, we only configure health checks and the elmah.io publisher if the ElmahIo:HeartbeatId setting is defined in config.","title":"Ignoring heartbeats on localhost, staging, etc."},{"location":"logging-heartbeats-from-asp-net-core/#troubleshooting","text":"Here's a list of things to check for if no heartbeats are registered: Did you include both API_KEY , LOG_ID , and HEARTBEAT_ID ? The publisher needs to be called before the AddElmahIo call from Elmah.Io.AspNetCore : services .AddHealthChecks() .AddElmahIoPublisher(); services.AddElmahIo(); If you are using Health Checks UI, it needs to be configured after the AddElmahIoPublisher -method: services .AddHealthChecks() .AddElmahIoPublisher(); service .AddHealthChecksUI();","title":"Troubleshooting"},{"location":"logging-heartbeats-from-aws-lambdas/","text":"Logging heartbeats from AWS Lambdas AWS Lambdas running on a schedule are great candidates for logging heartbeats to elmah.io. To send a healthy heartbeat when the Lambda runs successfully and an unhealthy heartbeat when an error happens, start by installing the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Include elmah.io API key, log ID, and heartbeat ID in your code. In this example, they are added as static fields: private const string ApiKey = \"API_KEY\"; private const string HeartbeatId = \"HEARTBEAT_ID\"; private static Guid LogId = new Guid(\"LOG_ID\"); Replace API_KEY with an API key with the Heartbeats | Write permission ( Where is my API key? ), HEARTBEAT_ID with the ID of the heartbeat available on the elmah.io UI, and LOG_ID with the ID of the log containing the heartbeat ( Where is my log ID? ). Create the elmah.io client and store the IHeartbeat object somewhere. In the following example, it is initialized in the Main method and stored in a static field: private static IHeartbeats heartbeats; private static async Task Main(string[] args) { heartbeats = ElmahioAPI.Create(ApiKey).Heartbeats; // ... } In the function handler, wrap your code in try/catch and call either the Healthy or Unhealthy method: public static string FunctionHandler(string input, ILambdaContext context) { try { // Lambda code goes here heartbeats.Healthy(LogId, HeartbeatId); return input?.ToUpper(); } catch (Exception e) { heartbeats.Unhealthy(LogId, HeartbeatId, e.ToString()); throw; } } When the lambda code runs (replace the Lambda code goes here comment with your code) without exceptions, a healthy heartbeat is logged to elmah.io. In case of an exception, an unhealthy heartbeat is logged to elmah.io. In case your Lambda doesn't run at all, elmah.io automatically logs a missing heartbeat.","title":"Logging heartbeats from AWS Lambdas"},{"location":"logging-heartbeats-from-aws-lambdas/#logging-heartbeats-from-aws-lambdas","text":"AWS Lambdas running on a schedule are great candidates for logging heartbeats to elmah.io. To send a healthy heartbeat when the Lambda runs successfully and an unhealthy heartbeat when an error happens, start by installing the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Include elmah.io API key, log ID, and heartbeat ID in your code. In this example, they are added as static fields: private const string ApiKey = \"API_KEY\"; private const string HeartbeatId = \"HEARTBEAT_ID\"; private static Guid LogId = new Guid(\"LOG_ID\"); Replace API_KEY with an API key with the Heartbeats | Write permission ( Where is my API key? ), HEARTBEAT_ID with the ID of the heartbeat available on the elmah.io UI, and LOG_ID with the ID of the log containing the heartbeat ( Where is my log ID? ). Create the elmah.io client and store the IHeartbeat object somewhere. In the following example, it is initialized in the Main method and stored in a static field: private static IHeartbeats heartbeats; private static async Task Main(string[] args) { heartbeats = ElmahioAPI.Create(ApiKey).Heartbeats; // ... } In the function handler, wrap your code in try/catch and call either the Healthy or Unhealthy method: public static string FunctionHandler(string input, ILambdaContext context) { try { // Lambda code goes here heartbeats.Healthy(LogId, HeartbeatId); return input?.ToUpper(); } catch (Exception e) { heartbeats.Unhealthy(LogId, HeartbeatId, e.ToString()); throw; } } When the lambda code runs (replace the Lambda code goes here comment with your code) without exceptions, a healthy heartbeat is logged to elmah.io. In case of an exception, an unhealthy heartbeat is logged to elmah.io. In case your Lambda doesn't run at all, elmah.io automatically logs a missing heartbeat.","title":"Logging heartbeats from AWS Lambdas"},{"location":"logging-heartbeats-from-azure-functions/","text":"Logging heartbeats from Azure Functions Logging heartbeats from Azure Functions Using a filter in Elmah.Io.Functions Manually using Elmah.Io.Client Using a separate heartbeat function Azure Functions are great candidates for adding heartbeats. For web API's implemented with Azure Functions, you should create a /health endpoint and ping that using Uptime Monitoring. But for timer triggered, queue triggers, and similar function apps, heartbeats are a great way to verify that your function is successfully running. The rest of this document is split into different ways of adding heartbeats to one or more functions. Using a filter in Elmah.Io.Functions The easiest way of including a heartbeat is to include the ElmahIoHeartbeatFilter available in the Elmah.Io.Functions package. This will automatically publish a Healthy or Unhealthy heartbeat, depending on if your functions execute successfully. This option is great for timer triggered functions like nightly batch jobs. Start by installing the Elmah.Io.Functions package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Functions dotnet add package Elmah.Io.Functions <PackageReference Include=\"Elmah.Io.Functions\" Version=\"3.*\" /> paket add Elmah.Io.Functions Elmah.Io.Functions requires dependency injection part of the Microsoft.Azure.Functions.Extensions package, why you will need this package if not already added. Extend the Startup.cs (or whatever you named your function startup class) file with the following code: using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Functions; [assembly: FunctionsStartup(typeof(My.FunctionApp.Startup))] namespace My.FunctionApp { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.HeartbeatId = config[\"heartbeatId\"]; }); builder.Services.AddSingleton<IFunctionFilter, ElmahIoHeartbeatFilter>(); } } } The code installs the ElmahIoHeartbeatFilter class, which will handle all of the communication with the elmah.io API. Finally, add the config variables ( apiKey , logId , and heartbeatId ) to the local.settings.json file, environment variables, Azure configuration settings, or in whatever way you specify settings for your function app. Manually using Elmah.Io.Client The example above installs the heartbeat filter for all functions. If you have multiple functions inside your function app, or you want greater control of when and how to send heartbeats, you can use Elmah.Io.Client to create heartbeats. Start by installing the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Extend the Startup.cs file with the following code: using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Client; using Elmah.Io.Client.Models [assembly: FunctionsStartup(typeof(My.FunctionApp.Startup))] namespace My.FunctionApp { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.AddSingleton(config); var elmahIo = ElmahioAPI.Create(config[\"apiKey\"]); builder.Services.AddSingleton(elmahIo.Heartbeats); } } } Inside your function, wrap all of the code in try/catch and add code to create either a Healthy or Unhealthy heartbeat: using System; using System.Threading.Tasks; using Elmah.Io.Client; using Elmah.Io.Client.Models; using Microsoft.Azure.WebJobs; using Microsoft.Extensions.Configuration; namespace My.FunctionApp { public class TimedFunction { private readonly IHeartbeats heartbeats; private readonly IConfiguration configuration; public TimedFunction(IHeartbeats heartbeats, IConfiguration configuration) { this.heartbeats = heartbeats; this.configuration = configuration; } [FunctionName(\"TimedFunction\")] public async Task Run([TimerTrigger(\"0 0 * * * *\")]TimerInfo myTimer) { var heartbeatId = configuration[\"heartbeatId\"]; var logId = configuration[\"logId\"]; try { // Your function code goes here await heartbeats.CreateAsync(heartbeatId, logId, new CreateHeartbeat { Result = \"Healthy\" }); } catch (Exception e) { await heartbeats.CreateAsync(heartbeatId, logId, new CreateHeartbeat { Result = \"Unhealthy\", Reason = e.ToString(), }); } } } } If your function code executes successfully, a Healthy heartbeat is created. If an exception is thrown, an Unhealthy heartbeat with the thrown exception in Reason is created. Using a separate heartbeat function You may want a single heartbeat representing your entire function app consisting of multiple functions. This is a good option if you want to create heartbeats from queue triggered functions or similar. In these cases, you don't want to create a heartbeat every time a message from the queue is handled, but you will want to notify elmah.io if dependencies like database connection suddenly aren't available. We recommend creating a new heartbeat function for this kind of functions. Like in the previous example, make sure to extend your Startup.cs file like this: using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Client; using Elmah.Io.Client.Models [assembly: FunctionsStartup(typeof(My.FunctionApp.Startup))] namespace My.FunctionApp { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.AddSingleton(config); var elmahIo = ElmahioAPI.Create(config[\"apiKey\"]); builder.Services.AddSingleton(elmahIo.Heartbeats); } } } Then create a new timed function with the following code: using System; using System.Threading.Tasks; using Elmah.Io.Client; using Elmah.Io.Client.Models; using Microsoft.Azure.WebJobs; using Microsoft.Extensions.Configuration; namespace My.FunctionApp { public class Heartbeat { private readonly IConfiguration configuration; private readonly IHeartbeats heartbeats; public Heartbeat(IHeartbeats heartbeats, IConfiguration configuration) { this.heartbeats = heartbeats; this.configuration = configuration; } [FunctionName(\"Heartbeat\")] public async Task Run([TimerTrigger(\"0 */5 * * * *\")]TimerInfo myTimer) { var result = \"Healthy\"; var reason = (string)null; try { // Check your dependencies here } catch (Exception e) { result = \"Unhealthy\"; reason = e.ToString(); } await heartbeats.CreateAsync(configuration[\"heartbeatId\"], configuration[\"logId\"], new CreateHeartbeat { Result = result, Reason = reason, }); } } } In the example above, the new function named Heartbeat (the name is entirely up to you) executes every 5 minutes. Replace the comment with your checks like opening a connection to the database. If everything works as it should, a Healthy heartbeat is logged to elmah.io. If an exception is thrown while checking your dependencies, an Unhealthy heartbeat is created. When running locally, you may want to disable heartbeats. You can use the Disable attribute for that by including the following code: #if DEBUG [Disable] #endif public class Heartbeat { // ... } or add the following to local.settings.json : { // ... \"Values\": { \"AzureWebJobs.Heartbeat.Disabled\": true, // ... } }","title":"Logging heartbeats from Azure Functions"},{"location":"logging-heartbeats-from-azure-functions/#logging-heartbeats-from-azure-functions","text":"Logging heartbeats from Azure Functions Using a filter in Elmah.Io.Functions Manually using Elmah.Io.Client Using a separate heartbeat function Azure Functions are great candidates for adding heartbeats. For web API's implemented with Azure Functions, you should create a /health endpoint and ping that using Uptime Monitoring. But for timer triggered, queue triggers, and similar function apps, heartbeats are a great way to verify that your function is successfully running. The rest of this document is split into different ways of adding heartbeats to one or more functions.","title":"Logging heartbeats from Azure Functions"},{"location":"logging-heartbeats-from-azure-functions/#using-a-filter-in-elmahiofunctions","text":"The easiest way of including a heartbeat is to include the ElmahIoHeartbeatFilter available in the Elmah.Io.Functions package. This will automatically publish a Healthy or Unhealthy heartbeat, depending on if your functions execute successfully. This option is great for timer triggered functions like nightly batch jobs. Start by installing the Elmah.Io.Functions package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Functions dotnet add package Elmah.Io.Functions <PackageReference Include=\"Elmah.Io.Functions\" Version=\"3.*\" /> paket add Elmah.Io.Functions Elmah.Io.Functions requires dependency injection part of the Microsoft.Azure.Functions.Extensions package, why you will need this package if not already added. Extend the Startup.cs (or whatever you named your function startup class) file with the following code: using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Functions; [assembly: FunctionsStartup(typeof(My.FunctionApp.Startup))] namespace My.FunctionApp { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.HeartbeatId = config[\"heartbeatId\"]; }); builder.Services.AddSingleton<IFunctionFilter, ElmahIoHeartbeatFilter>(); } } } The code installs the ElmahIoHeartbeatFilter class, which will handle all of the communication with the elmah.io API. Finally, add the config variables ( apiKey , logId , and heartbeatId ) to the local.settings.json file, environment variables, Azure configuration settings, or in whatever way you specify settings for your function app.","title":"Using a filter in Elmah.Io.Functions"},{"location":"logging-heartbeats-from-azure-functions/#manually-using-elmahioclient","text":"The example above installs the heartbeat filter for all functions. If you have multiple functions inside your function app, or you want greater control of when and how to send heartbeats, you can use Elmah.Io.Client to create heartbeats. Start by installing the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Extend the Startup.cs file with the following code: using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Client; using Elmah.Io.Client.Models [assembly: FunctionsStartup(typeof(My.FunctionApp.Startup))] namespace My.FunctionApp { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.AddSingleton(config); var elmahIo = ElmahioAPI.Create(config[\"apiKey\"]); builder.Services.AddSingleton(elmahIo.Heartbeats); } } } Inside your function, wrap all of the code in try/catch and add code to create either a Healthy or Unhealthy heartbeat: using System; using System.Threading.Tasks; using Elmah.Io.Client; using Elmah.Io.Client.Models; using Microsoft.Azure.WebJobs; using Microsoft.Extensions.Configuration; namespace My.FunctionApp { public class TimedFunction { private readonly IHeartbeats heartbeats; private readonly IConfiguration configuration; public TimedFunction(IHeartbeats heartbeats, IConfiguration configuration) { this.heartbeats = heartbeats; this.configuration = configuration; } [FunctionName(\"TimedFunction\")] public async Task Run([TimerTrigger(\"0 0 * * * *\")]TimerInfo myTimer) { var heartbeatId = configuration[\"heartbeatId\"]; var logId = configuration[\"logId\"]; try { // Your function code goes here await heartbeats.CreateAsync(heartbeatId, logId, new CreateHeartbeat { Result = \"Healthy\" }); } catch (Exception e) { await heartbeats.CreateAsync(heartbeatId, logId, new CreateHeartbeat { Result = \"Unhealthy\", Reason = e.ToString(), }); } } } } If your function code executes successfully, a Healthy heartbeat is created. If an exception is thrown, an Unhealthy heartbeat with the thrown exception in Reason is created.","title":"Manually using Elmah.Io.Client"},{"location":"logging-heartbeats-from-azure-functions/#using-a-separate-heartbeat-function","text":"You may want a single heartbeat representing your entire function app consisting of multiple functions. This is a good option if you want to create heartbeats from queue triggered functions or similar. In these cases, you don't want to create a heartbeat every time a message from the queue is handled, but you will want to notify elmah.io if dependencies like database connection suddenly aren't available. We recommend creating a new heartbeat function for this kind of functions. Like in the previous example, make sure to extend your Startup.cs file like this: using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Client; using Elmah.Io.Client.Models [assembly: FunctionsStartup(typeof(My.FunctionApp.Startup))] namespace My.FunctionApp { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.AddSingleton(config); var elmahIo = ElmahioAPI.Create(config[\"apiKey\"]); builder.Services.AddSingleton(elmahIo.Heartbeats); } } } Then create a new timed function with the following code: using System; using System.Threading.Tasks; using Elmah.Io.Client; using Elmah.Io.Client.Models; using Microsoft.Azure.WebJobs; using Microsoft.Extensions.Configuration; namespace My.FunctionApp { public class Heartbeat { private readonly IConfiguration configuration; private readonly IHeartbeats heartbeats; public Heartbeat(IHeartbeats heartbeats, IConfiguration configuration) { this.heartbeats = heartbeats; this.configuration = configuration; } [FunctionName(\"Heartbeat\")] public async Task Run([TimerTrigger(\"0 */5 * * * *\")]TimerInfo myTimer) { var result = \"Healthy\"; var reason = (string)null; try { // Check your dependencies here } catch (Exception e) { result = \"Unhealthy\"; reason = e.ToString(); } await heartbeats.CreateAsync(configuration[\"heartbeatId\"], configuration[\"logId\"], new CreateHeartbeat { Result = result, Reason = reason, }); } } } In the example above, the new function named Heartbeat (the name is entirely up to you) executes every 5 minutes. Replace the comment with your checks like opening a connection to the database. If everything works as it should, a Healthy heartbeat is logged to elmah.io. If an exception is thrown while checking your dependencies, an Unhealthy heartbeat is created. When running locally, you may want to disable heartbeats. You can use the Disable attribute for that by including the following code: #if DEBUG [Disable] #endif public class Heartbeat { // ... } or add the following to local.settings.json : { // ... \"Values\": { \"AzureWebJobs.Heartbeat.Disabled\": true, // ... } }","title":"Using a separate heartbeat function"},{"location":"logging-heartbeats-from-curl/","text":"Logging heartbeats from cURL Sometimes is just easier to use cURL when needing to call a REST API. Creating elmah.io heartbeats is easy using cURL and fits well into scripts, scheduled tasks, and similar. To create a new heartbeat, include the following cURL command in your script: curl -X POST \"https://api.elmah.io/v3/heartbeats/LOG_ID/HEARTBEAT_ID?api_key=API_KEY\" -H \"accept: application/json\" -H \"Content-Type: application/json-patch+json\" -d \"{ \\\"result\\\": \\\"Healthy\\\"}\" Remember to place LOG_ID , HEARTBEAT_ID , and API_KEY with the values found on the Heartbeats tab in elmah.io. To create an Unhealthy heartbeat, change the result in the body and include a reason : curl -X POST \"https://api.elmah.io/v3/heartbeats/LOG_ID/HEARTBEAT_ID?api_key=API_KEY\" -H \"accept: application/json\" -H \"Content-Type: application/json-patch+json\" -d \"{ \\\"result\\\": \\\"Unhealthy\\\", \\\"reason\\\": \\\"Something isn't working\\\" }\"","title":"Logging heartbeats from cURL"},{"location":"logging-heartbeats-from-curl/#logging-heartbeats-from-curl","text":"Sometimes is just easier to use cURL when needing to call a REST API. Creating elmah.io heartbeats is easy using cURL and fits well into scripts, scheduled tasks, and similar. To create a new heartbeat, include the following cURL command in your script: curl -X POST \"https://api.elmah.io/v3/heartbeats/LOG_ID/HEARTBEAT_ID?api_key=API_KEY\" -H \"accept: application/json\" -H \"Content-Type: application/json-patch+json\" -d \"{ \\\"result\\\": \\\"Healthy\\\"}\" Remember to place LOG_ID , HEARTBEAT_ID , and API_KEY with the values found on the Heartbeats tab in elmah.io. To create an Unhealthy heartbeat, change the result in the body and include a reason : curl -X POST \"https://api.elmah.io/v3/heartbeats/LOG_ID/HEARTBEAT_ID?api_key=API_KEY\" -H \"accept: application/json\" -H \"Content-Type: application/json-patch+json\" -d \"{ \\\"result\\\": \\\"Unhealthy\\\", \\\"reason\\\": \\\"Something isn't working\\\" }\"","title":"Logging heartbeats from cURL"},{"location":"logging-heartbeats-from-hangfire/","text":"Logging heartbeats from Hangfire Scheduling recurring tasks with Hangfire is easy. Monitoring if tasks successfully execute or even run can be a challenge. With elmah.io Heartbeats we provide native monitoring of Hangfire recurring taks. To publish heartbeats from Hangifre, install the Elmah.Io.Heartbeats.Hangfire NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Heartbeats.Hangfire dotnet add package Elmah.Io.Heartbeats.Hangfire <PackageReference Include=\"Elmah.Io.Heartbeats.Hangfire\" Version=\"3.*\" /> paket add Elmah.Io.Heartbeats.Hangfire For this example, we'll schedule a method named Test to execute every minute: RecurringJob.AddOrUpdate(() => Test(), Cron.Minutely); To automatically publish a heartbeat when the job is executed, add the following using : using Elmah.Io.Heartbeats.Hangfire; And decorate the Test -method with the ElmahIoHeartbeat attribute: [ElmahIoHeartbeat(\"API_KEY\", \"LOG_ID\", \"HEARTBEAT_ID\")] public void Test() { // ... } Replace API_KEY ( Where is my API key? ), LOG_ID ( Where is my log ID? ), and HEARTBEAT_ID with the correct variables from elmah.io. When the job successfully runs, a Healthy heartbeat is logged to elmah.io. If an exception is thrown an Unhealthy heartbeat is logged. elmah.io will automatically create an error if a heartbeat is missing, as long as the heartbeat is correctly configured as explained in Set up Heartbeats . Move configuration to config files You normally don't include your API key, log ID and heartbeat ID in C# code as shown in the example above. Unfortunately, Hangfire attributes doesn't support dependency injection or configuration from config files. There's a small \"hack\" that you can use to move configuration to a configuration file by creating a custom attribute: using Elmah.Io.Heartbeats.Hangfire; using Hangfire.Common; using Hangfire.Server; using System.Configuration; public class AppSettingsElmahIoHeartbeatAttribute : JobFilterAttribute, IServerFilter { private readonly ElmahIoHeartbeatAttribute _inner; public AppSettingsElmahIoHeartbeatAttribute() { var apiKey = ConfigurationManager.AppSettings[\"apiKey\"]; var logId = ConfigurationManager.AppSettings[\"logId\"]; var heartbeatId = ConfigurationManager.AppSettings[\"heartbeatId\"]; _inner = new ElmahIoHeartbeatAttribute(apiKey, logId, heartbeatId); } public void OnPerformed(PerformedContext filterContext) { _inner.OnPerformed(filterContext); } public void OnPerforming(PerformingContext filterContext) { _inner.OnPerforming(filterContext); } } In the example the AppSettingsElmahIoHeartbeatAttribute class wrap ElmahIoHeartbeatAttribute . By doing so, it is possible to fetch configuration from application settings as part of the constructor. The approach would be similar when using IConfiguration (like in ASP.NET Core), but you will need to share a reference to the configuration object somehow. To use AppSettingsElmahIoHeartbeatAttribute simply add it to the method: [AppSettingsElmahIoHeartbeat] public void Test() { // ... }","title":"Logging heartbeats from Hangfire"},{"location":"logging-heartbeats-from-hangfire/#logging-heartbeats-from-hangfire","text":"Scheduling recurring tasks with Hangfire is easy. Monitoring if tasks successfully execute or even run can be a challenge. With elmah.io Heartbeats we provide native monitoring of Hangfire recurring taks. To publish heartbeats from Hangifre, install the Elmah.Io.Heartbeats.Hangfire NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Heartbeats.Hangfire dotnet add package Elmah.Io.Heartbeats.Hangfire <PackageReference Include=\"Elmah.Io.Heartbeats.Hangfire\" Version=\"3.*\" /> paket add Elmah.Io.Heartbeats.Hangfire For this example, we'll schedule a method named Test to execute every minute: RecurringJob.AddOrUpdate(() => Test(), Cron.Minutely); To automatically publish a heartbeat when the job is executed, add the following using : using Elmah.Io.Heartbeats.Hangfire; And decorate the Test -method with the ElmahIoHeartbeat attribute: [ElmahIoHeartbeat(\"API_KEY\", \"LOG_ID\", \"HEARTBEAT_ID\")] public void Test() { // ... } Replace API_KEY ( Where is my API key? ), LOG_ID ( Where is my log ID? ), and HEARTBEAT_ID with the correct variables from elmah.io. When the job successfully runs, a Healthy heartbeat is logged to elmah.io. If an exception is thrown an Unhealthy heartbeat is logged. elmah.io will automatically create an error if a heartbeat is missing, as long as the heartbeat is correctly configured as explained in Set up Heartbeats .","title":"Logging heartbeats from Hangfire"},{"location":"logging-heartbeats-from-hangfire/#move-configuration-to-config-files","text":"You normally don't include your API key, log ID and heartbeat ID in C# code as shown in the example above. Unfortunately, Hangfire attributes doesn't support dependency injection or configuration from config files. There's a small \"hack\" that you can use to move configuration to a configuration file by creating a custom attribute: using Elmah.Io.Heartbeats.Hangfire; using Hangfire.Common; using Hangfire.Server; using System.Configuration; public class AppSettingsElmahIoHeartbeatAttribute : JobFilterAttribute, IServerFilter { private readonly ElmahIoHeartbeatAttribute _inner; public AppSettingsElmahIoHeartbeatAttribute() { var apiKey = ConfigurationManager.AppSettings[\"apiKey\"]; var logId = ConfigurationManager.AppSettings[\"logId\"]; var heartbeatId = ConfigurationManager.AppSettings[\"heartbeatId\"]; _inner = new ElmahIoHeartbeatAttribute(apiKey, logId, heartbeatId); } public void OnPerformed(PerformedContext filterContext) { _inner.OnPerformed(filterContext); } public void OnPerforming(PerformingContext filterContext) { _inner.OnPerforming(filterContext); } } In the example the AppSettingsElmahIoHeartbeatAttribute class wrap ElmahIoHeartbeatAttribute . By doing so, it is possible to fetch configuration from application settings as part of the constructor. The approach would be similar when using IConfiguration (like in ASP.NET Core), but you will need to share a reference to the configuration object somehow. To use AppSettingsElmahIoHeartbeatAttribute simply add it to the method: [AppSettingsElmahIoHeartbeat] public void Test() { // ... }","title":"Move configuration to config files"},{"location":"logging-heartbeats-from-net-core-worker-services/","text":"Logging heartbeats from .NET Core Worker Services .NET Core offer Worker Services as a way to schedule recurring tasks either hosted inside an ASP.NET Core website or as a Windows Service. Monitoring that Worker Services run successfully, can be easily set up with elmah.io Heartbeats. To register heartbeats from a worker service, start by creating a new heartbeat on the elmah.io UI. For this example, we want to monitor that a Service Worker is running every 5 minutes, why we set Interval to 5 minutes and Grace to 1 minute. Next, install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client In the Program.cs or Startup.cs file (depending on where you register dependencies), register IHeartbeats from the elmah.io client: .ConfigureServices((hostContext, services) => { var elmahIoApi = ElmahioAPI.Create(hostContext.Configuration[\"ElmahIo:ApiKey\"]); services.AddSingleton(elmahIoApi.Heartbeats); // ... services.AddHostedService<Worker>(); }); In the example, the configuration should be made available in the appsettings.json file as shown later in this article. In the service class ( Worker ) you can inject the IHeartbeats object, as well as additional configuration needed to create heartbeats: public class Worker : BackgroundService { private readonly IHeartbeats heartbeats; private readonly Guid logId; private readonly string heartbeatId; public Worker(IHeartbeats heartbeats, IConfiguration configuration) { this.heartbeats = heartbeats; this.logId = new Guid(configuration[\"ElmahIo:LogId\"]); this.heartbeatId = configuration[\"ElmahIo:HeartbeatId\"]; } } Inside the ExecuteAsync method, wrap the worker code in try-catch and call the HealthyAsync method when the worker successfully run and the UnhealthyAsync method when an exception occurs: protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { try { // Do work await heartbeats.HealthyAsync(logId, heartbeatId); } catch (Exception e) { await heartbeats.UnhealthyAsync(logId, heartbeatId, e.ToString()); } await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken); } } In the appsettings.json file, add the elmah.io configuration: { \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\", \"HeartbeatId\": \"HEARTBEAT_ID\" } } Replace the values with values found in the elmah.io UI. Remember to enable the Heartbeats | Write permission on the used API key.","title":"Logging heartbeats from .NET Core Worker Services"},{"location":"logging-heartbeats-from-net-core-worker-services/#logging-heartbeats-from-net-core-worker-services","text":".NET Core offer Worker Services as a way to schedule recurring tasks either hosted inside an ASP.NET Core website or as a Windows Service. Monitoring that Worker Services run successfully, can be easily set up with elmah.io Heartbeats. To register heartbeats from a worker service, start by creating a new heartbeat on the elmah.io UI. For this example, we want to monitor that a Service Worker is running every 5 minutes, why we set Interval to 5 minutes and Grace to 1 minute. Next, install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client In the Program.cs or Startup.cs file (depending on where you register dependencies), register IHeartbeats from the elmah.io client: .ConfigureServices((hostContext, services) => { var elmahIoApi = ElmahioAPI.Create(hostContext.Configuration[\"ElmahIo:ApiKey\"]); services.AddSingleton(elmahIoApi.Heartbeats); // ... services.AddHostedService<Worker>(); }); In the example, the configuration should be made available in the appsettings.json file as shown later in this article. In the service class ( Worker ) you can inject the IHeartbeats object, as well as additional configuration needed to create heartbeats: public class Worker : BackgroundService { private readonly IHeartbeats heartbeats; private readonly Guid logId; private readonly string heartbeatId; public Worker(IHeartbeats heartbeats, IConfiguration configuration) { this.heartbeats = heartbeats; this.logId = new Guid(configuration[\"ElmahIo:LogId\"]); this.heartbeatId = configuration[\"ElmahIo:HeartbeatId\"]; } } Inside the ExecuteAsync method, wrap the worker code in try-catch and call the HealthyAsync method when the worker successfully run and the UnhealthyAsync method when an exception occurs: protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { try { // Do work await heartbeats.HealthyAsync(logId, heartbeatId); } catch (Exception e) { await heartbeats.UnhealthyAsync(logId, heartbeatId, e.ToString()); } await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken); } } In the appsettings.json file, add the elmah.io configuration: { \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\", \"HeartbeatId\": \"HEARTBEAT_ID\" } } Replace the values with values found in the elmah.io UI. Remember to enable the Heartbeats | Write permission on the used API key.","title":"Logging heartbeats from .NET Core Worker Services"},{"location":"logging-heartbeats-from-powershell/","text":"Logging heartbeats from PowerShell The Heartbeats feature is a great way to verify that scripts run successfully too. A lot of people have PowerShell scripts running on a schedule to clean up folders on the file system, make batch changes in a database, and more. To include heartbeats in your PowerShell script, wrap the code in try/catch and add either Healthy or Unhealthy result: $apiKey = \"API_KEY\" $logId = \"LOG_ID\" $heartbeatId = \"HEARTBEAT_ID\" $url = \"https://api.elmah.io/v3/heartbeats/$logId/$heartbeatId/?api_key=$apiKey\" try { # Your script goes here $body = @{ result = \"Healthy\" } Invoke-RestMethod -Method Post -Uri $url -Body ($body|ConvertTo-Json) -ContentType \"application/json-patch+json\" } catch { $body = @{ result = \"Unhealthy\" reason = $_.Exception.Message } Invoke-RestMethod -Method Post -Uri $url -Body ($body|ConvertTo-Json) -ContentType \"application/json-patch+json\" } If everything goes well, a Healthy heartbeat is logged using the Invoke-RestMethod cmdlet. If an exception is thrown in your script, an Unhealthy heartbeat is logged.","title":"Logging heartbeats from PowerShell"},{"location":"logging-heartbeats-from-powershell/#logging-heartbeats-from-powershell","text":"The Heartbeats feature is a great way to verify that scripts run successfully too. A lot of people have PowerShell scripts running on a schedule to clean up folders on the file system, make batch changes in a database, and more. To include heartbeats in your PowerShell script, wrap the code in try/catch and add either Healthy or Unhealthy result: $apiKey = \"API_KEY\" $logId = \"LOG_ID\" $heartbeatId = \"HEARTBEAT_ID\" $url = \"https://api.elmah.io/v3/heartbeats/$logId/$heartbeatId/?api_key=$apiKey\" try { # Your script goes here $body = @{ result = \"Healthy\" } Invoke-RestMethod -Method Post -Uri $url -Body ($body|ConvertTo-Json) -ContentType \"application/json-patch+json\" } catch { $body = @{ result = \"Unhealthy\" reason = $_.Exception.Message } Invoke-RestMethod -Method Post -Uri $url -Body ($body|ConvertTo-Json) -ContentType \"application/json-patch+json\" } If everything goes well, a Healthy heartbeat is logged using the Invoke-RestMethod cmdlet. If an exception is thrown in your script, an Unhealthy heartbeat is logged.","title":"Logging heartbeats from PowerShell"},{"location":"logging-heartbeats-from-umbraco/","text":"Logging heartbeats from Umbraco Umbraco comes with a nice health check feature which can carry out a range of built-in health checks as well as custom checks you may want to add. Umbraco Health Checks fits perfectly with elmah.io Heartbeats. To start publishing Umbraco Health Checks to elmah.io, create a new health check. Select 1 day in Interval and 5 minutes in Grace . Next, install the Elmah.Io.Umbraco NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco dotnet add package Elmah.Io.Umbraco <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.*\" /> paket add Elmah.Io.Umbraco For Umbraco to automatically execute health checks, you will need to set your back office URL in the umbracoSettings.config file: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <settings> <!-- ... --> <web.routing umbracoApplicationUrl=\"https://localhost:44381/umbraco/\"> </web.routing> </settings> (localhost used as an example and should be replaced with a real URL) Umbraco comes with an email publisher already configured. To publish health check results to your newly created heartbeat, extend the HealthChecks.config file: <?xml version =\"1.0\" encoding=\"utf-8\" ?> <HealthChecks> <disabledChecks> </disabledChecks> <notificationSettings enabled=\"true\" firstRunTime=\"\" periodInHours=\"24\"> <notificationMethods> <notificationMethod alias=\"elmah.io\" enabled=\"true\" verbosity=\"Summary\"> <settings> <add key=\"apiKey\" value=\"API_KEY\" /> <add key=\"logId\" value=\"LOG_ID\" /> <add key=\"heartbeatId\" value=\"HEARTBEAT_ID\" /> </settings> </notificationMethod> <notificationMethod alias=\"email\" enabled=\"false\" verbosity=\"Summary\"> <settings> <add key=\"recipientEmail\" value=\"\" /> </settings> </notificationMethod> </notificationMethods> <disabledChecks> </disabledChecks> </notificationSettings> </HealthChecks> For this example I have disabled the email notification publisher but you can run with both if you'd like. Replace API_KEY , LOG_ID , and HEARTBEAT_ID with the values found on the elmah.io UI. When launching the website Umbraco automatically executes the health checks once every 24 hours and sends the results to elmah.io.","title":"Logging heartbeats from Umbraco"},{"location":"logging-heartbeats-from-umbraco/#logging-heartbeats-from-umbraco","text":"Umbraco comes with a nice health check feature which can carry out a range of built-in health checks as well as custom checks you may want to add. Umbraco Health Checks fits perfectly with elmah.io Heartbeats. To start publishing Umbraco Health Checks to elmah.io, create a new health check. Select 1 day in Interval and 5 minutes in Grace . Next, install the Elmah.Io.Umbraco NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco dotnet add package Elmah.Io.Umbraco <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.*\" /> paket add Elmah.Io.Umbraco For Umbraco to automatically execute health checks, you will need to set your back office URL in the umbracoSettings.config file: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <settings> <!-- ... --> <web.routing umbracoApplicationUrl=\"https://localhost:44381/umbraco/\"> </web.routing> </settings> (localhost used as an example and should be replaced with a real URL) Umbraco comes with an email publisher already configured. To publish health check results to your newly created heartbeat, extend the HealthChecks.config file: <?xml version =\"1.0\" encoding=\"utf-8\" ?> <HealthChecks> <disabledChecks> </disabledChecks> <notificationSettings enabled=\"true\" firstRunTime=\"\" periodInHours=\"24\"> <notificationMethods> <notificationMethod alias=\"elmah.io\" enabled=\"true\" verbosity=\"Summary\"> <settings> <add key=\"apiKey\" value=\"API_KEY\" /> <add key=\"logId\" value=\"LOG_ID\" /> <add key=\"heartbeatId\" value=\"HEARTBEAT_ID\" /> </settings> </notificationMethod> <notificationMethod alias=\"email\" enabled=\"false\" verbosity=\"Summary\"> <settings> <add key=\"recipientEmail\" value=\"\" /> </settings> </notificationMethod> </notificationMethods> <disabledChecks> </disabledChecks> </notificationSettings> </HealthChecks> For this example I have disabled the email notification publisher but you can run with both if you'd like. Replace API_KEY , LOG_ID , and HEARTBEAT_ID with the values found on the elmah.io UI. When launching the website Umbraco automatically executes the health checks once every 24 hours and sends the results to elmah.io.","title":"Logging heartbeats from Umbraco"},{"location":"logging-through-a-http-proxy/","text":"Logging through a HTTP proxy You may find yourself in a situation, where your production web servers aren't allowing HTTP requests towards the public Internet. This also impacts the elmah.io client, which requires access to the URL https://api.elmah.io. A popular choice of implementing this kind of restriction nowadays, is through a HTTP proxy like squid. Luckily the elmah.io client supports proxy configuration out of the box. Let\u2019s look at how to configure a HTTP proxy through web.config : <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <configSections> <sectionGroup name=\"elmah\"> <section name=\"security\" requirePermission=\"false\" type=\"Elmah.SecuritySectionHandler, Elmah\" /> <section name=\"errorLog\" requirePermission=\"false\" type=\"Elmah.ErrorLogSectionHandler, Elmah\" /> <section name=\"errorMail\" requirePermission=\"false\" type=\"Elmah.ErrorMailSectionHandler, Elmah\" /> <section name=\"errorFilter\" requirePermission=\"false\" type=\"Elmah.ErrorFilterSectionHandler, Elmah\" /> </sectionGroup> </configSections> <elmah> <security allowRemoteAccess=\"false\" /> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"...\" logId=\"...\" /> </elmah> <system.net> <defaultProxy> <proxy usesystemdefault=\"True\" proxyaddress=\"http://192.168.0.1:3128\" bypassonlocal=\"False\"/> </defaultProxy> </system.net> </configuration> The above example is of course greatly simplified. The elmah.io client automatically picks up the defaultProxy configuration through the system.net element. defaultProxy tunnels every request from your server, including requests to elmah.io, through the proxy located on 192.18.0.1 port 3128 (or whatever IP/hostname and port you are using). Proxies with username/password Some proxies require a username/password. Unfortunately, the defaultProxy element doesn't support authentication. You have two ways to set this up: Use default credentials Make sure to set the useDefaultCredentials attribute to true : <system.net> <defaultProxy useDefaultCredentials=\"true\"> <!-- ... --> </defaultProxy> </system.net> Run your web app (application pool) as a user with access to the proxy. Implement your own proxy Add the following class: public class AuthenticatingProxy : IWebProxy { public ICredentials Credentials { get { return new NetworkCredential(\"username\", \"password\"); } set {} } public Uri GetProxy(Uri destination) { return new Uri(\"http://localhost:8888\"); } public bool IsBypassed(Uri host) { return false; } } Configure the new proxy in web.config : <defaultProxy useDefaultCredentials=\"false\"> <module type=\"YourNamespace.AuthenticatingProxy, YourAssembly\" /> </defaultProxy>","title":"Logging through a HTTP proxy"},{"location":"logging-through-a-http-proxy/#logging-through-a-http-proxy","text":"You may find yourself in a situation, where your production web servers aren't allowing HTTP requests towards the public Internet. This also impacts the elmah.io client, which requires access to the URL https://api.elmah.io. A popular choice of implementing this kind of restriction nowadays, is through a HTTP proxy like squid. Luckily the elmah.io client supports proxy configuration out of the box. Let\u2019s look at how to configure a HTTP proxy through web.config : <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <configSections> <sectionGroup name=\"elmah\"> <section name=\"security\" requirePermission=\"false\" type=\"Elmah.SecuritySectionHandler, Elmah\" /> <section name=\"errorLog\" requirePermission=\"false\" type=\"Elmah.ErrorLogSectionHandler, Elmah\" /> <section name=\"errorMail\" requirePermission=\"false\" type=\"Elmah.ErrorMailSectionHandler, Elmah\" /> <section name=\"errorFilter\" requirePermission=\"false\" type=\"Elmah.ErrorFilterSectionHandler, Elmah\" /> </sectionGroup> </configSections> <elmah> <security allowRemoteAccess=\"false\" /> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"...\" logId=\"...\" /> </elmah> <system.net> <defaultProxy> <proxy usesystemdefault=\"True\" proxyaddress=\"http://192.168.0.1:3128\" bypassonlocal=\"False\"/> </defaultProxy> </system.net> </configuration> The above example is of course greatly simplified. The elmah.io client automatically picks up the defaultProxy configuration through the system.net element. defaultProxy tunnels every request from your server, including requests to elmah.io, through the proxy located on 192.18.0.1 port 3128 (or whatever IP/hostname and port you are using).","title":"Logging through a HTTP proxy"},{"location":"logging-through-a-http-proxy/#proxies-with-usernamepassword","text":"Some proxies require a username/password. Unfortunately, the defaultProxy element doesn't support authentication. You have two ways to set this up:","title":"Proxies with username/password"},{"location":"logging-through-a-http-proxy/#use-default-credentials","text":"Make sure to set the useDefaultCredentials attribute to true : <system.net> <defaultProxy useDefaultCredentials=\"true\"> <!-- ... --> </defaultProxy> </system.net> Run your web app (application pool) as a user with access to the proxy.","title":"Use default credentials"},{"location":"logging-through-a-http-proxy/#implement-your-own-proxy","text":"Add the following class: public class AuthenticatingProxy : IWebProxy { public ICredentials Credentials { get { return new NetworkCredential(\"username\", \"password\"); } set {} } public Uri GetProxy(Uri destination) { return new Uri(\"http://localhost:8888\"); } public bool IsBypassed(Uri host) { return false; } } Configure the new proxy in web.config : <defaultProxy useDefaultCredentials=\"false\"> <module type=\"YourNamespace.AuthenticatingProxy, YourAssembly\" /> </defaultProxy>","title":"Implement your own proxy"},{"location":"logging-to-elmah-io-from-a-running-website-on-azure/","text":"Logging to elmah.io from a running website on Azure Adding elmah.io on a running website isn't the recommended way to install. It should be used if you are unable to deploy a new version only. To enable error logging to elmah.io, you usually install one of our client integrations through PowerShell or Visual Studio and deploy a new version of your website to a web server. Sometimes you need to monitor an already running website or don't want logging logic as part of your repository. Using the elmah.io Site Extension for Azure App Services, error logging can be added to an already running website. Check out this video tutorial or keep reading for the text version: To start logging errors from your Azure web application, go to the Azure Portal and select the website you want to monitor. Click the Extensions tool: Click the Add button and select .NET elmah.io for Azure : Accept the terms and click the OK button. The elmah.io Site Extension is now added. Once added, restart the website for the new extension to load. Finally, you need to add your API key ( Where is my API key? ) and log ID ( Where is my log ID? ) to Application settings : Make sure to use the app setting names ELMAHIO_APIKEY and ELMAHIO_LOGID . Your Azure web application now logs all uncaught exceptions to elmah.io. Please notice that this only works for ASP.NET, MVC, Web API, and similar. ASP.NET Core websites should be installed locally and re-deployed. Also, the elmah.io Site Extensions supports .NET Full Framework 4.6 and newer. Troubleshooting ConfigurationErrorsException: Could not load file or assembly 'Elmah' or one of its dependencies. The system cannot find the file specified. After uninstalling the elmah.io site extension, you may see the configuration error above. This means that elmah.io's uninstall script for some reason wasn't allowed to run or resulted in an error. To make sure that elmah.io is completely removed, follow these steps: Stop your website. Browse your website files through Kudu. Remove all files starting with Elmah . Start your website.","title":"Logging from a running website on Azure"},{"location":"logging-to-elmah-io-from-a-running-website-on-azure/#logging-to-elmahio-from-a-running-website-on-azure","text":"Adding elmah.io on a running website isn't the recommended way to install. It should be used if you are unable to deploy a new version only. To enable error logging to elmah.io, you usually install one of our client integrations through PowerShell or Visual Studio and deploy a new version of your website to a web server. Sometimes you need to monitor an already running website or don't want logging logic as part of your repository. Using the elmah.io Site Extension for Azure App Services, error logging can be added to an already running website. Check out this video tutorial or keep reading for the text version: To start logging errors from your Azure web application, go to the Azure Portal and select the website you want to monitor. Click the Extensions tool: Click the Add button and select .NET elmah.io for Azure : Accept the terms and click the OK button. The elmah.io Site Extension is now added. Once added, restart the website for the new extension to load. Finally, you need to add your API key ( Where is my API key? ) and log ID ( Where is my log ID? ) to Application settings : Make sure to use the app setting names ELMAHIO_APIKEY and ELMAHIO_LOGID . Your Azure web application now logs all uncaught exceptions to elmah.io. Please notice that this only works for ASP.NET, MVC, Web API, and similar. ASP.NET Core websites should be installed locally and re-deployed. Also, the elmah.io Site Extensions supports .NET Full Framework 4.6 and newer.","title":"Logging to elmah.io from a running website on Azure"},{"location":"logging-to-elmah-io-from-a-running-website-on-azure/#troubleshooting","text":"ConfigurationErrorsException: Could not load file or assembly 'Elmah' or one of its dependencies. The system cannot find the file specified. After uninstalling the elmah.io site extension, you may see the configuration error above. This means that elmah.io's uninstall script for some reason wasn't allowed to run or resulted in an error. To make sure that elmah.io is completely removed, follow these steps: Stop your website. Browse your website files through Kudu. Remove all files starting with Elmah . Start your website.","title":"Troubleshooting"},{"location":"logging-to-elmah-io-from-a-running-website-on-iis/","text":"Logging to elmah.io from a running website on IIS Adding elmah.io on a running website isn't the recommended way to install. It should be used if you are unable to deploy a new version only. To enable error logging to elmah.io, you usually install one of our client integrations through PowerShell or Visual Studio and deploy a new version of your website to a web server. Sometimes you need to monitor an already running website or don't want logging logic as part of your repository. elmah.io can be added to a running website by following this guide. Run the following command somewhere on your computer: nuget install elmah.io From the folder where you ran the command, copy the following files to the bin folder of your running website: elmah.corelibrary.x.y.z\\lib\\Elmah.dll elmah.io.x.y.z\\lib\\net45\\Elmah.Io.dll Elmah.Io.Client.x.y.z\\lib\\<.net version your website is using>\\Elmah.Io.Client.dll Microsoft.Rest.ClientRuntime.x.y.z\\lib\\net452\\Microsoft.Rest.ClientRuntime.dll Newtonsoft.Json.x.y.z\\lib\\<.net version your website is using>\\Newtonsoft.Json.dll Configure elmah.io in Web.config as described here: Configure elmah.io manually (you don't need to call the Install-Package command). If the website doesn't start logging errors to elmah.io, you may need to restart it.","title":"Logging from a running website on IIS"},{"location":"logging-to-elmah-io-from-a-running-website-on-iis/#logging-to-elmahio-from-a-running-website-on-iis","text":"Adding elmah.io on a running website isn't the recommended way to install. It should be used if you are unable to deploy a new version only. To enable error logging to elmah.io, you usually install one of our client integrations through PowerShell or Visual Studio and deploy a new version of your website to a web server. Sometimes you need to monitor an already running website or don't want logging logic as part of your repository. elmah.io can be added to a running website by following this guide. Run the following command somewhere on your computer: nuget install elmah.io From the folder where you ran the command, copy the following files to the bin folder of your running website: elmah.corelibrary.x.y.z\\lib\\Elmah.dll elmah.io.x.y.z\\lib\\net45\\Elmah.Io.dll Elmah.Io.Client.x.y.z\\lib\\<.net version your website is using>\\Elmah.Io.Client.dll Microsoft.Rest.ClientRuntime.x.y.z\\lib\\net452\\Microsoft.Rest.ClientRuntime.dll Newtonsoft.Json.x.y.z\\lib\\<.net version your website is using>\\Newtonsoft.Json.dll Configure elmah.io in Web.config as described here: Configure elmah.io manually (you don't need to call the Install-Package command). If the website doesn't start logging errors to elmah.io, you may need to restart it.","title":"Logging to elmah.io from a running website on IIS"},{"location":"logging-to-elmah-io-from-aspnet-core/","text":"Logging to elmah.io from ASP.NET Core Logging to elmah.io from ASP.NET Core Configuring API key and log ID in options Logging exceptions manually Additional options Events Remove sensitive form data Formatting exceptions Logging responses not throwing an exception Logging through a proxy Logging health check results If you are looking to log all uncaught errors from ASP.NET Core, you've come to the right place. For help setting up general .NET Core logging similar to log4net, check out Logging from Microsoft.Extensions.Logging . To log all warnings and errors from ASP.NET Core, install the following NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore dotnet add package Elmah.Io.AspNetCore <PackageReference Include=\"Elmah.Io.AspNetCore\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore Call AddElmahIo in the ConfigureServices -method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); }); // ... } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with the log Id of the log you want to log to. Call UseElmahIo in the Configure -method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory fac) { // ... app.UseElmahIo(); // ... } Make sure to call the UseElmahIo -method after installation of other pieces of middleware handling exceptions and auth (like UseDeveloperExceptionPage , UseExceptionHandler , UseAuthentication , and UseAuthorization ), but before any calls to UseStaticFiles , UseMvc and similar. That's it. Every uncaught exception will be logged to elmah.io. Configuring API key and log ID in options If you have different environments (everyone have a least localhost and production), you should consider adding the API key and log ID in your appsettings.json file: { // ... \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Configuring elmah.io is done by calling the Configure method instead of AddElmahIo : public void ConfigureServices(IServiceCollection services) { services.Configure<ElmahIoOptions>(Configuration.GetSection(\"ElmahIo\")); services.AddElmahIo(); } Notice that you still need to call AddElmahIo in order to correctly register middleware dependencies. Finally, call the UseElmahIo -method (as you would do with config in C# too): public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... app.UseElmahIo(); // ... } You can still configure additional options on the ElmahIoOptions object: public void ConfigureServices(IServiceCollection services) { services.Configure<ElmahIoOptions>(Configuration.GetSection(\"ElmahIo\")); services.Configure<ElmahIoOptions>(o => { o.OnMessage = msg => { msg.Version = \"1.0.0\"; }; }); services.AddElmahIo(); } Logging exceptions manually While automatically logging all uncaught exceptions is definitely a nice feature, sometimes you may want to catch exceptions and log them manually. If you just want to log the exception details, without all of the contextual information about the HTTP context (cookies, server variables, etc.), we recommend you to look at our integration for Microsoft.Extensions.Logging . If the context is important for the error, you can utilize the Ship -methods available in Elmah.Io.AspNetCore : try { var i = 0; var result = 42/i; } catch (DivideByZeroException e) { e.Ship(HttpContext); } When catching an exception, you simply call the Ship extension method with the current HTTP context as parameter. Additional options Events elmah.io for ASP.NET Core supports a range of events for hooking into the process of logging messages. Events are registered as actions when installing the elmah.io middleware: services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); o.OnMessage = message => { message.Version = \"42\"; }; o.OnError = (message, exception) => { logger.LogError(1, exception, \"Error during log to elmah.io\"); }; }); The actions provide a mechanism for hooking into the log process. The action registered in the OnMessage property is called by elmah.io just before logging a new message to the API. Use this action to decorate/enrich your log messages with additional data, like a version number. The OnError action is called if communication with the elmah.io API failed. If this happens, you should log the message to a local log (through Microsoft.Extensions.Logging, Serilog or similar). Do not log to elmah.io in your OnError action, since that could cause an infinite loop in your code. While elmah.io supports ignore rules serverside, you may want to filter out errors without even hitting the elmah.io API. Using the OnFilter function on the options object, filtering is easy: services.AddElmahIo(o => { // ... o.OnFilter = message => { return message.Type == \"System.NullReferenceException\"; }; }); The example above, ignores all messages of type System.NullReferenceException . Remove sensitive form data The OnMessage event can be used to filter sensitive form data as well. In the following example, we remove the server variable named Secret-Key from all messages, before sending them to elmah.io. services.AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); options.OnMessage = msg => { var item = msg.ServerVariables.FirstOrDefault(x => x.Key == \"Secret-Key\"); if (item != null) { msg.ServerVariables.Remove(item); } }; }); Formatting exceptions A default exception formatter is used to format any exceptions, before sending them off to the elmah.io API. To override the format of the details field in elmah.io, set a new IExceptionFormatter in the ExceptionFormatter property on the ElmahIoOptions object: services.AddElmahIo(o => { // ... o.ExceptionFormatter = new DefaultExceptionFormatter(); } Besides the default exception formatted ( DefaultExceptionFormatter ), Elmah.Io.AspNetCore comes with a formatter called YellowScreenOfDeathExceptionFormatter . This formatter, outputs an exception and its inner exceptions as a list of exceptions, much like on the ASP.NET yellow screen of death. If you want, implementing your own exception formatter, requires you to implement a single method. Logging responses not throwing an exception As default, uncaught exceptions (500's) and 404's are logged automatically. Let's say you have a controller returning a Bad Request and want to log that as well. Since returning a 400 from a controller doesn't trigger an exception, you will need to configure this status code: services.AddElmahIo(o => { // ... o.HandledStatusCodesToLog = new List<int> { 400 }; } Logging through a proxy Since ASP.NET Core no longer support proxy configuration through web.config , you can log to elmah.io by configuring a proxy manually: services.AddElmahIo(o => { // ... o.WebProxy = new System.Net.WebProxy(\"localhost\", 8888); } In this example, the elmah.io client routes all traffic through http://localhost:8000 . ASP.NET Core 2.1 seems to have some problems when setting up authenticated proxies. Logging health check results The current elmah.io health check publisher will be discontinued. In the future, ASP.NET Core Health Checks will be integrated with elmah.io Heartbeats. Check out Logging heartbeats from ASP.NET Core for details. ASP.NET Core 2.2 introduced a new feature named Health Checks. Health checks enable much more sofisticated uptime checks, by allowing you to verify not only uptime on your own website, but also on any dependency or precondition necessary for your website to work. For a general introduction to health checks, I recommend you to read ASP.NET Core 2.2 Health Checks Explained . Health checks have error reporting built-in. We provide a publisher in order to allow ASP.NET Core to ship health check errors directly to your log on elmah.io. Start by installing the Elmah.Io.AspNetCore.HealthChecks NuGet package: Install-Package Elmah.Io.AspNetCore.HealthChecks -IncludePrerelease Then configure the elmah.io publisher as part of initializing health checks: public void ConfigureServices(IServiceCollection services) { // ... services .AddHealthChecks() .AddElmahIoPublisher(\"API_KEY\", new Guid(\"LOG_ID\")); // ... } If using Elmah.Io.AspNetCore.HealthChecks together with Health Checks UI make sure to call AddHealthChecksUI after calling AddElmahIoPublisher .","title":"Logging from ASP.NET Core"},{"location":"logging-to-elmah-io-from-aspnet-core/#logging-to-elmahio-from-aspnet-core","text":"Logging to elmah.io from ASP.NET Core Configuring API key and log ID in options Logging exceptions manually Additional options Events Remove sensitive form data Formatting exceptions Logging responses not throwing an exception Logging through a proxy Logging health check results If you are looking to log all uncaught errors from ASP.NET Core, you've come to the right place. For help setting up general .NET Core logging similar to log4net, check out Logging from Microsoft.Extensions.Logging . To log all warnings and errors from ASP.NET Core, install the following NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore dotnet add package Elmah.Io.AspNetCore <PackageReference Include=\"Elmah.Io.AspNetCore\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore Call AddElmahIo in the ConfigureServices -method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); }); // ... } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with the log Id of the log you want to log to. Call UseElmahIo in the Configure -method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory fac) { // ... app.UseElmahIo(); // ... } Make sure to call the UseElmahIo -method after installation of other pieces of middleware handling exceptions and auth (like UseDeveloperExceptionPage , UseExceptionHandler , UseAuthentication , and UseAuthorization ), but before any calls to UseStaticFiles , UseMvc and similar. That's it. Every uncaught exception will be logged to elmah.io.","title":"Logging to elmah.io from ASP.NET Core"},{"location":"logging-to-elmah-io-from-aspnet-core/#configuring-api-key-and-log-id-in-options","text":"If you have different environments (everyone have a least localhost and production), you should consider adding the API key and log ID in your appsettings.json file: { // ... \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Configuring elmah.io is done by calling the Configure method instead of AddElmahIo : public void ConfigureServices(IServiceCollection services) { services.Configure<ElmahIoOptions>(Configuration.GetSection(\"ElmahIo\")); services.AddElmahIo(); } Notice that you still need to call AddElmahIo in order to correctly register middleware dependencies. Finally, call the UseElmahIo -method (as you would do with config in C# too): public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... app.UseElmahIo(); // ... } You can still configure additional options on the ElmahIoOptions object: public void ConfigureServices(IServiceCollection services) { services.Configure<ElmahIoOptions>(Configuration.GetSection(\"ElmahIo\")); services.Configure<ElmahIoOptions>(o => { o.OnMessage = msg => { msg.Version = \"1.0.0\"; }; }); services.AddElmahIo(); }","title":"Configuring API key and log ID in options"},{"location":"logging-to-elmah-io-from-aspnet-core/#logging-exceptions-manually","text":"While automatically logging all uncaught exceptions is definitely a nice feature, sometimes you may want to catch exceptions and log them manually. If you just want to log the exception details, without all of the contextual information about the HTTP context (cookies, server variables, etc.), we recommend you to look at our integration for Microsoft.Extensions.Logging . If the context is important for the error, you can utilize the Ship -methods available in Elmah.Io.AspNetCore : try { var i = 0; var result = 42/i; } catch (DivideByZeroException e) { e.Ship(HttpContext); } When catching an exception, you simply call the Ship extension method with the current HTTP context as parameter.","title":"Logging exceptions manually"},{"location":"logging-to-elmah-io-from-aspnet-core/#additional-options","text":"","title":"Additional options"},{"location":"logging-to-elmah-io-from-aspnet-core/#events","text":"elmah.io for ASP.NET Core supports a range of events for hooking into the process of logging messages. Events are registered as actions when installing the elmah.io middleware: services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); o.OnMessage = message => { message.Version = \"42\"; }; o.OnError = (message, exception) => { logger.LogError(1, exception, \"Error during log to elmah.io\"); }; }); The actions provide a mechanism for hooking into the log process. The action registered in the OnMessage property is called by elmah.io just before logging a new message to the API. Use this action to decorate/enrich your log messages with additional data, like a version number. The OnError action is called if communication with the elmah.io API failed. If this happens, you should log the message to a local log (through Microsoft.Extensions.Logging, Serilog or similar). Do not log to elmah.io in your OnError action, since that could cause an infinite loop in your code. While elmah.io supports ignore rules serverside, you may want to filter out errors without even hitting the elmah.io API. Using the OnFilter function on the options object, filtering is easy: services.AddElmahIo(o => { // ... o.OnFilter = message => { return message.Type == \"System.NullReferenceException\"; }; }); The example above, ignores all messages of type System.NullReferenceException .","title":"Events"},{"location":"logging-to-elmah-io-from-aspnet-core/#remove-sensitive-form-data","text":"The OnMessage event can be used to filter sensitive form data as well. In the following example, we remove the server variable named Secret-Key from all messages, before sending them to elmah.io. services.AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); options.OnMessage = msg => { var item = msg.ServerVariables.FirstOrDefault(x => x.Key == \"Secret-Key\"); if (item != null) { msg.ServerVariables.Remove(item); } }; });","title":"Remove sensitive form data"},{"location":"logging-to-elmah-io-from-aspnet-core/#formatting-exceptions","text":"A default exception formatter is used to format any exceptions, before sending them off to the elmah.io API. To override the format of the details field in elmah.io, set a new IExceptionFormatter in the ExceptionFormatter property on the ElmahIoOptions object: services.AddElmahIo(o => { // ... o.ExceptionFormatter = new DefaultExceptionFormatter(); } Besides the default exception formatted ( DefaultExceptionFormatter ), Elmah.Io.AspNetCore comes with a formatter called YellowScreenOfDeathExceptionFormatter . This formatter, outputs an exception and its inner exceptions as a list of exceptions, much like on the ASP.NET yellow screen of death. If you want, implementing your own exception formatter, requires you to implement a single method.","title":"Formatting exceptions"},{"location":"logging-to-elmah-io-from-aspnet-core/#logging-responses-not-throwing-an-exception","text":"As default, uncaught exceptions (500's) and 404's are logged automatically. Let's say you have a controller returning a Bad Request and want to log that as well. Since returning a 400 from a controller doesn't trigger an exception, you will need to configure this status code: services.AddElmahIo(o => { // ... o.HandledStatusCodesToLog = new List<int> { 400 }; }","title":"Logging responses not throwing an exception"},{"location":"logging-to-elmah-io-from-aspnet-core/#logging-through-a-proxy","text":"Since ASP.NET Core no longer support proxy configuration through web.config , you can log to elmah.io by configuring a proxy manually: services.AddElmahIo(o => { // ... o.WebProxy = new System.Net.WebProxy(\"localhost\", 8888); } In this example, the elmah.io client routes all traffic through http://localhost:8000 . ASP.NET Core 2.1 seems to have some problems when setting up authenticated proxies.","title":"Logging through a proxy"},{"location":"logging-to-elmah-io-from-aspnet-core/#logging-health-check-results","text":"The current elmah.io health check publisher will be discontinued. In the future, ASP.NET Core Health Checks will be integrated with elmah.io Heartbeats. Check out Logging heartbeats from ASP.NET Core for details. ASP.NET Core 2.2 introduced a new feature named Health Checks. Health checks enable much more sofisticated uptime checks, by allowing you to verify not only uptime on your own website, but also on any dependency or precondition necessary for your website to work. For a general introduction to health checks, I recommend you to read ASP.NET Core 2.2 Health Checks Explained . Health checks have error reporting built-in. We provide a publisher in order to allow ASP.NET Core to ship health check errors directly to your log on elmah.io. Start by installing the Elmah.Io.AspNetCore.HealthChecks NuGet package: Install-Package Elmah.Io.AspNetCore.HealthChecks -IncludePrerelease Then configure the elmah.io publisher as part of initializing health checks: public void ConfigureServices(IServiceCollection services) { // ... services .AddHealthChecks() .AddElmahIoPublisher(\"API_KEY\", new Guid(\"LOG_ID\")); // ... } If using Elmah.Io.AspNetCore.HealthChecks together with Health Checks UI make sure to call AddHealthChecksUI after calling AddElmahIoPublisher .","title":"Logging health check results"},{"location":"logging-to-elmah-io-from-aspnet-mvc/","text":"Logging to elmah.io from ASP.NET MVC Even though ELMAH works out of the box with ASP.NET MVC, ELMAH and MVC provides some features which interfere with one another. As usual, the great community around ELMAH have done something to fix this, by using the Elmah.Mvc NuGet package. We've built a package for ASP.NET MVC exclusively, which installs all the necessary packages. To start logging exceptions from ASP.NET MVC, install the Elmah.Io.Mvc NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Mvc dotnet add package Elmah.Io.Mvc <PackageReference Include=\"Elmah.Io.Mvc\" Version=\"3.*\" /> paket add Elmah.Io.Mvc During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). That's it. Every unhandled exception in ASP.NET MVC, is logged to elmah.io. As part of the installation, we also installed Elmah.MVC , which adds some interesting logic around routing and authentication. Take a look in the web.config for application settings with the elmah.mvc. prefix. For documentation about these settings, check out the Elmah.MVC project on GitHub. Since Elmah.MVC configures its own URL for accessing the ELMAH UI (just /elmah and not /elmah.axd ), you can remove the location element in web.config , added by the Elmah.Io.Mvc NuGet package installer.","title":"Logging from ASP.NET MVC"},{"location":"logging-to-elmah-io-from-aspnet-mvc/#logging-to-elmahio-from-aspnet-mvc","text":"Even though ELMAH works out of the box with ASP.NET MVC, ELMAH and MVC provides some features which interfere with one another. As usual, the great community around ELMAH have done something to fix this, by using the Elmah.Mvc NuGet package. We've built a package for ASP.NET MVC exclusively, which installs all the necessary packages. To start logging exceptions from ASP.NET MVC, install the Elmah.Io.Mvc NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Mvc dotnet add package Elmah.Io.Mvc <PackageReference Include=\"Elmah.Io.Mvc\" Version=\"3.*\" /> paket add Elmah.Io.Mvc During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). That's it. Every unhandled exception in ASP.NET MVC, is logged to elmah.io. As part of the installation, we also installed Elmah.MVC , which adds some interesting logic around routing and authentication. Take a look in the web.config for application settings with the elmah.mvc. prefix. For documentation about these settings, check out the Elmah.MVC project on GitHub. Since Elmah.MVC configures its own URL for accessing the ELMAH UI (just /elmah and not /elmah.axd ), you can remove the location element in web.config , added by the Elmah.Io.Mvc NuGet package installer.","title":"Logging to elmah.io from ASP.NET MVC"},{"location":"logging-to-elmah-io-from-aws-beanstalk/","text":"Logging from AWS Beanstalk Logging from AWS Beanstalk ASP.NET / MVC / Web API ASP.NET Core Logging to elmah.io from .NET applications deployed on AWS Beanstalk is as easy as with other cloud hosting services. Since Beanstalk runs normal ASP.NET, MVC, Web API, and Core applications, setting up elmah.io almost follows the guides already available in the elmah.io documentation. There are a few things to notice when needing to configure elmah.io, which will be explained in this document. ASP.NET / MVC / Web API To install elmah.io in ASP.NET , MVC , and/or Web API , please follow the guidelines for each framework. You can specify one set of API key and log ID in the Web.config file and another set in the Web.release.config file as explained here: Use multiple logs for different environments . If you want to include your production API key and log ID on AWS only (to avoid having sensitive information in source control), you can do this using Environment properties on AWS. Go to your environment on the AWS console and click the Configuration tab. In the bottom, you will see a section named Environment properties . Input your API key and log ID there: AWS inserts the properties as application settings in the Web.config file. To make sure that elmah.io uses API key and log ID from appSettings , change the <elmah> element to reference the keys specified on AWS: <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKeyKey=\"elmahio-apikey\" logIdKey=\"elmahio-logid\" /> The apiKeyKey and logIdKey attributes reference the app settings keys. Finally, if you have an API key and/or log ID specified as part of the appSettings> element in Web.config , you will need to remove those when running in production. The reason for this is that AWS only insert missing keys. To do so, modify your Web.release.config file: <appSettings> <add key=\"elmahio-logid\" xdt:Transform=\"Remove\" xdt:Locator=\"Match(key)\" /> <add key=\"elmahio-apikey\" xdt:Transform=\"Remove\" xdt:Locator=\"Match(key)\" /> </appSettings> ASP.NET Core To install elmah.io in ASP.NET Core, follow this guide: Logging to elmah.io from ASP.NET Core . Unfortunately, Beanstalk configuration doesn't play well with the configuration system in .NET Core. From the Beanstalk documentation: Elastic Beanstalk doesn't support passing environment variables to .NET Core applications and multiple-application IIS deployments that use a deployment manifest. For now, you will need to hardcode your API key and log ID in the Startup.cs file or add it to your appsettings.json file. Both approaches are explained in the documentation for installing elmah.io in ASP.NET Core.","title":"Logging from AWS Beanstalk"},{"location":"logging-to-elmah-io-from-aws-beanstalk/#logging-from-aws-beanstalk","text":"Logging from AWS Beanstalk ASP.NET / MVC / Web API ASP.NET Core Logging to elmah.io from .NET applications deployed on AWS Beanstalk is as easy as with other cloud hosting services. Since Beanstalk runs normal ASP.NET, MVC, Web API, and Core applications, setting up elmah.io almost follows the guides already available in the elmah.io documentation. There are a few things to notice when needing to configure elmah.io, which will be explained in this document.","title":"Logging from AWS Beanstalk"},{"location":"logging-to-elmah-io-from-aws-beanstalk/#aspnet-mvc-web-api","text":"To install elmah.io in ASP.NET , MVC , and/or Web API , please follow the guidelines for each framework. You can specify one set of API key and log ID in the Web.config file and another set in the Web.release.config file as explained here: Use multiple logs for different environments . If you want to include your production API key and log ID on AWS only (to avoid having sensitive information in source control), you can do this using Environment properties on AWS. Go to your environment on the AWS console and click the Configuration tab. In the bottom, you will see a section named Environment properties . Input your API key and log ID there: AWS inserts the properties as application settings in the Web.config file. To make sure that elmah.io uses API key and log ID from appSettings , change the <elmah> element to reference the keys specified on AWS: <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKeyKey=\"elmahio-apikey\" logIdKey=\"elmahio-logid\" /> The apiKeyKey and logIdKey attributes reference the app settings keys. Finally, if you have an API key and/or log ID specified as part of the appSettings> element in Web.config , you will need to remove those when running in production. The reason for this is that AWS only insert missing keys. To do so, modify your Web.release.config file: <appSettings> <add key=\"elmahio-logid\" xdt:Transform=\"Remove\" xdt:Locator=\"Match(key)\" /> <add key=\"elmahio-apikey\" xdt:Transform=\"Remove\" xdt:Locator=\"Match(key)\" /> </appSettings>","title":"ASP.NET / MVC / Web API"},{"location":"logging-to-elmah-io-from-aws-beanstalk/#aspnet-core","text":"To install elmah.io in ASP.NET Core, follow this guide: Logging to elmah.io from ASP.NET Core . Unfortunately, Beanstalk configuration doesn't play well with the configuration system in .NET Core. From the Beanstalk documentation: Elastic Beanstalk doesn't support passing environment variables to .NET Core applications and multiple-application IIS deployments that use a deployment manifest. For now, you will need to hardcode your API key and log ID in the Startup.cs file or add it to your appsettings.json file. Both approaches are explained in the documentation for installing elmah.io in ASP.NET Core.","title":"ASP.NET Core"},{"location":"logging-to-elmah-io-from-aws-lambdas/","text":"Logging from AWS Lambdas Since AWS now supports .NET Core, logging to elmah.io from a lambda is easy. Logging to elmah.io from AWS Serverless Application AWS Serverless Applications are running on ASP.NET Core. The configuration therefore matches our documentation for ASP.NET Core. Check out Logging from ASP.NET Core for details on how to log all uncaught exceptions from an AWS Serverless Application. The .NET SDK for AWS comes with native support for logging to CloudWatch. We recommend to use Microsoft.Extensions.Logging for logging everything to CloudWatch and warnings and errors to elmah.io. The configuration follows that of Logging from Microsoft.Extensions.Logging . AWS Serverless Applications doesn't have a Program.cs file. To configure logging, you will need to modify either LambdaEntryPoint.cs , LocalEntryPoint.cs or both: public class LambdaEntryPoint : Amazon.Lambda.AspNetCoreServer.APIGatewayProxyFunction { protected override void Init(IWebHostBuilder builder) { builder .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); }); } } The same configuration would go into LocalEntryPoint.cs , if you want to log from localhost as well. Logging from AWS Lambda Project AWS Lambda Project comes with native support for CloudWatch too. In our experience, it's not possible to configure multiple destinations on LambdaLogger , why you would want to use another framework when logging to elmah.io from an AWS Lambda Project. We recommend using a logging framework like Serilog , Microsoft.Extensions.Logging , NLog or log4net .","title":"Logging from AWS Lambdas"},{"location":"logging-to-elmah-io-from-aws-lambdas/#logging-from-aws-lambdas","text":"Since AWS now supports .NET Core, logging to elmah.io from a lambda is easy.","title":"Logging from AWS Lambdas"},{"location":"logging-to-elmah-io-from-aws-lambdas/#logging-to-elmahio-from-aws-serverless-application","text":"AWS Serverless Applications are running on ASP.NET Core. The configuration therefore matches our documentation for ASP.NET Core. Check out Logging from ASP.NET Core for details on how to log all uncaught exceptions from an AWS Serverless Application. The .NET SDK for AWS comes with native support for logging to CloudWatch. We recommend to use Microsoft.Extensions.Logging for logging everything to CloudWatch and warnings and errors to elmah.io. The configuration follows that of Logging from Microsoft.Extensions.Logging . AWS Serverless Applications doesn't have a Program.cs file. To configure logging, you will need to modify either LambdaEntryPoint.cs , LocalEntryPoint.cs or both: public class LambdaEntryPoint : Amazon.Lambda.AspNetCoreServer.APIGatewayProxyFunction { protected override void Init(IWebHostBuilder builder) { builder .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); }); } } The same configuration would go into LocalEntryPoint.cs , if you want to log from localhost as well.","title":"Logging to elmah.io from AWS Serverless Application"},{"location":"logging-to-elmah-io-from-aws-lambdas/#logging-from-aws-lambda-project","text":"AWS Lambda Project comes with native support for CloudWatch too. In our experience, it's not possible to configure multiple destinations on LambdaLogger , why you would want to use another framework when logging to elmah.io from an AWS Lambda Project. We recommend using a logging framework like Serilog , Microsoft.Extensions.Logging , NLog or log4net .","title":"Logging from AWS Lambda Project"},{"location":"logging-to-elmah-io-from-azure-functions/","text":"Logging to elmah.io from Azure Functions Logging to elmah.io from Azure Functions Application name Message hooks Decorating log messages Handle errors Error filtering Logging through ILogger Azure Functions v1 Logging errors from Azure Functions , requires only a few lines of code. We've created a client specifically for Azure Functions. Install the newest Elmah.Io.Functions package in your Azure Functions project: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Functions dotnet add package Elmah.Io.Functions <PackageReference Include=\"Elmah.Io.Functions\" Version=\"3.*\" /> paket add Elmah.Io.Functions The elmah.io integration for Azure Functions uses function filters and dependency injection part of the Microsoft.Azure.Functions.Extensions package. To configure elmah.io, open the Startup.cs file or create a new one if not already there. In the Configure -method, add the elmah.io options and exception filter: using Elmah.Io.Functions; using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using System; [assembly: FunctionsStartup(typeof(MyFunction.Startup))] namespace MyFunction { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); }); builder.Services.AddSingleton<IFunctionFilter, ElmahIoExceptionFilter>(); } } } Notice how API key and log ID are configured through the ElmahIoFunctionOptions object. In the last line of the Configure -method, the ElmahIoExceptionFilter -filter is configured. This filter will automatically catch any exception caused by your filter and log it to elmah.io. A quick comment about the obsolete warning showed when using the package. Microsoft marked IFunctionFilter as obsolete. Not because it will be removed, but because they may change the way attributes work in functions in the future. For now, you can suppress this warning with the following code: #pragma warning disable CS0618 // Type or member is obsolete builder.Services.AddSingleton<IFunctionFilter, ElmahIoExceptionFilter>(); #pragma warning restore CS0618 // Type or member is obsolete In your settings, add the apiKey and logId variables: { // ... \"Values\": { // ... \"apiKey\": \"API_KEY\", \"logId\": \"LOG_ID\" } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with your log ID. When running on Azure or similar, you can overwrite apiKey and logId with application settings or environment variables as already thoroughly documented on Microsoft's documentation. Application name To set the application name on all errors, set the Application property during initialization: builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.Application = \"MyFunction\"; }); Message hooks Elmah.Io.Functions provide message hooks similar to the integrations with ASP.NET and ASP.NET Core. Decorating log messages To include additional information on log messages, you can use the OnMessage event when initializing ElmahIoFunctionOptions : builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.OnMessage = msg => { msg.Version = \"1.0.0\"; }; }); The example above includes a version number on all errors. Handle errors To handle any errors happening while processing a log message, you can use the OnError event when initializing ElmahIoFunctionOptions : builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.OnError = (msg, ex) => { logger.LogError(ex, ex.Message); }; }); The example above logs any errors during communication with elmah.io to a local log. Error filtering To ignore specific errors based on their content, you can use the OnFilter event when initializing ElmahIoFunctionOptions : builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.OnFilter = msg => { return msg.Method == \"GET\"; }; }); The example above ignores any errors generated during an HTTP GET request. Logging through ILogger Azure Functions can log through Microsoft.Extensions.Logging (MEL) too. By adding the filter, as shown above, all uncaught exceptions are automatically logged. But when configuring your Function app to log through MEL, custom messages can be logged through the ILogger interface. Furthermore, you will get detailed log messages from within the Function host. To set this up, install the Elmah.Io.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging Then extend your Startup.cs file like this: builder.Services.AddLogging(logging => { logging.AddElmahIo(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); }); In the example, only warning messages and above are logged to elmah.io. You can remove the filter or set another log level if you want to log more. Either pass an ILogger to your function method: public class MyFunction { public static void Run([TimerTrigger(\"...\")]TimerInfo myTimer, ILogger log) { log.LogWarning(\"This is a warning\"); } } Or inject an ILoggerFactory and create a logger as part of the constructor: public class MyFunction { private readonly ILogger log; public Function1(ILoggerFactory loggerFactory) { this.log = loggerFactory.CreateLogger(\"MyFunction\"); } public void Run([TimerTrigger(\"...\")]TimerInfo myTimer) { log.LogWarning(\"This is a warning\"); } } Azure Functions v1 The recent Elmah.Io.Functions package no longer supports Azure Functions v1. You can still log from Functions v1 using an older version of the package. Check out Logging to elmah.io from Azure WebJobs for details. The guide is for Azure WebJobs but installation for Functions v1 is identical.","title":"Logging from Azure Functions"},{"location":"logging-to-elmah-io-from-azure-functions/#logging-to-elmahio-from-azure-functions","text":"Logging to elmah.io from Azure Functions Application name Message hooks Decorating log messages Handle errors Error filtering Logging through ILogger Azure Functions v1 Logging errors from Azure Functions , requires only a few lines of code. We've created a client specifically for Azure Functions. Install the newest Elmah.Io.Functions package in your Azure Functions project: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Functions dotnet add package Elmah.Io.Functions <PackageReference Include=\"Elmah.Io.Functions\" Version=\"3.*\" /> paket add Elmah.Io.Functions The elmah.io integration for Azure Functions uses function filters and dependency injection part of the Microsoft.Azure.Functions.Extensions package. To configure elmah.io, open the Startup.cs file or create a new one if not already there. In the Configure -method, add the elmah.io options and exception filter: using Elmah.Io.Functions; using Microsoft.Azure.Functions.Extensions.DependencyInjection; using Microsoft.Azure.WebJobs.Host; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using System; [assembly: FunctionsStartup(typeof(MyFunction.Startup))] namespace MyFunction { public class Startup : FunctionsStartup { public override void Configure(IFunctionsHostBuilder builder) { var config = new ConfigurationBuilder() .AddJsonFile(\"local.settings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables() .Build(); builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); }); builder.Services.AddSingleton<IFunctionFilter, ElmahIoExceptionFilter>(); } } } Notice how API key and log ID are configured through the ElmahIoFunctionOptions object. In the last line of the Configure -method, the ElmahIoExceptionFilter -filter is configured. This filter will automatically catch any exception caused by your filter and log it to elmah.io. A quick comment about the obsolete warning showed when using the package. Microsoft marked IFunctionFilter as obsolete. Not because it will be removed, but because they may change the way attributes work in functions in the future. For now, you can suppress this warning with the following code: #pragma warning disable CS0618 // Type or member is obsolete builder.Services.AddSingleton<IFunctionFilter, ElmahIoExceptionFilter>(); #pragma warning restore CS0618 // Type or member is obsolete In your settings, add the apiKey and logId variables: { // ... \"Values\": { // ... \"apiKey\": \"API_KEY\", \"logId\": \"LOG_ID\" } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with your log ID. When running on Azure or similar, you can overwrite apiKey and logId with application settings or environment variables as already thoroughly documented on Microsoft's documentation.","title":"Logging to elmah.io from Azure Functions"},{"location":"logging-to-elmah-io-from-azure-functions/#application-name","text":"To set the application name on all errors, set the Application property during initialization: builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.Application = \"MyFunction\"; });","title":"Application name"},{"location":"logging-to-elmah-io-from-azure-functions/#message-hooks","text":"Elmah.Io.Functions provide message hooks similar to the integrations with ASP.NET and ASP.NET Core.","title":"Message hooks"},{"location":"logging-to-elmah-io-from-azure-functions/#decorating-log-messages","text":"To include additional information on log messages, you can use the OnMessage event when initializing ElmahIoFunctionOptions : builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.OnMessage = msg => { msg.Version = \"1.0.0\"; }; }); The example above includes a version number on all errors.","title":"Decorating log messages"},{"location":"logging-to-elmah-io-from-azure-functions/#handle-errors","text":"To handle any errors happening while processing a log message, you can use the OnError event when initializing ElmahIoFunctionOptions : builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.OnError = (msg, ex) => { logger.LogError(ex, ex.Message); }; }); The example above logs any errors during communication with elmah.io to a local log.","title":"Handle errors"},{"location":"logging-to-elmah-io-from-azure-functions/#error-filtering","text":"To ignore specific errors based on their content, you can use the OnFilter event when initializing ElmahIoFunctionOptions : builder.Services.Configure<ElmahIoFunctionOptions>(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); o.OnFilter = msg => { return msg.Method == \"GET\"; }; }); The example above ignores any errors generated during an HTTP GET request.","title":"Error filtering"},{"location":"logging-to-elmah-io-from-azure-functions/#logging-through-ilogger","text":"Azure Functions can log through Microsoft.Extensions.Logging (MEL) too. By adding the filter, as shown above, all uncaught exceptions are automatically logged. But when configuring your Function app to log through MEL, custom messages can be logged through the ILogger interface. Furthermore, you will get detailed log messages from within the Function host. To set this up, install the Elmah.Io.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging Then extend your Startup.cs file like this: builder.Services.AddLogging(logging => { logging.AddElmahIo(o => { o.ApiKey = config[\"apiKey\"]; o.LogId = new Guid(config[\"logId\"]); }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); }); In the example, only warning messages and above are logged to elmah.io. You can remove the filter or set another log level if you want to log more. Either pass an ILogger to your function method: public class MyFunction { public static void Run([TimerTrigger(\"...\")]TimerInfo myTimer, ILogger log) { log.LogWarning(\"This is a warning\"); } } Or inject an ILoggerFactory and create a logger as part of the constructor: public class MyFunction { private readonly ILogger log; public Function1(ILoggerFactory loggerFactory) { this.log = loggerFactory.CreateLogger(\"MyFunction\"); } public void Run([TimerTrigger(\"...\")]TimerInfo myTimer) { log.LogWarning(\"This is a warning\"); } }","title":"Logging through ILogger"},{"location":"logging-to-elmah-io-from-azure-functions/#azure-functions-v1","text":"The recent Elmah.Io.Functions package no longer supports Azure Functions v1. You can still log from Functions v1 using an older version of the package. Check out Logging to elmah.io from Azure WebJobs for details. The guide is for Azure WebJobs but installation for Functions v1 is identical.","title":"Azure Functions v1"},{"location":"logging-to-elmah-io-from-azure-webjobs/","text":"Logging to elmah.io from Azure WebJobs Logging errors from Azure WebJobs , requires only a few lines of code. We've created a client specifically for Azure WebJobs. Support for Azure WebJobs have been stopped on version 3.1.23 of the Elmah.Io.Functions package. The newer versions only work with Azure Functions. Install the Elmah.Io.Functions package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Functions -Version 3.1.23 dotnet add package Elmah.Io.Functions --version 3.1.23 <PackageReference Include=\"Elmah.Io.Functions\" Version=\"3.1.23\" /> paket add Elmah.Io.Functions --version 3.1.23 Log all uncaught exceptions using the ElmahIoExceptionFilter attribute: [ElmahIoExceptionFilter(\"API_KEY\", \"LOG_ID\")] public class Functions { public static void ProcessQueueMessage([QueueTrigger(\"queue\")] string msg, TextWriter log) { throw new Exception(\"Some exception\"); } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with your log ID. If your WebJob method is declared as async, remember to change the return type to Task . Without it, ElmahIoExceptionFilter is never invoked. The filter also supports config variables: [ElmahIoExceptionFilter(\"%apiKey%\", \"%logId%\")] The variables above, would require you to add your API key and log ID to your App.config : <configuration> <appSettings> <add key=\"apiKey\" value=\"API_KEY\"/> <add key=\"logId\" value=\"LOG_ID\"/> </appSettings> </configuration>","title":"Logging from Azure WebJobs"},{"location":"logging-to-elmah-io-from-azure-webjobs/#logging-to-elmahio-from-azure-webjobs","text":"Logging errors from Azure WebJobs , requires only a few lines of code. We've created a client specifically for Azure WebJobs. Support for Azure WebJobs have been stopped on version 3.1.23 of the Elmah.Io.Functions package. The newer versions only work with Azure Functions. Install the Elmah.Io.Functions package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Functions -Version 3.1.23 dotnet add package Elmah.Io.Functions --version 3.1.23 <PackageReference Include=\"Elmah.Io.Functions\" Version=\"3.1.23\" /> paket add Elmah.Io.Functions --version 3.1.23 Log all uncaught exceptions using the ElmahIoExceptionFilter attribute: [ElmahIoExceptionFilter(\"API_KEY\", \"LOG_ID\")] public class Functions { public static void ProcessQueueMessage([QueueTrigger(\"queue\")] string msg, TextWriter log) { throw new Exception(\"Some exception\"); } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with your log ID. If your WebJob method is declared as async, remember to change the return type to Task . Without it, ElmahIoExceptionFilter is never invoked. The filter also supports config variables: [ElmahIoExceptionFilter(\"%apiKey%\", \"%logId%\")] The variables above, would require you to add your API key and log ID to your App.config : <configuration> <appSettings> <add key=\"apiKey\" value=\"API_KEY\"/> <add key=\"logId\" value=\"LOG_ID\"/> </appSettings> </configuration>","title":"Logging to elmah.io from Azure WebJobs"},{"location":"logging-to-elmah-io-from-blazor/","text":"Logging to elmah.io from Blazor Logging to elmah.io from Blazor Blazor Server App Blazor WebAssembly App (wasm) Blazor Server App To start logging to elmah.io from a Blazor Server App, install the Elmah.Io.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging In the Startup.cs file, add elmah.io logging configuration: using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Extensions.Logging; namespace MyBlazorApp { public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddLogging(builder => builder .AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); }) ); } // ... } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). All uncaught exceptions are automatically logged to elmah.io. Exceptions can be logged manually, by injecting an ILogger into your view and adding try/catch : @using Microsoft.Extensions.Logging @inject ILogger<FetchData> logger <!-- ... --> @functions { WeatherForecast[] forecasts; protected override async Task OnInitAsync() { try { forecasts = await Http.GetJsonAsync<WeatherForecast[]>(\"api/SampleData/WeatherForecasts-nonexisting\"); } catch (Exception e) { logger.LogError(e, e.Message); } } } Information and other severities can be logged as well: @using Microsoft.Extensions.Logging @inject ILogger<Counter> logger <!-- ... --> @functions { int currentCount = 0; void IncrementCount() { currentCount++; logger.LogInformation(\"Incremented count to {currentCount}\", currentCount); } } Blazor WebAssembly App (wasm) Please notice that the code for Blazor WebAssembly App is highly experimental. Logging to elmah.io from a Blazor WebAssembly App can be done by adding some code. While being \"production-ready\" according to Microsoft, Blazor WebAssembly Apps are still very limited in regards to using third-party libraries. All of our integrations log to elmah.io through the Elmah.Io.Client package. Neither Elmah.Io.Client or Elmah.Io.Extensions.Logging are allowed to run on the runtime provided by Blazor WebAssembly. For now, you can log to elmah.io by adding the following code to the Program.cs file: public class Program { public static async Task Main(string[] args) { // ... // If not already there make sure to include a HttpClient like this: builder.Services.AddTransient(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) }); // Set up logging builder.Logging.SetMinimumLevel(LogLevel.Warning); builder.Services.AddSingleton<ILoggerProvider, ElmahIoLoggerProvider>(services => { var httpClient = services.GetService<HttpClient>(); return new ElmahIoLoggerProvider(httpClient); }); // ... } private class ElmahIoLoggerProvider : ILoggerProvider { private readonly HttpClient httpClient; public ElmahIoLoggerProvider(HttpClient httpClient) { this.httpClient = httpClient; } public ILogger CreateLogger(string categoryName) { return new ElmahIoLogger(httpClient); } public void Dispose() { } } private class ElmahIoLogger : ILogger { private readonly HttpClient httpClient; public ElmahIoLogger(HttpClient httpClient) { this.httpClient = httpClient; } public IDisposable BeginScope<TState>(TState state) { return null; } public bool IsEnabled(LogLevel logLevel) { return true; } public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter) { httpClient.PostAsJsonAsync( \"https://api.elmah.io/v3/messages/LOG_ID?api_key=API_KEY\", new { title = formatter(state, exception), dateTime = DateTime.UtcNow, severity = LogLevelToSeverity(logLevel), source = exception?.GetBaseException().Source, hostname = Environment.MachineName, type = exception?.GetBaseException().GetType().FullName, }); } private string LogLevelToSeverity(LogLevel logLevel) { switch (logLevel) { case LogLevel.Critical: return \"Fatal\"; case LogLevel.Debug: return \"Debug\"; case LogLevel.Error: return \"Error\"; case LogLevel.Information: return \"Information\"; case LogLevel.Trace: return \"Verbose\"; case LogLevel.Warning: return \"Warning\"; default: return \"Information\"; } } } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). The code uses HttpClient to call the elmah.io API directly. This implementation is provided as code to copy, to make it clear that this is not a polished package yet. When Blazor WebAssembly Apps mature, we will decide if we want to release an official package for Blazor or utilize some of the existing packages. There's a couple of disadvantages with the code above that you need to consider before copying: A lot of information about the HTTP context is missing (like cookies, URL, and user). There's a lot of code lines compared to the usual elmah.io integration where you install a NuGet package. The Log method calls an async method without await . No internal message queue and/or batch processing like Microsoft.Extensions.Logging . No support for logging scopes.","title":"Logging from Blazor"},{"location":"logging-to-elmah-io-from-blazor/#logging-to-elmahio-from-blazor","text":"Logging to elmah.io from Blazor Blazor Server App Blazor WebAssembly App (wasm)","title":"Logging to elmah.io from Blazor"},{"location":"logging-to-elmah-io-from-blazor/#blazor-server-app","text":"To start logging to elmah.io from a Blazor Server App, install the Elmah.Io.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging In the Startup.cs file, add elmah.io logging configuration: using Microsoft.Extensions.DependencyInjection; using Elmah.Io.Extensions.Logging; namespace MyBlazorApp { public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddLogging(builder => builder .AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); }) ); } // ... } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). All uncaught exceptions are automatically logged to elmah.io. Exceptions can be logged manually, by injecting an ILogger into your view and adding try/catch : @using Microsoft.Extensions.Logging @inject ILogger<FetchData> logger <!-- ... --> @functions { WeatherForecast[] forecasts; protected override async Task OnInitAsync() { try { forecasts = await Http.GetJsonAsync<WeatherForecast[]>(\"api/SampleData/WeatherForecasts-nonexisting\"); } catch (Exception e) { logger.LogError(e, e.Message); } } } Information and other severities can be logged as well: @using Microsoft.Extensions.Logging @inject ILogger<Counter> logger <!-- ... --> @functions { int currentCount = 0; void IncrementCount() { currentCount++; logger.LogInformation(\"Incremented count to {currentCount}\", currentCount); } }","title":"Blazor Server App"},{"location":"logging-to-elmah-io-from-blazor/#blazor-webassembly-app-wasm","text":"Please notice that the code for Blazor WebAssembly App is highly experimental. Logging to elmah.io from a Blazor WebAssembly App can be done by adding some code. While being \"production-ready\" according to Microsoft, Blazor WebAssembly Apps are still very limited in regards to using third-party libraries. All of our integrations log to elmah.io through the Elmah.Io.Client package. Neither Elmah.Io.Client or Elmah.Io.Extensions.Logging are allowed to run on the runtime provided by Blazor WebAssembly. For now, you can log to elmah.io by adding the following code to the Program.cs file: public class Program { public static async Task Main(string[] args) { // ... // If not already there make sure to include a HttpClient like this: builder.Services.AddTransient(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) }); // Set up logging builder.Logging.SetMinimumLevel(LogLevel.Warning); builder.Services.AddSingleton<ILoggerProvider, ElmahIoLoggerProvider>(services => { var httpClient = services.GetService<HttpClient>(); return new ElmahIoLoggerProvider(httpClient); }); // ... } private class ElmahIoLoggerProvider : ILoggerProvider { private readonly HttpClient httpClient; public ElmahIoLoggerProvider(HttpClient httpClient) { this.httpClient = httpClient; } public ILogger CreateLogger(string categoryName) { return new ElmahIoLogger(httpClient); } public void Dispose() { } } private class ElmahIoLogger : ILogger { private readonly HttpClient httpClient; public ElmahIoLogger(HttpClient httpClient) { this.httpClient = httpClient; } public IDisposable BeginScope<TState>(TState state) { return null; } public bool IsEnabled(LogLevel logLevel) { return true; } public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter) { httpClient.PostAsJsonAsync( \"https://api.elmah.io/v3/messages/LOG_ID?api_key=API_KEY\", new { title = formatter(state, exception), dateTime = DateTime.UtcNow, severity = LogLevelToSeverity(logLevel), source = exception?.GetBaseException().Source, hostname = Environment.MachineName, type = exception?.GetBaseException().GetType().FullName, }); } private string LogLevelToSeverity(LogLevel logLevel) { switch (logLevel) { case LogLevel.Critical: return \"Fatal\"; case LogLevel.Debug: return \"Debug\"; case LogLevel.Error: return \"Error\"; case LogLevel.Information: return \"Information\"; case LogLevel.Trace: return \"Verbose\"; case LogLevel.Warning: return \"Warning\"; default: return \"Information\"; } } } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). The code uses HttpClient to call the elmah.io API directly. This implementation is provided as code to copy, to make it clear that this is not a polished package yet. When Blazor WebAssembly Apps mature, we will decide if we want to release an official package for Blazor or utilize some of the existing packages. There's a couple of disadvantages with the code above that you need to consider before copying: A lot of information about the HTTP context is missing (like cookies, URL, and user). There's a lot of code lines compared to the usual elmah.io integration where you install a NuGet package. The Log method calls an async method without await . No internal message queue and/or batch processing like Microsoft.Extensions.Logging . No support for logging scopes.","title":"Blazor WebAssembly App (wasm)"},{"location":"logging-to-elmah-io-from-blogengine-net/","text":"Logging to elmah.io from BlogEngine.NET Because BlogEngine.NET is written in ASP.NET, it doesn\u2019t really need any custom code to use ELMAH and elmah.io. In fact, ELMAH works out of the box for most web frameworks by Microsoft. If you are building and deploying the code yourself, installing elmah.io is achieved using our NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). When installed, BlogEngine.NET starts reporting errors to elmah.io. To check it out, force an internal server error or similar, and visit /elmah.axd or the search area of your log at elmah.io. Some of you may use the BlogEngine.NET binaries or even installed it using a one-click installer. In this case you will need to add elmah.io manually. To do that, use a tool like NuGet Package Explorer to download the most recent versions of ELMAH and elmah.io. Copy Elmah.dll and Elmah.Io.dll to the bin directory of your BlogEngine.NET installation. Also modify your web.config to include the ELMAH config as shown in the config example. Last but not least, remember to add the elmah.io error logger configuration as a child node to the <elmah> element: <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> Where API_KEY is your API key and LOG_ID is your log ID. To wrap this up, you may have noticed that there\u2019s a NuGet package to bring ELMAH support into BlogEngine.NET. This package adds the ELMAH assembly and config as well as adds a nice BlogEngine.NET compliant URL for browsing errors. Feel free to use this package, but remember to add it after the elmah.io package. Also, make sure to clean up the dual error log configuration: <elmah> <security allowRemoteAccess=\"false\" /> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"APIKEY\" logId=\"LOGID\" /> <security allowRemoteAccess=\"true\" /> <errorLog type=\"Elmah.SqlServerCompactErrorLog, Elmah\" connectionStringName=\"elmah-sqlservercompact\" /> </elmah>","title":"Logging from BlogEngine.NET"},{"location":"logging-to-elmah-io-from-blogengine-net/#logging-to-elmahio-from-blogenginenet","text":"Because BlogEngine.NET is written in ASP.NET, it doesn\u2019t really need any custom code to use ELMAH and elmah.io. In fact, ELMAH works out of the box for most web frameworks by Microsoft. If you are building and deploying the code yourself, installing elmah.io is achieved using our NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). When installed, BlogEngine.NET starts reporting errors to elmah.io. To check it out, force an internal server error or similar, and visit /elmah.axd or the search area of your log at elmah.io. Some of you may use the BlogEngine.NET binaries or even installed it using a one-click installer. In this case you will need to add elmah.io manually. To do that, use a tool like NuGet Package Explorer to download the most recent versions of ELMAH and elmah.io. Copy Elmah.dll and Elmah.Io.dll to the bin directory of your BlogEngine.NET installation. Also modify your web.config to include the ELMAH config as shown in the config example. Last but not least, remember to add the elmah.io error logger configuration as a child node to the <elmah> element: <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> Where API_KEY is your API key and LOG_ID is your log ID. To wrap this up, you may have noticed that there\u2019s a NuGet package to bring ELMAH support into BlogEngine.NET. This package adds the ELMAH assembly and config as well as adds a nice BlogEngine.NET compliant URL for browsing errors. Feel free to use this package, but remember to add it after the elmah.io package. Also, make sure to clean up the dual error log configuration: <elmah> <security allowRemoteAccess=\"false\" /> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"APIKEY\" logId=\"LOGID\" /> <security allowRemoteAccess=\"true\" /> <errorLog type=\"Elmah.SqlServerCompactErrorLog, Elmah\" connectionStringName=\"elmah-sqlservercompact\" /> </elmah>","title":"Logging to elmah.io from BlogEngine.NET"},{"location":"logging-to-elmah-io-from-console-application/","text":"Logging to elmah.io from Console Logging to elmah.io from Console Events OnMessage OnMessageFail Bulk upload Options Proxy Opfuscate form values Even though elmah.io support various logging frameworks like Serilog , log4net , and NLog , logging from a simple console application is dead simple. To start logging, install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Create a new ElmahioAPI : var logger = ElmahioAPI.Create(\"API_KEY\"); Replace API_KEY with your API key ( Where is my API key? ). The elmah.io client supports logging in different log levels much like other logging frameworks for .NET: var logId = new Guid(\"LOG_ID\"); logger.Messages.Fatal(logId, new ApplicationException(\"A fatal exception\"), \"Fatal message\"); logger.Messages.Error(logId, new ApplicationException(\"An exception\"), \"Error message\"); logger.Messages.Warning(logId, \"A warning\"); logger.Messages.Information(logId, \"An info message\"); logger.Messages.Debug(logId, \"A debug message\"); logger.Messages.Verbose(logId, \"A verbose message\"); Replace LOG_ID with your log ID from elmah.io ( Where is my log ID? ). To have 100% control of how the message is logged to elmah.io, you can use the CreateAndNotify -method: logger.Messages.CreateAndNotify(logId, new CreateMessage { Title = \"Hello World\", Application = \"Elmah.Io.Client sample\", Detail = \"This is a long description of the error. Maybe even a stacktrace\", Severity = Severity.Error.ToString(), Data = new List<Item> { new Item {Key = \"Username\", Value = \"Man in black\"} }, Form = new List<Item> { new Item {Key = \"Password\", Value = \"SecretPassword\"}, new Item {Key = \"pwd\", Value = \"Other secret value\"}, new Item {Key = \"visible form item\", Value = \"With a value\"} } }); Like the integrations for Serilog, NLog and, Microsoft.Extensions.Logging, the elmah.io client supports structured logging: logger.Messages.CreateAndNotify(logId, new CreateMessage { Title = \"Thomas says Hello\", TitleTemplate = \"{User} says Hello\", }); Events The elmah.io client supports to different events: OnMessage and OnMessageFail . OnMessage To get a callback every time a new message is being logged to elmah.io, you can implement the OnMessage event. This is a great chance to decorate all log messages with a specific property or similar. logger.Messages.OnMessage += (sender, eventArgs) => { eventArgs.Message.Version = \"1.0.0\"; }; OnMessageFail Logging to elmah.io can fail if the network connection is down, if elmah.io experience downtime, or something third. To make sure you log an error elsewhere if this happen, you can implement the OnMessageFail event: logger.Messages.OnMessageFail += (sender, eventArgs) => { System.Console.Error.WriteLine(\"Error when logging to elmah.io\"); }; Bulk upload If logging many messages to elmah.io, bulk upload can be a way to optimize performance. The elmah.io client supports bulk upload using the CreateBulkAndNotify -method: logger.Messages.CreateBulkAndNotify(logId, new[] { new CreateMessage { Title = \"This is a bulk message\" }, new CreateMessage { Title = \"This is another bulk message\" }, }.ToList()); Options The elmah.io client contains a set of default options that you can override. Proxy To log through a HTTP proxy, set the WebProxy property: var logger = ElmahioAPI.Create(\"API_KEY\"); logger.Options.WebProxy = new WebProxy(\"localhost\", 8888); Opfuscate form values When logging POSTs with form values, you don't want users password and similar logged to elmah.io. The elmah.io client automatically filter form keys named password and pwd . Using the FormKeysToObfuscate you can tell the client to opfuscate additional form entries: var logger = ElmahioAPI.Create(\"API_KEY\"); logger.Options.FormKeysToObfuscate.Add(\"secret_key\");","title":"Logging from Console"},{"location":"logging-to-elmah-io-from-console-application/#logging-to-elmahio-from-console","text":"Logging to elmah.io from Console Events OnMessage OnMessageFail Bulk upload Options Proxy Opfuscate form values Even though elmah.io support various logging frameworks like Serilog , log4net , and NLog , logging from a simple console application is dead simple. To start logging, install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Create a new ElmahioAPI : var logger = ElmahioAPI.Create(\"API_KEY\"); Replace API_KEY with your API key ( Where is my API key? ). The elmah.io client supports logging in different log levels much like other logging frameworks for .NET: var logId = new Guid(\"LOG_ID\"); logger.Messages.Fatal(logId, new ApplicationException(\"A fatal exception\"), \"Fatal message\"); logger.Messages.Error(logId, new ApplicationException(\"An exception\"), \"Error message\"); logger.Messages.Warning(logId, \"A warning\"); logger.Messages.Information(logId, \"An info message\"); logger.Messages.Debug(logId, \"A debug message\"); logger.Messages.Verbose(logId, \"A verbose message\"); Replace LOG_ID with your log ID from elmah.io ( Where is my log ID? ). To have 100% control of how the message is logged to elmah.io, you can use the CreateAndNotify -method: logger.Messages.CreateAndNotify(logId, new CreateMessage { Title = \"Hello World\", Application = \"Elmah.Io.Client sample\", Detail = \"This is a long description of the error. Maybe even a stacktrace\", Severity = Severity.Error.ToString(), Data = new List<Item> { new Item {Key = \"Username\", Value = \"Man in black\"} }, Form = new List<Item> { new Item {Key = \"Password\", Value = \"SecretPassword\"}, new Item {Key = \"pwd\", Value = \"Other secret value\"}, new Item {Key = \"visible form item\", Value = \"With a value\"} } }); Like the integrations for Serilog, NLog and, Microsoft.Extensions.Logging, the elmah.io client supports structured logging: logger.Messages.CreateAndNotify(logId, new CreateMessage { Title = \"Thomas says Hello\", TitleTemplate = \"{User} says Hello\", });","title":"Logging to elmah.io from Console"},{"location":"logging-to-elmah-io-from-console-application/#events","text":"The elmah.io client supports to different events: OnMessage and OnMessageFail .","title":"Events"},{"location":"logging-to-elmah-io-from-console-application/#onmessage","text":"To get a callback every time a new message is being logged to elmah.io, you can implement the OnMessage event. This is a great chance to decorate all log messages with a specific property or similar. logger.Messages.OnMessage += (sender, eventArgs) => { eventArgs.Message.Version = \"1.0.0\"; };","title":"OnMessage"},{"location":"logging-to-elmah-io-from-console-application/#onmessagefail","text":"Logging to elmah.io can fail if the network connection is down, if elmah.io experience downtime, or something third. To make sure you log an error elsewhere if this happen, you can implement the OnMessageFail event: logger.Messages.OnMessageFail += (sender, eventArgs) => { System.Console.Error.WriteLine(\"Error when logging to elmah.io\"); };","title":"OnMessageFail"},{"location":"logging-to-elmah-io-from-console-application/#bulk-upload","text":"If logging many messages to elmah.io, bulk upload can be a way to optimize performance. The elmah.io client supports bulk upload using the CreateBulkAndNotify -method: logger.Messages.CreateBulkAndNotify(logId, new[] { new CreateMessage { Title = \"This is a bulk message\" }, new CreateMessage { Title = \"This is another bulk message\" }, }.ToList());","title":"Bulk upload"},{"location":"logging-to-elmah-io-from-console-application/#options","text":"The elmah.io client contains a set of default options that you can override.","title":"Options"},{"location":"logging-to-elmah-io-from-console-application/#proxy","text":"To log through a HTTP proxy, set the WebProxy property: var logger = ElmahioAPI.Create(\"API_KEY\"); logger.Options.WebProxy = new WebProxy(\"localhost\", 8888);","title":"Proxy"},{"location":"logging-to-elmah-io-from-console-application/#opfuscate-form-values","text":"When logging POSTs with form values, you don't want users password and similar logged to elmah.io. The elmah.io client automatically filter form keys named password and pwd . Using the FormKeysToObfuscate you can tell the client to opfuscate additional form entries: var logger = ElmahioAPI.Create(\"API_KEY\"); logger.Options.FormKeysToObfuscate.Add(\"secret_key\");","title":"Opfuscate form values"},{"location":"logging-to-elmah-io-from-devexpress/","text":"Logging to elmah.io from DevExpress (eXpressApp Framework) eXpressApp Framework (XAF) is built on top of ASP.NET. Installing elmah.io corresponds any other ASP.NET site: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). To verify the integration, throw a new exception in Default.aspx or similar: <body class=\"VerticalTemplate\"> <% throw new Exception(\"Test exception\"); %> <form id=\"form2\" runat=\"server\"> <!-- ... --> </form> </body> Launch the project and see the test exception flow into elmah.io.","title":"Logging from DevExpress (eXpressApp Framework)"},{"location":"logging-to-elmah-io-from-devexpress/#logging-to-elmahio-from-devexpress-expressapp-framework","text":"eXpressApp Framework (XAF) is built on top of ASP.NET. Installing elmah.io corresponds any other ASP.NET site: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). To verify the integration, throw a new exception in Default.aspx or similar: <body class=\"VerticalTemplate\"> <% throw new Exception(\"Test exception\"); %> <form id=\"form2\" runat=\"server\"> <!-- ... --> </form> </body> Launch the project and see the test exception flow into elmah.io.","title":"Logging to elmah.io from DevExpress (eXpressApp Framework)"},{"location":"logging-to-elmah-io-from-elmah/","text":"Logging to elmah.io from ASP.NET / WebForms This article will explain the steps necessary to log errors from your web application into elmah.io. We also offer more specific guides on ASP.NET MVC , Web API , and a lot of other web- and logging-frameworks. Read through this tutorial and head over to a tutorial specific for your choice of framework afterwards. This guide is also available as a short video tutorial here: Create a new ASP.NET Web Application in Visual Studio : Select a project template of your choice: Navigate to elmah.io and login using username/password or your favorite social provider. When logged in, elmah.io redirects you to the dashboard. If you just signed up, you will be guided through the process of creating an organization and a log. When the log has been created, elmah.io shows you the install instructions. If you are currently on the dashboard, click the gears icon on the lower right corner of the log box. Don't pay too much attention to the install steps, because the rest of this tutorial will guide you through the installation. Keep the page open in order to copy your API key and log ID at a later step: Navigate back to your web project, right click References and select Manage NuGet Packages : In the NuGet dialog, search for elmah.io: Select the elmah.io package and click Install . Input your API key and log ID in the dialog appearing during installation of the NuGet package: You\u2019re ready to rock and roll. Hit F5 and input a URL you know doesn\u2019t exist (like http://localhost:64987/notfound). You should see the standard 404 message displayed in the browser. To verify that the installation of elmah.io is successful, navigate back to the elmah.io dashboard and select the Search tab of your newly created log: See the notfound error? Congrats! Every error on your application is now logged to elmah.io.","title":"Logging from WebForms"},{"location":"logging-to-elmah-io-from-elmah/#logging-to-elmahio-from-aspnet-webforms","text":"This article will explain the steps necessary to log errors from your web application into elmah.io. We also offer more specific guides on ASP.NET MVC , Web API , and a lot of other web- and logging-frameworks. Read through this tutorial and head over to a tutorial specific for your choice of framework afterwards. This guide is also available as a short video tutorial here: Create a new ASP.NET Web Application in Visual Studio : Select a project template of your choice: Navigate to elmah.io and login using username/password or your favorite social provider. When logged in, elmah.io redirects you to the dashboard. If you just signed up, you will be guided through the process of creating an organization and a log. When the log has been created, elmah.io shows you the install instructions. If you are currently on the dashboard, click the gears icon on the lower right corner of the log box. Don't pay too much attention to the install steps, because the rest of this tutorial will guide you through the installation. Keep the page open in order to copy your API key and log ID at a later step: Navigate back to your web project, right click References and select Manage NuGet Packages : In the NuGet dialog, search for elmah.io: Select the elmah.io package and click Install . Input your API key and log ID in the dialog appearing during installation of the NuGet package: You\u2019re ready to rock and roll. Hit F5 and input a URL you know doesn\u2019t exist (like http://localhost:64987/notfound). You should see the standard 404 message displayed in the browser. To verify that the installation of elmah.io is successful, navigate back to the elmah.io dashboard and select the Search tab of your newly created log: See the notfound error? Congrats! Every error on your application is now logged to elmah.io.","title":"Logging to elmah.io from ASP.NET / WebForms"},{"location":"logging-to-elmah-io-from-entity-framework-core/","text":"Logging to elmah.io from Entity Framework Core Both elmah.io and Entity Framework Core supports logging through Microsoft.Extensions.Logging. To log all errors happening inside Entity Framework Core, install the Elmah.Io.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging Then add elmah.io to a new or existing LoggerFactory : var loggerFactory = new LoggerFactory() .AddElmahIo(\"API_KEY\", new Guid(\"LOG_ID\")); Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the log ID ( Where is my log ID? ) that should receive errors from Entity Framework. When using Entity Framework Core from ASP.NET Core, you never create your own LoggerFactory . Factories are provided through DI by ASP.NET Core. Check out this sample for details. Finally, enable logging in Entity Framework Core: optionsBuilder .UseLoggerFactory(loggerFactory) .UseSqlServer(/*...*/); ( UseSqlServer included for illustration purposes only - elmah.io works with any provider) That's it! All errors happening in Entity Framework Core, are now logged in elmah.io.","title":"Logging from Entity Framework Core"},{"location":"logging-to-elmah-io-from-entity-framework-core/#logging-to-elmahio-from-entity-framework-core","text":"Both elmah.io and Entity Framework Core supports logging through Microsoft.Extensions.Logging. To log all errors happening inside Entity Framework Core, install the Elmah.Io.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging Then add elmah.io to a new or existing LoggerFactory : var loggerFactory = new LoggerFactory() .AddElmahIo(\"API_KEY\", new Guid(\"LOG_ID\")); Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the log ID ( Where is my log ID? ) that should receive errors from Entity Framework. When using Entity Framework Core from ASP.NET Core, you never create your own LoggerFactory . Factories are provided through DI by ASP.NET Core. Check out this sample for details. Finally, enable logging in Entity Framework Core: optionsBuilder .UseLoggerFactory(loggerFactory) .UseSqlServer(/*...*/); ( UseSqlServer included for illustration purposes only - elmah.io works with any provider) That's it! All errors happening in Entity Framework Core, are now logged in elmah.io.","title":"Logging to elmah.io from Entity Framework Core"},{"location":"logging-to-elmah-io-from-express/","text":"Logging to elmah.io from Express The elmah.io integration for Express has been deprecated. For details on how to log errors to elmah.io from Express, check out https://github.com/elmahio/other-language-examples/blob/master/Node-Express/log.js . That's right. elmah.io doesn't only work with .NET. To integrate elmah.io into a Node Express web application, install the elmah.io npm package npm install elmah.io Add the following to your Express application: var elmah = require(\"elmah.io\"); var express = require(\"express\"); var app = express(); app.use(elmah.auto({logId:\"LOG_ID\", application:\"My App Name\", version: \"42.0.0\"})); Replace LOG_ID with your log ID ( Where is my log ID? ). Every error is logged to elmah.io.","title":"Logging from Express"},{"location":"logging-to-elmah-io-from-express/#logging-to-elmahio-from-express","text":"The elmah.io integration for Express has been deprecated. For details on how to log errors to elmah.io from Express, check out https://github.com/elmahio/other-language-examples/blob/master/Node-Express/log.js . That's right. elmah.io doesn't only work with .NET. To integrate elmah.io into a Node Express web application, install the elmah.io npm package npm install elmah.io Add the following to your Express application: var elmah = require(\"elmah.io\"); var express = require(\"express\"); var app = express(); app.use(elmah.auto({logId:\"LOG_ID\", application:\"My App Name\", version: \"42.0.0\"})); Replace LOG_ID with your log ID ( Where is my log ID? ). Every error is logged to elmah.io.","title":"Logging to elmah.io from Express"},{"location":"logging-to-elmah-io-from-javascript/","text":"Logging to elmah.io from JavaScript Logging to elmah.io from JavaScript Installation Options Application name Debug output Message filtering Events Enriching log messages Handling errors Logging manually IntelliSense Source maps Samples Angular React Message reference Troubleshooting elmah.io doesn't only support server-side .NET logging. We also log JavaScript errors happening on your website. Logging client-side errors, requires nothing more than installing the elmahio.js script on your website. Remember to generate a new API key with messages_write permission only. This makes it easy to revoke the API key if someone starts sending messages to your log with your key. Installation Pick an installation method of your choice: Manually CDN npm NuGet Library Manager ASP.NET Core Bower Download the latest release as a zip: https://github.com/elmahio/elmah.io.javascript/releases Unpack and copy elmahio.min.js to the Scripts folder or whatever folder you use to store JavaScript files. Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/Scripts/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"https://cdn.jsdelivr.net/gh/elmahio/elmah.io.javascript@3.1.3/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Install the elmah.io.javascript npm package: npm install elmah.io.javascript Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/node_modules/elmah.io.javascript/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Since Bower is no longer maintained , installing elmah.io.javascript through Bower, is supported using bower-npm-resolver . Install the resolver: npm install bower-npm-resolver --save Add the resolver in your .bowerrc file: { \"resolvers\": [ \"bower-npm-resolver\" ] } Install the elmah.io.javascript npm package: bower install npm:elmah.io.javascript --save Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/bower_components/elmah.io.javascript/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Add the elmah.io.javascript library in your libman.json file: { // ... \"libraries\": [ // ... { \"provider\": \"filesystem\", \"library\": \"https://raw.githubusercontent.com/elmahio/elmah.io.javascript/3.1.3/dist/elmahio.min.js\", \"destination\": \"wwwroot/lib/elmahio\" } ] } or using the LibMan CLI: libman install https://raw.githubusercontent.com/elmahio/elmah.io.javascript/3.1.3/dist/elmahio.min.js --provider filesystem --destination wwwroot\\lib\\elmahio Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/lib/elmahio/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Install the elmah.io.javascript NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package elmah.io.javascript dotnet add package elmah.io.javascript <PackageReference Include=\"elmah.io.javascript\" Version=\"3.*\" /> paket add elmah.io.javascript Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/Scripts/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> If not already configured, follow the guide installing elmah.io in ASP.NET Core . Install the Elmah.Io.AspNetCore.TagHelpers NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.TagHelpers dotnet add package Elmah.Io.AspNetCore.TagHelpers <PackageReference Include=\"Elmah.Io.AspNetCore.TagHelpers\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.TagHelpers Copy and paste the following line to the top of the _Layout.cshtml file: @addTagHelper *, Elmah.Io.AspNetCore.TagHelpers In the bottom of the file (but before referencing other JavaScript files), add the following tag helper: <elmah-io/> If you want to log JavaScript errors from production only, make sure to move the elmah-io element inside the tag <environment exclude=\"Development\"> . elmah.io automatically pulls your API key and log ID from the options specified as part of the installation for logging serverside errors from ASP.NET Core. That's it. All uncaught errors on your website, are now logged to elmah.io. Options If you prefer configuring in code (or need to access the options for something else), API key and log ID can be configured by referencing the elmahio.min.js script with parameters: <script src=\"~/scripts/elmahio.min.js\" type=\"text/javascript\"></script> Then initialize the logger in JavaScript: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID' }); Application name The application property on elmah.io, can be set on all log messages by setting the application option: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID', application: 'My application name' }); Debug output For debug purposes, debug output from the logger to the console can be enabled using the debug option: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID', debug: true }); Message filtering Log messages can be filtered, by adding an filter handler in options: new Elmahio({ // ... filter: function(msg) { return msg.severity === 'Verbose'; } }); In the example, all log messages with a severity of Verbose , are not logged to elmah.io. Events Enriching log messages Log messages can be enriched by subscribing to the message event: new Elmahio({ // ... }).on('message', function(msg) { if (!msg.data) msg.data = []; msg.data.push({key: 'MyCustomKey', value: 'MyCustomValue'}); }); In the example, all log messages are enriched with a data variable with they key MyCustomKey and value MyCustomValue . Handling errors To react on errors happening in elmah.io.javascript, subscribe to the error event: new Elmahio({ // ... }).on('error', function(status, text) { console.log('An error happened in elmah.io.javascript', status, text); }); In the example, all errors are written to the console. Logging manually You may want to log errors manually or even log information messages from JavaScript. To do so, Elmahio is actually a logging framework too: var logger = new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID' }); logger.verbose('This is verbose'); logger.verbose('This is verbose', new Error('A JavaScript error object')); logger.debug('This is debug'); logger.debug('This is debug', new Error('A JavaScript error object')); logger.information('This is information'); logger.information('This is information', new Error('A JavaScript error object')); logger.warning('This is warning'); logger.warning('This is warning', new Error('A JavaScript error object')); logger.error('This is error'); logger.error('This is error', new Error('A JavaScript error object')); logger.fatal('This is fatal'); logger.fatal('This is fatal', new Error('A JavaScript error object')); logger.log({ title: 'This is a custom log message', type: 'Of some type', severity: 'Error' }); var msg = logger.message(); // Get a prefilled message msg.title = \"This is a custom log message\"; logger.log(msg); The Error object used, should be a JavaScript Error object . As for the log -function, check out message reference . Manual logging only works when initializing the elmah.io logger from code. IntelliSense If installing through npm or similar, Visual Studio should pick up the TypeScript mappings from the elmah.io.javascript package. If not, add the following line in the top of the JavaScript file where you wan't elmah.io.javascript IntelliSense: /// <reference path=\"/path/to/elmahio.d.ts\" /> Source maps elmah.io.javascript automatically tries to translate stack traces from minified code into developer friendly traces using JavaScript source maps. In order for this to work, you will need to publish a valid .map source map file to your production environment and reference it in the end of your JavaScript: var v = 42; //# sourceMappingURL=/script.map Samples Angular elmah.io.javascript works great with Angular applications too. To log all errors happening in your Angular app, install elmah.io.javascript through npm as described above. Then add elmahio.min.js to the scripts section in the .angular-cli.json file ( angular.json in Angular 6): { \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\", // ... \"apps\": [ { // ... \"scripts\": [ \"../node_modules/elmah.io.javascript/dist/elmahio.min.js\" ], // ... } ], // ... } In the app.module.ts file, add a new ErrorHandler and add it to the providers section: import { NgModule, ErrorHandler } from '@angular/core'; // ... class ElmahIoErrorHandler implements ErrorHandler { logger: any; constructor() { this.logger = new Elmahio({ apiKey: 'API_KEY', logId: 'LOG_ID', }); } handleError(error) { if (error && error.message) { this.logger.error(error.message, error); } else { this.logger.error('Error in application', error); } } } @NgModule({ declarations: [ // ... ], imports: [ // ... ], providers: [{ provide: ErrorHandler, useClass: ElmahIoErrorHandler }], // ... }) All errors are shipped to the handleError -function by Angular and logged to elmah.io. Check out the Elmah.Io.JavaScript.Angular and Elmah.Io.JavaScript.AngularWebpack samples for some real working code. React To log all errors from a React application, install the elmah.io.javascript npm package as described above. Then modify the App.js file: // ... import Elmahio from '../node_modules/elmah.io.javascript/dist/elmahio'; export default class App extends Component { // ... constructor() { super(); var log = new Elmahio({ apiKey: 'API_KEY', logId: 'LOG_ID' }); } // ... } When initializing your React app, elmah.io is configured and all errors happening in the application are logged. Check out the Elmah.Io.JavaScript.React sample for some real working code. React have a known bug where errors are submitted twice. For better error handling in React, you should look into Error Boundaries . Message reference This is an example of the elmah.io.javascript Message object that is used in various callbacks, etc.: { title: 'The title of the message', detail: 'The error stack', source: 'The source of the error (typically a filename)', severity: 'Error', type: 'The type of the error', url: 'http://url.of/current/page', application: 'Application name set through options', queryString: [ {key: 'id', value: '42'} ], data: [ {key: 'User-Language', value: 'en-US'}, {key: 'Color-Depth', value: '24'} ], serverVariables: [ {key: 'User-Agent', value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'} ] } For a complete definition, check out the Message interface in the elmah.io.javascript TypeScript mappings . Troubleshooting If errors aren't logged from JavaScript, here's a list of things to try out: Make sure that the log with the specified ID exists. Make sure that the log isn't disabled and/or contain any ignore filters that could ignore client-side errors. Make sure that the API key is valid and contain the Messages | Write permission. Enable debugging when initializing elmah.io.javascript to get additional debug and error messages from within the script printed to the browser console: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID', debug: true });","title":"Logging from JavaScript"},{"location":"logging-to-elmah-io-from-javascript/#logging-to-elmahio-from-javascript","text":"Logging to elmah.io from JavaScript Installation Options Application name Debug output Message filtering Events Enriching log messages Handling errors Logging manually IntelliSense Source maps Samples Angular React Message reference Troubleshooting elmah.io doesn't only support server-side .NET logging. We also log JavaScript errors happening on your website. Logging client-side errors, requires nothing more than installing the elmahio.js script on your website. Remember to generate a new API key with messages_write permission only. This makes it easy to revoke the API key if someone starts sending messages to your log with your key.","title":"Logging to elmah.io from JavaScript"},{"location":"logging-to-elmah-io-from-javascript/#installation","text":"Pick an installation method of your choice: Manually CDN npm NuGet Library Manager ASP.NET Core Bower Download the latest release as a zip: https://github.com/elmahio/elmah.io.javascript/releases Unpack and copy elmahio.min.js to the Scripts folder or whatever folder you use to store JavaScript files. Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/Scripts/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"https://cdn.jsdelivr.net/gh/elmahio/elmah.io.javascript@3.1.3/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Install the elmah.io.javascript npm package: npm install elmah.io.javascript Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/node_modules/elmah.io.javascript/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Since Bower is no longer maintained , installing elmah.io.javascript through Bower, is supported using bower-npm-resolver . Install the resolver: npm install bower-npm-resolver --save Add the resolver in your .bowerrc file: { \"resolvers\": [ \"bower-npm-resolver\" ] } Install the elmah.io.javascript npm package: bower install npm:elmah.io.javascript --save Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/bower_components/elmah.io.javascript/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Add the elmah.io.javascript library in your libman.json file: { // ... \"libraries\": [ // ... { \"provider\": \"filesystem\", \"library\": \"https://raw.githubusercontent.com/elmahio/elmah.io.javascript/3.1.3/dist/elmahio.min.js\", \"destination\": \"wwwroot/lib/elmahio\" } ] } or using the LibMan CLI: libman install https://raw.githubusercontent.com/elmahio/elmah.io.javascript/3.1.3/dist/elmahio.min.js --provider filesystem --destination wwwroot\\lib\\elmahio Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/lib/elmahio/dist/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> Install the elmah.io.javascript NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package elmah.io.javascript dotnet add package elmah.io.javascript <PackageReference Include=\"elmah.io.javascript\" Version=\"3.*\" /> paket add elmah.io.javascript Reference elmahio.min.js just before the </body> tag (but before all other JavaScripts) in your shared _Layout.cshtml or all HTML files, depending on how you've structured your site: <script src=\"~/Scripts/elmahio.min.js?apiKey=YOUR-API-KEY&logId=YOUR-LOG-ID\" type=\"text/javascript\"></script> If not already configured, follow the guide installing elmah.io in ASP.NET Core . Install the Elmah.Io.AspNetCore.TagHelpers NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.TagHelpers dotnet add package Elmah.Io.AspNetCore.TagHelpers <PackageReference Include=\"Elmah.Io.AspNetCore.TagHelpers\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.TagHelpers Copy and paste the following line to the top of the _Layout.cshtml file: @addTagHelper *, Elmah.Io.AspNetCore.TagHelpers In the bottom of the file (but before referencing other JavaScript files), add the following tag helper: <elmah-io/> If you want to log JavaScript errors from production only, make sure to move the elmah-io element inside the tag <environment exclude=\"Development\"> . elmah.io automatically pulls your API key and log ID from the options specified as part of the installation for logging serverside errors from ASP.NET Core. That's it. All uncaught errors on your website, are now logged to elmah.io.","title":"Installation"},{"location":"logging-to-elmah-io-from-javascript/#options","text":"If you prefer configuring in code (or need to access the options for something else), API key and log ID can be configured by referencing the elmahio.min.js script with parameters: <script src=\"~/scripts/elmahio.min.js\" type=\"text/javascript\"></script> Then initialize the logger in JavaScript: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID' });","title":"Options"},{"location":"logging-to-elmah-io-from-javascript/#application-name","text":"The application property on elmah.io, can be set on all log messages by setting the application option: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID', application: 'My application name' });","title":"Application name"},{"location":"logging-to-elmah-io-from-javascript/#debug-output","text":"For debug purposes, debug output from the logger to the console can be enabled using the debug option: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID', debug: true });","title":"Debug output"},{"location":"logging-to-elmah-io-from-javascript/#message-filtering","text":"Log messages can be filtered, by adding an filter handler in options: new Elmahio({ // ... filter: function(msg) { return msg.severity === 'Verbose'; } }); In the example, all log messages with a severity of Verbose , are not logged to elmah.io.","title":"Message filtering"},{"location":"logging-to-elmah-io-from-javascript/#events","text":"","title":"Events"},{"location":"logging-to-elmah-io-from-javascript/#enriching-log-messages","text":"Log messages can be enriched by subscribing to the message event: new Elmahio({ // ... }).on('message', function(msg) { if (!msg.data) msg.data = []; msg.data.push({key: 'MyCustomKey', value: 'MyCustomValue'}); }); In the example, all log messages are enriched with a data variable with they key MyCustomKey and value MyCustomValue .","title":"Enriching log messages"},{"location":"logging-to-elmah-io-from-javascript/#handling-errors","text":"To react on errors happening in elmah.io.javascript, subscribe to the error event: new Elmahio({ // ... }).on('error', function(status, text) { console.log('An error happened in elmah.io.javascript', status, text); }); In the example, all errors are written to the console.","title":"Handling errors"},{"location":"logging-to-elmah-io-from-javascript/#logging-manually","text":"You may want to log errors manually or even log information messages from JavaScript. To do so, Elmahio is actually a logging framework too: var logger = new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID' }); logger.verbose('This is verbose'); logger.verbose('This is verbose', new Error('A JavaScript error object')); logger.debug('This is debug'); logger.debug('This is debug', new Error('A JavaScript error object')); logger.information('This is information'); logger.information('This is information', new Error('A JavaScript error object')); logger.warning('This is warning'); logger.warning('This is warning', new Error('A JavaScript error object')); logger.error('This is error'); logger.error('This is error', new Error('A JavaScript error object')); logger.fatal('This is fatal'); logger.fatal('This is fatal', new Error('A JavaScript error object')); logger.log({ title: 'This is a custom log message', type: 'Of some type', severity: 'Error' }); var msg = logger.message(); // Get a prefilled message msg.title = \"This is a custom log message\"; logger.log(msg); The Error object used, should be a JavaScript Error object . As for the log -function, check out message reference . Manual logging only works when initializing the elmah.io logger from code.","title":"Logging manually"},{"location":"logging-to-elmah-io-from-javascript/#intellisense","text":"If installing through npm or similar, Visual Studio should pick up the TypeScript mappings from the elmah.io.javascript package. If not, add the following line in the top of the JavaScript file where you wan't elmah.io.javascript IntelliSense: /// <reference path=\"/path/to/elmahio.d.ts\" />","title":"IntelliSense"},{"location":"logging-to-elmah-io-from-javascript/#source-maps","text":"elmah.io.javascript automatically tries to translate stack traces from minified code into developer friendly traces using JavaScript source maps. In order for this to work, you will need to publish a valid .map source map file to your production environment and reference it in the end of your JavaScript: var v = 42; //# sourceMappingURL=/script.map","title":"Source maps"},{"location":"logging-to-elmah-io-from-javascript/#samples","text":"","title":"Samples"},{"location":"logging-to-elmah-io-from-javascript/#angular","text":"elmah.io.javascript works great with Angular applications too. To log all errors happening in your Angular app, install elmah.io.javascript through npm as described above. Then add elmahio.min.js to the scripts section in the .angular-cli.json file ( angular.json in Angular 6): { \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\", // ... \"apps\": [ { // ... \"scripts\": [ \"../node_modules/elmah.io.javascript/dist/elmahio.min.js\" ], // ... } ], // ... } In the app.module.ts file, add a new ErrorHandler and add it to the providers section: import { NgModule, ErrorHandler } from '@angular/core'; // ... class ElmahIoErrorHandler implements ErrorHandler { logger: any; constructor() { this.logger = new Elmahio({ apiKey: 'API_KEY', logId: 'LOG_ID', }); } handleError(error) { if (error && error.message) { this.logger.error(error.message, error); } else { this.logger.error('Error in application', error); } } } @NgModule({ declarations: [ // ... ], imports: [ // ... ], providers: [{ provide: ErrorHandler, useClass: ElmahIoErrorHandler }], // ... }) All errors are shipped to the handleError -function by Angular and logged to elmah.io. Check out the Elmah.Io.JavaScript.Angular and Elmah.Io.JavaScript.AngularWebpack samples for some real working code.","title":"Angular"},{"location":"logging-to-elmah-io-from-javascript/#react","text":"To log all errors from a React application, install the elmah.io.javascript npm package as described above. Then modify the App.js file: // ... import Elmahio from '../node_modules/elmah.io.javascript/dist/elmahio'; export default class App extends Component { // ... constructor() { super(); var log = new Elmahio({ apiKey: 'API_KEY', logId: 'LOG_ID' }); } // ... } When initializing your React app, elmah.io is configured and all errors happening in the application are logged. Check out the Elmah.Io.JavaScript.React sample for some real working code. React have a known bug where errors are submitted twice. For better error handling in React, you should look into Error Boundaries .","title":"React"},{"location":"logging-to-elmah-io-from-javascript/#message-reference","text":"This is an example of the elmah.io.javascript Message object that is used in various callbacks, etc.: { title: 'The title of the message', detail: 'The error stack', source: 'The source of the error (typically a filename)', severity: 'Error', type: 'The type of the error', url: 'http://url.of/current/page', application: 'Application name set through options', queryString: [ {key: 'id', value: '42'} ], data: [ {key: 'User-Language', value: 'en-US'}, {key: 'Color-Depth', value: '24'} ], serverVariables: [ {key: 'User-Agent', value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'} ] } For a complete definition, check out the Message interface in the elmah.io.javascript TypeScript mappings .","title":"Message reference"},{"location":"logging-to-elmah-io-from-javascript/#troubleshooting","text":"If errors aren't logged from JavaScript, here's a list of things to try out: Make sure that the log with the specified ID exists. Make sure that the log isn't disabled and/or contain any ignore filters that could ignore client-side errors. Make sure that the API key is valid and contain the Messages | Write permission. Enable debugging when initializing elmah.io.javascript to get additional debug and error messages from within the script printed to the browser console: new Elmahio({ apiKey: 'YOUR-API-KEY', logId: 'YOUR-LOG-ID', debug: true });","title":"Troubleshooting"},{"location":"logging-to-elmah-io-from-jsnlog/","text":"Logging to elmah.io from JSNLog While logging through JSNLog still works, we recommend to use our native integration with JavaScript: Logging to elmah.io from JavaScript Using JSNLog you will be able to log JavaScript errors to elmah.io. In this sample, we will focus about logging JavaScript errors from a ASP.NET MVC web application, but you can use JSNLog to log anything to elmah.io, so please check out their documentation. Start by installing the JSNLog.Elmah package: Package Manager .NET CLI PackageReference Paket CLI Install-Package JSNLog.Elmah dotnet add package JSNLog.Elmah <PackageReference Include=\"JSNLog.Elmah\" Version=\"2.*\" /> paket add JSNLog.Elmah This installs and setup JSNLog into your project, using ELMAH as an appender. Then, install Elmah.Io : Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Add the JSNLog code before any script imports in your _Layout.cshtml file: @Html.Raw(JSNLog.JavascriptLogging.Configure()) You are ready to log errors from JavaScript til elmah.io. To test that everything is installed correctly, launch your web application and execute the following JavaScript using Chrome Developer Tools or similar: JL().fatal(\"log message\"); Navigate to you log at elmah.io and observe the new error. As you can see, logging JavaScript errors is now extremely simple and can be built into any try-catch, jQuery fail handlers and pretty much anywhere else. To log every JavaScript error, add the following to the bottom of the _Layout.cshtml file: <script> window.onerror = function (errorMsg, url, lineNumber, column, errorObj) { // Send object with all data to server side log, using severity fatal, // from logger \"onerrorLogger\" JL(\"onerrorLogger\").fatalException({ \"msg\": \"Exception!\", \"errorMsg\": errorMsg, \"url\": url, \"line number\": lineNumber, \"column\": column }, errorObj); // Tell browser to run its own error handler as well return false; } </script>","title":"Logging from JSNLog"},{"location":"logging-to-elmah-io-from-jsnlog/#logging-to-elmahio-from-jsnlog","text":"While logging through JSNLog still works, we recommend to use our native integration with JavaScript: Logging to elmah.io from JavaScript Using JSNLog you will be able to log JavaScript errors to elmah.io. In this sample, we will focus about logging JavaScript errors from a ASP.NET MVC web application, but you can use JSNLog to log anything to elmah.io, so please check out their documentation. Start by installing the JSNLog.Elmah package: Package Manager .NET CLI PackageReference Paket CLI Install-Package JSNLog.Elmah dotnet add package JSNLog.Elmah <PackageReference Include=\"JSNLog.Elmah\" Version=\"2.*\" /> paket add JSNLog.Elmah This installs and setup JSNLog into your project, using ELMAH as an appender. Then, install Elmah.Io : Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Add the JSNLog code before any script imports in your _Layout.cshtml file: @Html.Raw(JSNLog.JavascriptLogging.Configure()) You are ready to log errors from JavaScript til elmah.io. To test that everything is installed correctly, launch your web application and execute the following JavaScript using Chrome Developer Tools or similar: JL().fatal(\"log message\"); Navigate to you log at elmah.io and observe the new error. As you can see, logging JavaScript errors is now extremely simple and can be built into any try-catch, jQuery fail handlers and pretty much anywhere else. To log every JavaScript error, add the following to the bottom of the _Layout.cshtml file: <script> window.onerror = function (errorMsg, url, lineNumber, column, errorObj) { // Send object with all data to server side log, using severity fatal, // from logger \"onerrorLogger\" JL(\"onerrorLogger\").fatalException({ \"msg\": \"Exception!\", \"errorMsg\": errorMsg, \"url\": url, \"line number\": lineNumber, \"column\": column }, errorObj); // Tell browser to run its own error handler as well return false; } </script>","title":"Logging to elmah.io from JSNLog"},{"location":"logging-to-elmah-io-from-log4net/","text":"Logging to elmah.io from Log4net Logging to elmah.io from Log4net Logging custom properties Message hooks Decorating log messages Specify API key and log ID in appSettings ASP.NET Core In this tutorial we'll add logging to elmah.io from a .NET application with log4net. Install the elmah.io appender: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Log4Net dotnet add package Elmah.Io.Log4Net <PackageReference Include=\"Elmah.Io.Log4Net\" Version=\"3.*\" /> paket add Elmah.Io.Log4Net Add the following to your AssemblyInfo.cs file: [assembly: log4net.Config.XmlConfigurator(Watch = true)] Add the following config section to your web/app.config file: <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\" /> Finally, add the log4net configuration element to web/app.config : <log4net> <appender name=\"ElmahIoAppender\" type=\"elmah.io.log4net.ElmahIoAppender, elmah.io.log4net\"> <logId value=\"LOG_ID\" /> <apiKey value=\"API_KEY\" /> </appender> <root> <level value=\"Info\" /> <appender-ref ref=\"ElmahIoAppender\" /> </root> </log4net> That\u2019s it! log4net is now configured and log messages to elmah.io. Remember to replace API_KEY ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with your actual log Id. To start logging, write your usual log4net log statements: var log = log4net.LogManager.GetLogger(typeof(HomeController)); try { log.Info(\"Trying something\"); throw new ApplicationException(); } catch (ApplicationException ex) { log.Error(\"Error happening\", ex); } Logging custom properties log4net offers a feature called context properties. With context properties, you can log additional key/value pairs with every log message. The elmah.io appender for log4net, supports context properties as well. Context properties are handled like custom properties in the elmah.io UI. Let's utilize two different hooks in log4net, to add context properties to elmah.io: log4net.GlobalContext.Properties[\"ApplicationIdentifier\"] = \"MyCoolApp\"; log4net.ThreadContext.Properties[\"ThreadId\"] = Thread.CurrentThread.ManagedThreadId; log.Info(\"This is a message with custom properties\"); Basically, we set two custom properties on contextual classes provided by log4net. To read more about the choices in log4net, check out the log4net manual . When looking up the log message in elmah.io, we see the context properties in the Data tab. Besides the two custom variables that we set through GlobalContext and ThreadContext , we see a couple of build-in properties in log4net, both prefixed with log4net: . In addition, Elmah.Io.Log4Net provides a range of reserved property names, that can be used to fill in data in the correct fields on the elmah.io UI. Let's say you want to fill the User field: var properties = new PropertiesDictionary(); properties[\"User\"] = \"Arnold Schwarzenegger\"; log.Logger.Log(new LoggingEvent(new LoggingEventData { Level = Level.Error, TimeStampUtc = DateTime.UtcNow, Properties = properties, Message = \"Hasta la vista, baby\", })); This will fill in the value Arnold Schwarzenegger in the User field, as well as add a key/value pair to the Data tab on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage . Message hooks Decorating log messages In case you want to set one or more core properties on each elmah.io message logged, using message hooks may be a better solution. In that case you will need to add a bit of log4net magic. An example could be setting the Version property on all log messages. In the following code, we set a hard-coded version number on all log messages, but the value could come from assembly info, a text file, or similar: Hierarchy hier = log4net.LogManager.GetRepository() as Hierarchy; var elmahIoAppender = (ElmahIoAppender)(hier?.GetAppenders()) .FirstOrDefault(appender => appender.Name .Equals(\"ElmahIoAppender\", StringComparison.InvariantCultureIgnoreCase)); elmahIoAppender.ActivateOptions(); elmahIoAppender.Client.Messages.OnMessage += (sender, a) => { a.Message.Version = \"1.0.0\"; }; This rather ugly piece of code would go into an initalization block, depending on the project type. The code starts by getting the configured elmah.io appender (typically set up in web/app.config or log4net.config ). With the appender, you can access the underlying elmah.io client and subscribe to the OnMessage event. This let you trigger a small piece of code, just before sending log messages to elmah.io. In this case, we set the Version property to 1.0.0 . Remember to call the ActiveOptions method, to make sure that the Client property is initialized. Specify API key and log ID in appSettings You may prefer storing the API key and log ID in the appSettings element over having the values embedded into the appender element. This can be the case for easy config transformation, overwriting values on Azure, or similar. log4net provides a feature named pattern strings to address just that: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <configSections> <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\" /> </configSections> <appSettings> <add key=\"logId\" value=\"LOG_ID\"/> <add key=\"apiKey\" value=\"API_KEY\"/> </appSettings> <log4net> <root> <level value=\"ALL\" /> <appender-ref ref=\"ElmahIoAppender\" /> </root> <appender name=\"ElmahIoAppender\" type=\"elmah.io.log4net.ElmahIoAppender, elmah.io.log4net\"> <logId type=\"log4net.Util.PatternString\" value=\"%appSetting{logId}\" /> <apiKey type=\"log4net.Util.PatternString\" value=\"%appSetting{apiKey}\" /> </appender> </log4net> </configuration> The logId and apiKey elements underneath the elmah.io appender have been extended to include type=\"log4net.Util.PatternString\" . This allows for complex patterns in the value attribute. In this example, I reference an app setting from its name, by adding a value of %appSetting{logId} where logId is a reference to the app setting key specified above. ASP.NET Core Like other logging frameworks, logging through log4net from ASP.NET Core is also supported. We have a sample to show you how to set it up. The required NuGet packages and configuration are documented in this section. To start logging to elmah.io from Microsoft.Extensions.Logging (through log4net), install the Microsoft.Extensions.Logging.Log4Net.AspNetCore NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Microsoft.Extensions.Logging.Log4Net.AspNetCore dotnet add package Microsoft.Extensions.Logging.Log4Net.AspNetCore <PackageReference Include=\"Microsoft.Extensions.Logging.Log4Net.AspNetCore\" Version=\"3.*\" /> paket add Microsoft.Extensions.Logging.Log4Net.AspNetCore Include a log4net config file to the root of the project: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <log4net> <root> <level value=\"WARN\" /> <appender-ref ref=\"ElmahIoAppender\" /> <appender-ref ref=\"ConsoleAppender\" /> </root> <appender name=\"ElmahIoAppender\" type=\"elmah.io.log4net.ElmahIoAppender, elmah.io.log4net\"> <logId value=\"LOG_ID\" /> <apiKey value=\"API_KEY\" /> <!--<application value=\"My app\" />--> </appender> <appender name=\"ConsoleAppender\" type=\"log4net.Appender.ConsoleAppender\"> <layout type=\"log4net.Layout.PatternLayout\"> <conversionPattern value=\"%date [%thread] %-5level %logger [%property{NDC}] - %message%newline\" /> </layout> </appender> </log4net> In the Program.cs file, make sure to set up log4net: public class Program { public static void Main(string[] args) { CreateWebHostBuilder(args).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) => WebHost.CreateDefaultBuilder(args) .ConfigureLogging((hostingContext, logging) => { logging.AddLog4Net(); }) .UseStartup<Startup>(); } All internal logging from ASP.NET Core, as well as manual logging you create through the ILogger interface, now goes directly into elmah.io. A common request is to include all of the HTTP contextual information you usually get logged when using a package like Elmah.Io.AspNetCore . We have developed a specialized NuGet package to include cookies, server variables, etc. when logging through log4net from ASP.NET Core. To set it up, install the Elmah.Io.AspNetCore.Log4Net NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.Log4Net dotnet add package Elmah.Io.AspNetCore.Log4Net <PackageReference Include=\"Elmah.Io.AspNetCore.Log4Net\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.Log4Net Finally, make sure to call the UseElmahIoLog4Net method in the Configure method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // ... Exception handling middleware app.UseElmahIoLog4Net(); // ... UseMvc etc. }","title":"Logging from log4net"},{"location":"logging-to-elmah-io-from-log4net/#logging-to-elmahio-from-log4net","text":"Logging to elmah.io from Log4net Logging custom properties Message hooks Decorating log messages Specify API key and log ID in appSettings ASP.NET Core In this tutorial we'll add logging to elmah.io from a .NET application with log4net. Install the elmah.io appender: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Log4Net dotnet add package Elmah.Io.Log4Net <PackageReference Include=\"Elmah.Io.Log4Net\" Version=\"3.*\" /> paket add Elmah.Io.Log4Net Add the following to your AssemblyInfo.cs file: [assembly: log4net.Config.XmlConfigurator(Watch = true)] Add the following config section to your web/app.config file: <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\" /> Finally, add the log4net configuration element to web/app.config : <log4net> <appender name=\"ElmahIoAppender\" type=\"elmah.io.log4net.ElmahIoAppender, elmah.io.log4net\"> <logId value=\"LOG_ID\" /> <apiKey value=\"API_KEY\" /> </appender> <root> <level value=\"Info\" /> <appender-ref ref=\"ElmahIoAppender\" /> </root> </log4net> That\u2019s it! log4net is now configured and log messages to elmah.io. Remember to replace API_KEY ( Where is my API key? ) and LOG_ID ( Where is my log ID? ) with your actual log Id. To start logging, write your usual log4net log statements: var log = log4net.LogManager.GetLogger(typeof(HomeController)); try { log.Info(\"Trying something\"); throw new ApplicationException(); } catch (ApplicationException ex) { log.Error(\"Error happening\", ex); }","title":"Logging to elmah.io from Log4net"},{"location":"logging-to-elmah-io-from-log4net/#logging-custom-properties","text":"log4net offers a feature called context properties. With context properties, you can log additional key/value pairs with every log message. The elmah.io appender for log4net, supports context properties as well. Context properties are handled like custom properties in the elmah.io UI. Let's utilize two different hooks in log4net, to add context properties to elmah.io: log4net.GlobalContext.Properties[\"ApplicationIdentifier\"] = \"MyCoolApp\"; log4net.ThreadContext.Properties[\"ThreadId\"] = Thread.CurrentThread.ManagedThreadId; log.Info(\"This is a message with custom properties\"); Basically, we set two custom properties on contextual classes provided by log4net. To read more about the choices in log4net, check out the log4net manual . When looking up the log message in elmah.io, we see the context properties in the Data tab. Besides the two custom variables that we set through GlobalContext and ThreadContext , we see a couple of build-in properties in log4net, both prefixed with log4net: . In addition, Elmah.Io.Log4Net provides a range of reserved property names, that can be used to fill in data in the correct fields on the elmah.io UI. Let's say you want to fill the User field: var properties = new PropertiesDictionary(); properties[\"User\"] = \"Arnold Schwarzenegger\"; log.Logger.Log(new LoggingEvent(new LoggingEventData { Level = Level.Error, TimeStampUtc = DateTime.UtcNow, Properties = properties, Message = \"Hasta la vista, baby\", })); This will fill in the value Arnold Schwarzenegger in the User field, as well as add a key/value pair to the Data tab on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage .","title":"Logging custom properties"},{"location":"logging-to-elmah-io-from-log4net/#message-hooks","text":"","title":"Message hooks"},{"location":"logging-to-elmah-io-from-log4net/#decorating-log-messages","text":"In case you want to set one or more core properties on each elmah.io message logged, using message hooks may be a better solution. In that case you will need to add a bit of log4net magic. An example could be setting the Version property on all log messages. In the following code, we set a hard-coded version number on all log messages, but the value could come from assembly info, a text file, or similar: Hierarchy hier = log4net.LogManager.GetRepository() as Hierarchy; var elmahIoAppender = (ElmahIoAppender)(hier?.GetAppenders()) .FirstOrDefault(appender => appender.Name .Equals(\"ElmahIoAppender\", StringComparison.InvariantCultureIgnoreCase)); elmahIoAppender.ActivateOptions(); elmahIoAppender.Client.Messages.OnMessage += (sender, a) => { a.Message.Version = \"1.0.0\"; }; This rather ugly piece of code would go into an initalization block, depending on the project type. The code starts by getting the configured elmah.io appender (typically set up in web/app.config or log4net.config ). With the appender, you can access the underlying elmah.io client and subscribe to the OnMessage event. This let you trigger a small piece of code, just before sending log messages to elmah.io. In this case, we set the Version property to 1.0.0 . Remember to call the ActiveOptions method, to make sure that the Client property is initialized.","title":"Decorating log messages"},{"location":"logging-to-elmah-io-from-log4net/#specify-api-key-and-log-id-in-appsettings","text":"You may prefer storing the API key and log ID in the appSettings element over having the values embedded into the appender element. This can be the case for easy config transformation, overwriting values on Azure, or similar. log4net provides a feature named pattern strings to address just that: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <configSections> <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\" /> </configSections> <appSettings> <add key=\"logId\" value=\"LOG_ID\"/> <add key=\"apiKey\" value=\"API_KEY\"/> </appSettings> <log4net> <root> <level value=\"ALL\" /> <appender-ref ref=\"ElmahIoAppender\" /> </root> <appender name=\"ElmahIoAppender\" type=\"elmah.io.log4net.ElmahIoAppender, elmah.io.log4net\"> <logId type=\"log4net.Util.PatternString\" value=\"%appSetting{logId}\" /> <apiKey type=\"log4net.Util.PatternString\" value=\"%appSetting{apiKey}\" /> </appender> </log4net> </configuration> The logId and apiKey elements underneath the elmah.io appender have been extended to include type=\"log4net.Util.PatternString\" . This allows for complex patterns in the value attribute. In this example, I reference an app setting from its name, by adding a value of %appSetting{logId} where logId is a reference to the app setting key specified above.","title":"Specify API key and log ID in appSettings"},{"location":"logging-to-elmah-io-from-log4net/#aspnet-core","text":"Like other logging frameworks, logging through log4net from ASP.NET Core is also supported. We have a sample to show you how to set it up. The required NuGet packages and configuration are documented in this section. To start logging to elmah.io from Microsoft.Extensions.Logging (through log4net), install the Microsoft.Extensions.Logging.Log4Net.AspNetCore NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Microsoft.Extensions.Logging.Log4Net.AspNetCore dotnet add package Microsoft.Extensions.Logging.Log4Net.AspNetCore <PackageReference Include=\"Microsoft.Extensions.Logging.Log4Net.AspNetCore\" Version=\"3.*\" /> paket add Microsoft.Extensions.Logging.Log4Net.AspNetCore Include a log4net config file to the root of the project: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <log4net> <root> <level value=\"WARN\" /> <appender-ref ref=\"ElmahIoAppender\" /> <appender-ref ref=\"ConsoleAppender\" /> </root> <appender name=\"ElmahIoAppender\" type=\"elmah.io.log4net.ElmahIoAppender, elmah.io.log4net\"> <logId value=\"LOG_ID\" /> <apiKey value=\"API_KEY\" /> <!--<application value=\"My app\" />--> </appender> <appender name=\"ConsoleAppender\" type=\"log4net.Appender.ConsoleAppender\"> <layout type=\"log4net.Layout.PatternLayout\"> <conversionPattern value=\"%date [%thread] %-5level %logger [%property{NDC}] - %message%newline\" /> </layout> </appender> </log4net> In the Program.cs file, make sure to set up log4net: public class Program { public static void Main(string[] args) { CreateWebHostBuilder(args).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) => WebHost.CreateDefaultBuilder(args) .ConfigureLogging((hostingContext, logging) => { logging.AddLog4Net(); }) .UseStartup<Startup>(); } All internal logging from ASP.NET Core, as well as manual logging you create through the ILogger interface, now goes directly into elmah.io. A common request is to include all of the HTTP contextual information you usually get logged when using a package like Elmah.Io.AspNetCore . We have developed a specialized NuGet package to include cookies, server variables, etc. when logging through log4net from ASP.NET Core. To set it up, install the Elmah.Io.AspNetCore.Log4Net NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.Log4Net dotnet add package Elmah.Io.AspNetCore.Log4Net <PackageReference Include=\"Elmah.Io.AspNetCore.Log4Net\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.Log4Net Finally, make sure to call the UseElmahIoLog4Net method in the Configure method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // ... Exception handling middleware app.UseElmahIoLog4Net(); // ... UseMvc etc. }","title":"ASP.NET Core"},{"location":"logging-to-elmah-io-from-logary/","text":"Logging to elmah.io from Logary Logary is a semantic logging framework like Serilog and Microsoft Semantic Logging. Combining semantic logs with elmah.io are a perfect fit, since elmah.io has been designed with semantics from the ground up. In this tutorial, we\u2019ll add Logary to a Console application, but the process is almost identical with other project types. Create a new console application and add the elmah.io target for Logary: Package Manager .NET CLI PackageReference Paket CLI Install-Package Logary.Targets.Elmah.Io dotnet add package Logary.Targets.Elmah.Io <PackageReference Include=\"Logary.Targets.Elmah.Io\" Version=\"4.*\" /> paket add Logary.Targets.Elmah.Io Configuration in F# Configure elmah.io just like you would any normal target: withTargets [ // ... ElmahIO.create { ElmahIO with logId = \"LOG_ID\" } \"elmah.io\" ] >> withRules [ // ... Rule.createForTarget \"elmah.io\" ] where LOG_ID is the id of your log ( Where is my log ID? ). Configuration in C# Configuration in C# is just as easy: .Target<ElmahIO.Builder>( \"elmah.io\", conf => conf.Target.SendTo(apiKey: \"LOG_ID\")) where LOG_ID is the id of your log. Logging To start logging messages to elmah.io, you can use the following F# code: let logger = logary.getLogger (PointName [| \"Logary\"; \"Samples\"; \"main\" |]) Message.event Info \"User logged in\" |> Message.setField \"userName\" \"haf\" |> Logger.logSimple logger or in C#: var logger = logary.GetLogger(\"Logary.CSharpExample\"); logger.LogEventFormat(LogLevel.Fatal, \"Unhandled {exception}!\", e);","title":"Logging from Logary"},{"location":"logging-to-elmah-io-from-logary/#logging-to-elmahio-from-logary","text":"Logary is a semantic logging framework like Serilog and Microsoft Semantic Logging. Combining semantic logs with elmah.io are a perfect fit, since elmah.io has been designed with semantics from the ground up. In this tutorial, we\u2019ll add Logary to a Console application, but the process is almost identical with other project types. Create a new console application and add the elmah.io target for Logary: Package Manager .NET CLI PackageReference Paket CLI Install-Package Logary.Targets.Elmah.Io dotnet add package Logary.Targets.Elmah.Io <PackageReference Include=\"Logary.Targets.Elmah.Io\" Version=\"4.*\" /> paket add Logary.Targets.Elmah.Io","title":"Logging to elmah.io from Logary"},{"location":"logging-to-elmah-io-from-logary/#configuration-in-f","text":"Configure elmah.io just like you would any normal target: withTargets [ // ... ElmahIO.create { ElmahIO with logId = \"LOG_ID\" } \"elmah.io\" ] >> withRules [ // ... Rule.createForTarget \"elmah.io\" ] where LOG_ID is the id of your log ( Where is my log ID? ).","title":"Configuration in F&#35;"},{"location":"logging-to-elmah-io-from-logary/#configuration-in-c","text":"Configuration in C# is just as easy: .Target<ElmahIO.Builder>( \"elmah.io\", conf => conf.Target.SendTo(apiKey: \"LOG_ID\")) where LOG_ID is the id of your log.","title":"Configuration in C&#35;"},{"location":"logging-to-elmah-io-from-logary/#logging","text":"To start logging messages to elmah.io, you can use the following F# code: let logger = logary.getLogger (PointName [| \"Logary\"; \"Samples\"; \"main\" |]) Message.event Info \"User logged in\" |> Message.setField \"userName\" \"haf\" |> Logger.logSimple logger or in C#: var logger = logary.GetLogger(\"Logary.CSharpExample\"); logger.LogEventFormat(LogLevel.Fatal, \"Unhandled {exception}!\", e);","title":"Logging"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/","text":"Logging to elmah.io from Microsoft.Extensions.Logging Logging to elmah.io from Microsoft.Extensions.Logging Logging from ASP.NET Core Include HTTP context Logging custom properties Options appsettings.json configuration Filtering log messages Logging through a proxy Logging from a console application Troubleshooting Microsoft.Extensions.Logging is a common logging abstraction from Microsoft, much like log4net and Serilog. Microsoft.Extensions.Logging started as a new logging mechanism for ASP.NET Core but now acts as a logging framework for all sorts of project types. Start by installing the Elmah.Io.Extensions.Logging package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging Locate your API key ( Where is my API key? ) and log ID. The two values will be referenced as API_KEY and LOG_ID ( Where is my log ID? ) in the following. Logging from ASP.NET Core In the Program.cs file, add a new using statement: using Elmah.Io.Extensions.Logging; Then call the ConfigureLogging -method and configure elmah.io like shown here: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); }) .Build(); By calling, the AddFilter -method, you ensure that only warnings and up are logged to elmah.io. The API key and log ID can also be configured in appsettings.json : { // ... \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Then configure the section and use the AddElmahIo overload (without any parameters): WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.Services.Configure<ElmahIoProviderOptions>(ctx.Configuration.GetSection(\"ElmahIo\")); logging.AddElmahIo(); }) .Build(); Start logging messages by injecting an ILogger in your controllers: public class HomeController : Controller { private readonly ILogger _logger; public HomeController(ILogger logger) { _logger = logger; } public IActionResult Index() { _logger.LogWarning(\"Request to index\"); return View(); } } Include HTTP context A common use case for using Microsoft.Extensions.Logging is part of an ASP.NET Core project. When combining the two, you would expect the log messages to contain relevant information from the HTTP context (like URL, status code, cookies, etc.). This is not the case out of the box, since Microsoft.Extensions.Logging doesn't know which project type that includes it. Logging HTTP context requires Elmah.Io.Extensions.Logging version 3.6.x or newer. To add HTTP context properties to log messages when logging from ASP.NET Core, install the Elmah.Io.AspNetCore.ExtensionsLogging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.ExtensionsLogging dotnet add package Elmah.Io.AspNetCore.ExtensionsLogging <PackageReference Include=\"Elmah.Io.AspNetCore.ExtensionsLogging\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.ExtensionsLogging Then call the UseElmahIoExtensionsLogging method in the Configure method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // ... Exception handling middleware app.UseElmahIoExtensionsLogging(); // ... UseMvc etc. } It's important to call the UseElmahIoExtensionsLogging method after any calls to UseElmahIo , UseAuthentication , and other exception handling middleware but before UseMvc and UseEndpoints . Logging custom properties Elmah.Io.Extensions.Logging support Microsoft.Extensions.Logging scopes from version 3.6.x . In short, scopes are a way to decorate your log messages like enrichers in Serilog and context in NLog and log4net. By including properties to a scope, these properties automatically go into the Data tab on elmah.io. To define a new scope, wrap your logging code in a using : using (_logger.BeginScope(new Dictionary<string, object> { { \"UserId\", 42 } })) { _logger.LogInformation(\"Someone says hello\"); } In the example above, the UserId key will be added on the Data tab with the value of 42 . Like the other logging framework integrations, Elmah.Io.Extensions.Logging supports a range of known keys that can be used to insert value in the correct fields on the elmah.io UI. using (_logger.BeginScope(new Dictionary<string, object> { { \"statuscode\", 500 }, { \"method\", \"GET\" } })) { _logger.LogError(\"Request to {url} caused an error\", \"/profile\"); } In this example, a log message with the template Request to {url} caused an error is logged. The use of the variable names statuscode , method , and url will fill in those values in the correct fields on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage . An alternative is to use the OnMessage action. As an example, we'll add a version number to all messages: logging .AddElmahIo(options => { // ... options.OnMessage = msg => { msg.Version = \"2.0.0\"; }; }); You can even access the current HTTP context in the OnMessage action. To do so, start by creating a new class named DecorateElmahIoMessages : public class DecorateElmahIoMessages : IConfigureOptions<ElmahIoProviderOptions> { private readonly IHttpContextAccessor httpContextAccessor; public DecorateElmahIoMessages(IHttpContextAccessor httpContextAccessor) { this.httpContextAccessor = httpContextAccessor; } public void Configure(ElmahIoProviderOptions options) { options.OnMessage = msg => { var context = httpContextAccessor.HttpContext; if (context == null) return; msg.User = context.User?.Identity?.Name; }; } } Then register IHttpContextAccessor and the new class in the ConfigureServices method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>(); services.AddSingleton<IConfigureOptions<ElmahIoProviderOptions>, DecorateElmahIoMessages>(); // ... } Options appsettings.json configuration Some of the configuration for Elmah.Io.Extensions.Logging can be done through the appsettings.json file when using ASP.NET Core 2.x. To configure the minimum log level, add a new logger named ElmahIo to the settings file: { \"Logging\": { // ... \"ElmahIo\": { \"LogLevel\": { \"Default\": \"Warning\" } } } } Finally, tell the logger to look for this information, by adding a bit of code to the ConfigureLogging -method: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddConfiguration(ctx.Configuration.GetSection(\"Logging\")); // ... }) .Build(); Filtering log messages As default, the elmah.io logger for Microsoft.Extensions.Logging only logs warnings, errors, and fatals. The rationale behind this is that we build an error management system and doesn't do much to support millions of debug messages from your code. Sometimes you may want to log non-exception messages, though. To do so, use filters in Microsoft.Extensions.Logging. To log everything from log level Information and up, do the following: Inside the ConfigureLogging -method in Startup.cs , change the minimum level: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { // ... logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Information); }) .Build(); In the code sample, every log message with a log level of Information and up will be logged to elmah.io. To log a new information message, create a logger with the elmah.io category, and call the LogInformation method: var logger = factory.CreateLogger(\"elmah.io\"); logger.LogInformation(\"This is an information message\"); Logging through a proxy Proxy configuration requires 3.5.49 or newer. You can log through a proxy using options: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddElmahIo(options => { // ... options.WebProxy = new WebProxy(\"localhost\", 8000); }); }) .Build(); In this example, the elmah.io client routes all traffic through http://localhost:8000 . Logging from a console application Create a new LoggerFactory : var factory = new LoggerFactory(); Configure Microsoft.Extensions.Logging to use elmah.io: factory.AddElmahIo(\"API_KEY\", new Guid(\"LOG_ID\")); Finally, create a new logger and start logging exceptions: var logger = factory.CreateLogger(\"MyLog\"); logger.LogError(1, ex, \"Unexpected error\"); Troubleshooting x message(s) dropped because of queue size limit If you see this message in your log, it means that you are logging a large number of messages to elmah.io through Microsoft.Extensions.Logging within a short period of time. Either turn down the volume using filters: logging.AddElmahIo(options => { /*...*/ }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); or increase the queue size of Elmah.Io.Extensions.Logging : logging.AddElmahIo(options => { // ... options.BackgroundQueueSize = 5000; });","title":"Logging from Microsoft.Extensions.Logging"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#logging-to-elmahio-from-microsoftextensionslogging","text":"Logging to elmah.io from Microsoft.Extensions.Logging Logging from ASP.NET Core Include HTTP context Logging custom properties Options appsettings.json configuration Filtering log messages Logging through a proxy Logging from a console application Troubleshooting Microsoft.Extensions.Logging is a common logging abstraction from Microsoft, much like log4net and Serilog. Microsoft.Extensions.Logging started as a new logging mechanism for ASP.NET Core but now acts as a logging framework for all sorts of project types. Start by installing the Elmah.Io.Extensions.Logging package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Extensions.Logging dotnet add package Elmah.Io.Extensions.Logging <PackageReference Include=\"Elmah.Io.Extensions.Logging\" Version=\"3.*\" /> paket add Elmah.Io.Extensions.Logging Locate your API key ( Where is my API key? ) and log ID. The two values will be referenced as API_KEY and LOG_ID ( Where is my log ID? ) in the following.","title":"Logging to elmah.io from Microsoft.Extensions.Logging"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#logging-from-aspnet-core","text":"In the Program.cs file, add a new using statement: using Elmah.Io.Extensions.Logging; Then call the ConfigureLogging -method and configure elmah.io like shown here: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddElmahIo(options => { options.ApiKey = \"API_KEY\"; options.LogId = new Guid(\"LOG_ID\"); }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); }) .Build(); By calling, the AddFilter -method, you ensure that only warnings and up are logged to elmah.io. The API key and log ID can also be configured in appsettings.json : { // ... \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Then configure the section and use the AddElmahIo overload (without any parameters): WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.Services.Configure<ElmahIoProviderOptions>(ctx.Configuration.GetSection(\"ElmahIo\")); logging.AddElmahIo(); }) .Build(); Start logging messages by injecting an ILogger in your controllers: public class HomeController : Controller { private readonly ILogger _logger; public HomeController(ILogger logger) { _logger = logger; } public IActionResult Index() { _logger.LogWarning(\"Request to index\"); return View(); } }","title":"Logging from ASP.NET Core"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#include-http-context","text":"A common use case for using Microsoft.Extensions.Logging is part of an ASP.NET Core project. When combining the two, you would expect the log messages to contain relevant information from the HTTP context (like URL, status code, cookies, etc.). This is not the case out of the box, since Microsoft.Extensions.Logging doesn't know which project type that includes it. Logging HTTP context requires Elmah.Io.Extensions.Logging version 3.6.x or newer. To add HTTP context properties to log messages when logging from ASP.NET Core, install the Elmah.Io.AspNetCore.ExtensionsLogging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.ExtensionsLogging dotnet add package Elmah.Io.AspNetCore.ExtensionsLogging <PackageReference Include=\"Elmah.Io.AspNetCore.ExtensionsLogging\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.ExtensionsLogging Then call the UseElmahIoExtensionsLogging method in the Configure method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // ... Exception handling middleware app.UseElmahIoExtensionsLogging(); // ... UseMvc etc. } It's important to call the UseElmahIoExtensionsLogging method after any calls to UseElmahIo , UseAuthentication , and other exception handling middleware but before UseMvc and UseEndpoints .","title":"Include HTTP context"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#logging-custom-properties","text":"Elmah.Io.Extensions.Logging support Microsoft.Extensions.Logging scopes from version 3.6.x . In short, scopes are a way to decorate your log messages like enrichers in Serilog and context in NLog and log4net. By including properties to a scope, these properties automatically go into the Data tab on elmah.io. To define a new scope, wrap your logging code in a using : using (_logger.BeginScope(new Dictionary<string, object> { { \"UserId\", 42 } })) { _logger.LogInformation(\"Someone says hello\"); } In the example above, the UserId key will be added on the Data tab with the value of 42 . Like the other logging framework integrations, Elmah.Io.Extensions.Logging supports a range of known keys that can be used to insert value in the correct fields on the elmah.io UI. using (_logger.BeginScope(new Dictionary<string, object> { { \"statuscode\", 500 }, { \"method\", \"GET\" } })) { _logger.LogError(\"Request to {url} caused an error\", \"/profile\"); } In this example, a log message with the template Request to {url} caused an error is logged. The use of the variable names statuscode , method , and url will fill in those values in the correct fields on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage . An alternative is to use the OnMessage action. As an example, we'll add a version number to all messages: logging .AddElmahIo(options => { // ... options.OnMessage = msg => { msg.Version = \"2.0.0\"; }; }); You can even access the current HTTP context in the OnMessage action. To do so, start by creating a new class named DecorateElmahIoMessages : public class DecorateElmahIoMessages : IConfigureOptions<ElmahIoProviderOptions> { private readonly IHttpContextAccessor httpContextAccessor; public DecorateElmahIoMessages(IHttpContextAccessor httpContextAccessor) { this.httpContextAccessor = httpContextAccessor; } public void Configure(ElmahIoProviderOptions options) { options.OnMessage = msg => { var context = httpContextAccessor.HttpContext; if (context == null) return; msg.User = context.User?.Identity?.Name; }; } } Then register IHttpContextAccessor and the new class in the ConfigureServices method in the Startup.cs file: public void ConfigureServices(IServiceCollection services) { services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>(); services.AddSingleton<IConfigureOptions<ElmahIoProviderOptions>, DecorateElmahIoMessages>(); // ... }","title":"Logging custom properties"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#options","text":"","title":"Options"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#appsettingsjson-configuration","text":"Some of the configuration for Elmah.Io.Extensions.Logging can be done through the appsettings.json file when using ASP.NET Core 2.x. To configure the minimum log level, add a new logger named ElmahIo to the settings file: { \"Logging\": { // ... \"ElmahIo\": { \"LogLevel\": { \"Default\": \"Warning\" } } } } Finally, tell the logger to look for this information, by adding a bit of code to the ConfigureLogging -method: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddConfiguration(ctx.Configuration.GetSection(\"Logging\")); // ... }) .Build();","title":"appsettings.json configuration"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#filtering-log-messages","text":"As default, the elmah.io logger for Microsoft.Extensions.Logging only logs warnings, errors, and fatals. The rationale behind this is that we build an error management system and doesn't do much to support millions of debug messages from your code. Sometimes you may want to log non-exception messages, though. To do so, use filters in Microsoft.Extensions.Logging. To log everything from log level Information and up, do the following: Inside the ConfigureLogging -method in Startup.cs , change the minimum level: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { // ... logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Information); }) .Build(); In the code sample, every log message with a log level of Information and up will be logged to elmah.io. To log a new information message, create a logger with the elmah.io category, and call the LogInformation method: var logger = factory.CreateLogger(\"elmah.io\"); logger.LogInformation(\"This is an information message\");","title":"Filtering log messages"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#logging-through-a-proxy","text":"Proxy configuration requires 3.5.49 or newer. You can log through a proxy using options: WebHost.CreateDefaultBuilder(args) .UseStartup<Startup>() .ConfigureLogging((ctx, logging) => { logging.AddElmahIo(options => { // ... options.WebProxy = new WebProxy(\"localhost\", 8000); }); }) .Build(); In this example, the elmah.io client routes all traffic through http://localhost:8000 .","title":"Logging through a proxy"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#logging-from-a-console-application","text":"Create a new LoggerFactory : var factory = new LoggerFactory(); Configure Microsoft.Extensions.Logging to use elmah.io: factory.AddElmahIo(\"API_KEY\", new Guid(\"LOG_ID\")); Finally, create a new logger and start logging exceptions: var logger = factory.CreateLogger(\"MyLog\"); logger.LogError(1, ex, \"Unexpected error\");","title":"Logging from a console application"},{"location":"logging-to-elmah-io-from-microsoft-extensions-logging/#troubleshooting","text":"x message(s) dropped because of queue size limit If you see this message in your log, it means that you are logging a large number of messages to elmah.io through Microsoft.Extensions.Logging within a short period of time. Either turn down the volume using filters: logging.AddElmahIo(options => { /*...*/ }); logging.AddFilter<ElmahIoLoggerProvider>(null, LogLevel.Warning); or increase the queue size of Elmah.Io.Extensions.Logging : logging.AddElmahIo(options => { // ... options.BackgroundQueueSize = 5000; });","title":"Troubleshooting"},{"location":"logging-to-elmah-io-from-nancy/","text":"Logging to elmah.io from Nancy As with MVC and WebAPI, Nancy already provides ELMAH support out of the box. Start by installing the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). To integrate Nancy and ELMAH, Christian Westman already did a great job with his Nancy.Elmah package. Install it using NuGet: Package Manager .NET CLI PackageReference Paket CLI Install-Package Nancy.Elmah dotnet add package Nancy.Elmah <PackageReference Include=\"Nancy.Elmah\" Version=\"0.*\" /> paket add Nancy.Elmah It\u2019s important that you install the elmah.io package before Nancy.Elmah, because both packages like to add the ELMAH configuration to the web.config file. If you install it the other way around, you will need to add the elmah.io ErrorLog element manually. In order for Nancy to know how to log errors to Elmah, you need to add an override of the DefaultNancyBootstrapper. Create a new class in the root named Bootstrapper: using Nancy; using Nancy.Bootstrapper; using Nancy.Elmah; using Nancy.TinyIoc; namespace Elmah.Io.NancyExample { public class Bootstrapper : DefaultNancyBootstrapper { protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines) { base.ApplicationStartup(container, pipelines); Elmahlogging.Enable(pipelines, \"elmah\"); } } } The important thing in the code sample is line 13, where we tell Nancy.Elmah to hook into the pipeline of Nancy in order for it to catch and log HTTP errors. The second parameter for the Enable-method, lets us define a URL for the ELMAH error page, which can be used as an alternative to elmah.io for quick viewing of errors.","title":"Logging from Nancy"},{"location":"logging-to-elmah-io-from-nancy/#logging-to-elmahio-from-nancy","text":"As with MVC and WebAPI, Nancy already provides ELMAH support out of the box. Start by installing the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). To integrate Nancy and ELMAH, Christian Westman already did a great job with his Nancy.Elmah package. Install it using NuGet: Package Manager .NET CLI PackageReference Paket CLI Install-Package Nancy.Elmah dotnet add package Nancy.Elmah <PackageReference Include=\"Nancy.Elmah\" Version=\"0.*\" /> paket add Nancy.Elmah It\u2019s important that you install the elmah.io package before Nancy.Elmah, because both packages like to add the ELMAH configuration to the web.config file. If you install it the other way around, you will need to add the elmah.io ErrorLog element manually. In order for Nancy to know how to log errors to Elmah, you need to add an override of the DefaultNancyBootstrapper. Create a new class in the root named Bootstrapper: using Nancy; using Nancy.Bootstrapper; using Nancy.Elmah; using Nancy.TinyIoc; namespace Elmah.Io.NancyExample { public class Bootstrapper : DefaultNancyBootstrapper { protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines) { base.ApplicationStartup(container, pipelines); Elmahlogging.Enable(pipelines, \"elmah\"); } } } The important thing in the code sample is line 13, where we tell Nancy.Elmah to hook into the pipeline of Nancy in order for it to catch and log HTTP errors. The second parameter for the Enable-method, lets us define a URL for the ELMAH error page, which can be used as an alternative to elmah.io for quick viewing of errors.","title":"Logging to elmah.io from Nancy"},{"location":"logging-to-elmah-io-from-nlog/","text":"Logging to elmah.io from NLog Logging to elmah.io from NLog Configuration in .NET Specify API key and log ID in appSettings Setting application name IntelliSense Configuration in .NET Core elmah.io configuration outside the NLog section IntelliSense Configuration in code Logging custom properties Message hooks Decorating log messages Handle errors Error filtering Include HTTP context in ASP.NET and ASP.NET Core Troubleshooting NLog is one of the most popular logging frameworks for .NET. With an active history of almost 10 years, the possibilities with NLog are many and it\u2019s easy to find documentation on how to use it. To start logging messages from NLog to elmah.io, you need to install the Elmah.Io.NLog NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.NLog dotnet add package Elmah.Io.NLog <PackageReference Include=\"Elmah.Io.NLog\" Version=\"3.*\" /> paket add Elmah.Io.NLog Please don't use NLog 4.6.0 since that version contains a bug that causes the elmah.io target to not load correctly. 4.5.11 , 4.6.1 , or newer. Configuration in .NET To configure the elmah.io target, add the following configuration to your app.config/web.config/nlog.config depending on what kind of project you\u2019ve created: <extensions> <add assembly=\"Elmah.Io.NLog\"/> </extensions> <targets> <target name=\"elmahio\" type=\"elmah.io\" apiKey=\"API_KEY\" logId=\"LOG_ID\"/> </targets> <rules> <logger name=\"*\" minlevel=\"Info\" writeTo=\"elmahio\" /> </rules> Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). In the example we specify the level minimum as Info. This tells NLog to log only information, warning, error and fatal messages. You may adjust this, but be aware that your elmah.io log may run full pretty fast, especially if you log thousands and thousands of trace and debug messages. Log messages to elmah.io, just as with every other target and NLog: log.Warn(\"This is a warning message\"); log.Error(new Exception(), \"This is an error message\"); Specify API key and log ID in appSettings If you are already using elmah.io, you may have your API key and log ID in the appSettings element already. To use these settings from withing the NLog target configuration you can use an NLog layout formatter: <targets> <target name=\"elmahio\" type=\"elmah.io\" apiKey=\"${appsetting:item=apiKey}\" logId=\"${appsetting:item=logId}\"/> </targets> By using the layout ${appsetting:item=apiKey} you tell NLog that the value for this attribute is in an appSettings element named elmahKey : <appSettings> <add key=\"apiKey\" value=\"API_KEY\" /> <add key=\"logId\" value=\"LOG_ID\" /> </appSettings> The appSettings layout formatter only works when targeting .NET Full Framework and requires Elmah.Io.NLog version 3.3.x or above and NLog version 4.6.x or above. Setting application name The application field on elmah.io can be set globally through NLog config: <targets> <target name=\"elmahio\" xsi:type=\"elmahio:elmah.io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" application=\"APP_NAME\" /> </targets> Replace APP_NAME with the application you want logged to elmah.io IntelliSense There is support for adding IntelliSense in Visual Studio for the NLog.config file. Extend the nlog root element like this: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:elmahio=\"http://www.nlog-project.org/schemas/NLog.Targets.Elmah.Io.xsd\" xsi:schemaLocation=\"http://www.nlog-project.org/schemas/NLog.Targets.Elmah.Io.xsd http://www.nlog-project.org/schemas/NLog.Targets.Elmah.Io.xsd\"> <!-- ... --> </nlog> Configuration in .NET Core .NET Core switched from declaring XML configuration in app/web/nlog.config files to JSON configuration in an appsettings.json file. To configure elmah.io in JSON, install the NLog.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package NLog.Extensions.Logging dotnet add package NLog.Extensions.Logging <PackageReference Include=\"NLog.Extensions.Logging\" Version=\"1.*\" /> paket add NLog.Extensions.Logging Extend the appsettings.json file with a new NLog section: { \"NLog\": { \"throwConfigExceptions\": true, \"extensions\": [ { \"assembly\": \"Elmah.Io.NLog\" } ], \"targets\": { \"elmahio\": { \"type\": \"elmah.io\", \"apiKey\": \"API_KEY\", \"logId\": \"LOG_ID\" } }, \"rules\": [ { \"logger\": \"*\", \"minLevel\": \"Info\", \"writeTo\": \"elmahio\" } ] } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). If you haven't already loaded the configuration in your application, make sure to do so: var config = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .Build(); Finally, tell NLog how to load the NLog configuration section: LogManager.Configuration = new NLogLoggingConfiguration(config.GetSection(\"NLog\")); elmah.io configuration outside the NLog section You might not want the elmah.io API key and log Id inside the NLog section or already have an ElmahIo section defined and want to reuse that. Splitting up configuration like that is supported through NLog layout renderers: { \"NLog\": { // ... \"targets\": { \"elmahio\": { \"type\": \"elmah.io\", \"apiKey\": \"${configsetting:item=ElmahIo.ApiKey}\", \"logId\": \"${configsetting:item=ElmahIo.LogId}\" } }, // ... }, \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Notice how the value of the apiKey and logId parameters have been replaced with ${configsetting:item=ElmahIo.*} . In the bottom the ElmahIo section wrap the API key and log Id. To make this work, you will need an additional line of C# when setting up NLog logging: var config = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .Build(); ConfigSettingLayoutRenderer.DefaultConfiguration = config; // \ud83d\udc48 add this line LogManager.Configuration = new NLogLoggingConfiguration(config.GetSection(\"NLog\")); IntelliSense There is support for adding IntelliSense in Visual Studio for the NLog section in the appsettings.json file. Copy and paste the following link into the Schema textbox above the file content: https://nlog-project.org/schemas/appsettings.schema.json Configuration in code The elmah.io target can be configured from C# code if you prefer or need to access the built-in events (see more later). The following adds logging to elmah.io: var config = new LoggingConfiguration(); var elmahIoTarget = new ElmahIoTarget(); elmahIoTarget.Name = \"elmahio\"; elmahIoTarget.ApiKey = \"API_KEY\"; elmahIoTarget.LogId = \"LOG_ID\"; config.AddTarget(elmahIoTarget); config.AddRuleForAllLevels(elmahIoTarget); LogManager.Configuration = config; The example will log all log levels to elmah.io. For more information about how to configure individual log levels, check out the NLog documentation on GitHub . Logging custom properties NLog supports logging custom properties in multiple ways. If you want to include a property (like a version number) to all log messages, you might want to look into the OnMessage feature on Elmah.Io.NLog . With custom properties, you can log additional key/value pairs with every log message. The elmah.io target for NLog supports custom properties as well. Properties are persisted alongside every log message in elmah.io and searchable if named correctly . One way to log custom properties with NLog and elmah.io is to use the overload of each logging-method that takes a LogEventInfo object as a parameter: var infoMessage = new LogEventInfo(LogLevel.Info, \"\", \"This is an information message\"); infoMessage.Properties.Add(\"Some Property Key\", \"Some Property Value\"); log.Info(infoMessage); This saves the information message in elmah.io with a custom property with key Some Property Key and value Some Property Value . As of NLog 4.5, structured logging is supported as well. To log a property as part of the log message, use the new syntax as shown here: log.Warn(\"Property named {FirstName}\", \"Donald\"); In the example, NLog will log the message Property named \"Donald\" , but the key ( FirstName ) and value ( Donald ), will also be available in the Data tab inside elmah.io. Elmah.Io.NLog provides a range of reserved property names, that can be used to fill in data in the correct fields on the elmah.io UI. Let's say you want to fill the User field using structured logging only: log.Info(\"{Quote} from {User}\", \"Hasta la vista, baby\", \"T-800\"); This will fill in the value T-800 in the User field, as well as add two key/value pairs ( Quote and User ) to the Data tab on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage . NLog also provides a fluent API (available in the NLog.Fluent namespace) that some might find more readable: logger.Info() .Message(\"I'll be back\") .Property(\"User\", \"T-800\") .Write(); If you want to use the normal logging methods like Info and Error , you can do so injunction with the MappedDiagnosticsLogicalContext class, also provided by NLog: using (MappedDiagnosticsLogicalContext.SetScoped(\"User\", \"T-800\")) { logger.Info(\"I'll be back\"); } This will create the same result as the example above. Message hooks Elmah.Io.NLog provides message hooks similar to the integrations with ASP.NET and ASP.NET Core. Message hooks need to be implemented in C#. Either configure the elmah.io target in C# or fetch the target already configured in XML: var elmahIoTarget = (ElmahIoTarget)LogManager.Configuration.FindTargetByName(\"elmahio\"); You also need to install the most recent version of the Elmah.Io.Client NuGet package to use message hooks. Decorating log messages To include additional information on log messages, you can use the OnMessage action: elmahIoTarget.OnMessage = msg => { msg.Version = \"1.0.0\"; }; The example above includes a version number on all errors. Handle errors To handle any errors happening while processing a log message, you can use the OnError event when initializing the elmah.io target: elmahIoTarget.OnError = (msg, err) => { // Do something here }; The example implements a callback if logging to elmah.io fails. How you choose to implement this is entirely up to your application and tech stack. Error filtering To ignore specific errors based on their content, you can use the OnFilter event when initializing the elmah.io target: elmahIoTarget.OnFilter = msg => { return msg.Title.Contains(\"trace\"); }; The example above ignores any log messages with the word trace in the title. Include HTTP context in ASP.NET and ASP.NET Core When logging through NLog from a web application, you may want to include HTTP contextual information like the current URL, status codes, server variables, etc. NLog provides two web-packages to include this information. For ASP.NET, MVC, and Web API you can install the NLog.Web NuGet package and include the following code in web.config : <system.webServer> <modules runAllManagedModulesForAllRequests=\"true\"> <add name=\"NLog\" type=\"NLog.Web.NLogHttpModule, NLog.Web\" /> </modules> </system.webServer> For ASP.NET Core you can install the NLog.Web.AspNetCore NuGet package. When installed, the elmah.io NLog target automatically picks up the HTTP context and fill in all possible fields on messages sent to elmah.io. Troubleshooting Here are some things to try out if logging from NLog to elmah.io doesn't work: Make sure that you have the newest Elmah.Io.NLog and Elmah.Io.Client packages installed. Make sure to include all of the configuration from the example above. That includes both the <extensions> , <targets> , and <rules> element. Make sure that the API key is valid and allow the Messages | Write permission . Make sure to include a valid log ID. Make sure that you have sufficient log messages in your subscription and that you didn't disable logging to the log or include any ignore filters/rules. Always make sure to call LogManager.Shutdown() before exiting the application to make sure that all log messages are flushed. Extend the nlog element with internalLogLevel=\"Warn\" internalLogFile=\"c:\\temp\\nlog-internal.log and inspect that log file for any internal NLog errors.","title":"Logging from NLog"},{"location":"logging-to-elmah-io-from-nlog/#logging-to-elmahio-from-nlog","text":"Logging to elmah.io from NLog Configuration in .NET Specify API key and log ID in appSettings Setting application name IntelliSense Configuration in .NET Core elmah.io configuration outside the NLog section IntelliSense Configuration in code Logging custom properties Message hooks Decorating log messages Handle errors Error filtering Include HTTP context in ASP.NET and ASP.NET Core Troubleshooting NLog is one of the most popular logging frameworks for .NET. With an active history of almost 10 years, the possibilities with NLog are many and it\u2019s easy to find documentation on how to use it. To start logging messages from NLog to elmah.io, you need to install the Elmah.Io.NLog NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.NLog dotnet add package Elmah.Io.NLog <PackageReference Include=\"Elmah.Io.NLog\" Version=\"3.*\" /> paket add Elmah.Io.NLog Please don't use NLog 4.6.0 since that version contains a bug that causes the elmah.io target to not load correctly. 4.5.11 , 4.6.1 , or newer.","title":"Logging to elmah.io from NLog"},{"location":"logging-to-elmah-io-from-nlog/#configuration-in-net","text":"To configure the elmah.io target, add the following configuration to your app.config/web.config/nlog.config depending on what kind of project you\u2019ve created: <extensions> <add assembly=\"Elmah.Io.NLog\"/> </extensions> <targets> <target name=\"elmahio\" type=\"elmah.io\" apiKey=\"API_KEY\" logId=\"LOG_ID\"/> </targets> <rules> <logger name=\"*\" minlevel=\"Info\" writeTo=\"elmahio\" /> </rules> Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). In the example we specify the level minimum as Info. This tells NLog to log only information, warning, error and fatal messages. You may adjust this, but be aware that your elmah.io log may run full pretty fast, especially if you log thousands and thousands of trace and debug messages. Log messages to elmah.io, just as with every other target and NLog: log.Warn(\"This is a warning message\"); log.Error(new Exception(), \"This is an error message\");","title":"Configuration in .NET"},{"location":"logging-to-elmah-io-from-nlog/#specify-api-key-and-log-id-in-appsettings","text":"If you are already using elmah.io, you may have your API key and log ID in the appSettings element already. To use these settings from withing the NLog target configuration you can use an NLog layout formatter: <targets> <target name=\"elmahio\" type=\"elmah.io\" apiKey=\"${appsetting:item=apiKey}\" logId=\"${appsetting:item=logId}\"/> </targets> By using the layout ${appsetting:item=apiKey} you tell NLog that the value for this attribute is in an appSettings element named elmahKey : <appSettings> <add key=\"apiKey\" value=\"API_KEY\" /> <add key=\"logId\" value=\"LOG_ID\" /> </appSettings> The appSettings layout formatter only works when targeting .NET Full Framework and requires Elmah.Io.NLog version 3.3.x or above and NLog version 4.6.x or above.","title":"Specify API key and log ID in appSettings"},{"location":"logging-to-elmah-io-from-nlog/#setting-application-name","text":"The application field on elmah.io can be set globally through NLog config: <targets> <target name=\"elmahio\" xsi:type=\"elmahio:elmah.io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" application=\"APP_NAME\" /> </targets> Replace APP_NAME with the application you want logged to elmah.io","title":"Setting application name"},{"location":"logging-to-elmah-io-from-nlog/#intellisense","text":"There is support for adding IntelliSense in Visual Studio for the NLog.config file. Extend the nlog root element like this: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:elmahio=\"http://www.nlog-project.org/schemas/NLog.Targets.Elmah.Io.xsd\" xsi:schemaLocation=\"http://www.nlog-project.org/schemas/NLog.Targets.Elmah.Io.xsd http://www.nlog-project.org/schemas/NLog.Targets.Elmah.Io.xsd\"> <!-- ... --> </nlog>","title":"IntelliSense"},{"location":"logging-to-elmah-io-from-nlog/#configuration-in-net-core","text":".NET Core switched from declaring XML configuration in app/web/nlog.config files to JSON configuration in an appsettings.json file. To configure elmah.io in JSON, install the NLog.Extensions.Logging NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package NLog.Extensions.Logging dotnet add package NLog.Extensions.Logging <PackageReference Include=\"NLog.Extensions.Logging\" Version=\"1.*\" /> paket add NLog.Extensions.Logging Extend the appsettings.json file with a new NLog section: { \"NLog\": { \"throwConfigExceptions\": true, \"extensions\": [ { \"assembly\": \"Elmah.Io.NLog\" } ], \"targets\": { \"elmahio\": { \"type\": \"elmah.io\", \"apiKey\": \"API_KEY\", \"logId\": \"LOG_ID\" } }, \"rules\": [ { \"logger\": \"*\", \"minLevel\": \"Info\", \"writeTo\": \"elmahio\" } ] } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). If you haven't already loaded the configuration in your application, make sure to do so: var config = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .Build(); Finally, tell NLog how to load the NLog configuration section: LogManager.Configuration = new NLogLoggingConfiguration(config.GetSection(\"NLog\"));","title":"Configuration in .NET Core"},{"location":"logging-to-elmah-io-from-nlog/#elmahio-configuration-outside-the-nlog-section","text":"You might not want the elmah.io API key and log Id inside the NLog section or already have an ElmahIo section defined and want to reuse that. Splitting up configuration like that is supported through NLog layout renderers: { \"NLog\": { // ... \"targets\": { \"elmahio\": { \"type\": \"elmah.io\", \"apiKey\": \"${configsetting:item=ElmahIo.ApiKey}\", \"logId\": \"${configsetting:item=ElmahIo.LogId}\" } }, // ... }, \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Notice how the value of the apiKey and logId parameters have been replaced with ${configsetting:item=ElmahIo.*} . In the bottom the ElmahIo section wrap the API key and log Id. To make this work, you will need an additional line of C# when setting up NLog logging: var config = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true) .Build(); ConfigSettingLayoutRenderer.DefaultConfiguration = config; // \ud83d\udc48 add this line LogManager.Configuration = new NLogLoggingConfiguration(config.GetSection(\"NLog\"));","title":"elmah.io configuration outside the NLog section"},{"location":"logging-to-elmah-io-from-nlog/#intellisense_1","text":"There is support for adding IntelliSense in Visual Studio for the NLog section in the appsettings.json file. Copy and paste the following link into the Schema textbox above the file content: https://nlog-project.org/schemas/appsettings.schema.json","title":"IntelliSense"},{"location":"logging-to-elmah-io-from-nlog/#configuration-in-code","text":"The elmah.io target can be configured from C# code if you prefer or need to access the built-in events (see more later). The following adds logging to elmah.io: var config = new LoggingConfiguration(); var elmahIoTarget = new ElmahIoTarget(); elmahIoTarget.Name = \"elmahio\"; elmahIoTarget.ApiKey = \"API_KEY\"; elmahIoTarget.LogId = \"LOG_ID\"; config.AddTarget(elmahIoTarget); config.AddRuleForAllLevels(elmahIoTarget); LogManager.Configuration = config; The example will log all log levels to elmah.io. For more information about how to configure individual log levels, check out the NLog documentation on GitHub .","title":"Configuration in code"},{"location":"logging-to-elmah-io-from-nlog/#logging-custom-properties","text":"NLog supports logging custom properties in multiple ways. If you want to include a property (like a version number) to all log messages, you might want to look into the OnMessage feature on Elmah.Io.NLog . With custom properties, you can log additional key/value pairs with every log message. The elmah.io target for NLog supports custom properties as well. Properties are persisted alongside every log message in elmah.io and searchable if named correctly . One way to log custom properties with NLog and elmah.io is to use the overload of each logging-method that takes a LogEventInfo object as a parameter: var infoMessage = new LogEventInfo(LogLevel.Info, \"\", \"This is an information message\"); infoMessage.Properties.Add(\"Some Property Key\", \"Some Property Value\"); log.Info(infoMessage); This saves the information message in elmah.io with a custom property with key Some Property Key and value Some Property Value . As of NLog 4.5, structured logging is supported as well. To log a property as part of the log message, use the new syntax as shown here: log.Warn(\"Property named {FirstName}\", \"Donald\"); In the example, NLog will log the message Property named \"Donald\" , but the key ( FirstName ) and value ( Donald ), will also be available in the Data tab inside elmah.io. Elmah.Io.NLog provides a range of reserved property names, that can be used to fill in data in the correct fields on the elmah.io UI. Let's say you want to fill the User field using structured logging only: log.Info(\"{Quote} from {User}\", \"Hasta la vista, baby\", \"T-800\"); This will fill in the value T-800 in the User field, as well as add two key/value pairs ( Quote and User ) to the Data tab on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage . NLog also provides a fluent API (available in the NLog.Fluent namespace) that some might find more readable: logger.Info() .Message(\"I'll be back\") .Property(\"User\", \"T-800\") .Write(); If you want to use the normal logging methods like Info and Error , you can do so injunction with the MappedDiagnosticsLogicalContext class, also provided by NLog: using (MappedDiagnosticsLogicalContext.SetScoped(\"User\", \"T-800\")) { logger.Info(\"I'll be back\"); } This will create the same result as the example above.","title":"Logging custom properties"},{"location":"logging-to-elmah-io-from-nlog/#message-hooks","text":"Elmah.Io.NLog provides message hooks similar to the integrations with ASP.NET and ASP.NET Core. Message hooks need to be implemented in C#. Either configure the elmah.io target in C# or fetch the target already configured in XML: var elmahIoTarget = (ElmahIoTarget)LogManager.Configuration.FindTargetByName(\"elmahio\"); You also need to install the most recent version of the Elmah.Io.Client NuGet package to use message hooks.","title":"Message hooks"},{"location":"logging-to-elmah-io-from-nlog/#decorating-log-messages","text":"To include additional information on log messages, you can use the OnMessage action: elmahIoTarget.OnMessage = msg => { msg.Version = \"1.0.0\"; }; The example above includes a version number on all errors.","title":"Decorating log messages"},{"location":"logging-to-elmah-io-from-nlog/#handle-errors","text":"To handle any errors happening while processing a log message, you can use the OnError event when initializing the elmah.io target: elmahIoTarget.OnError = (msg, err) => { // Do something here }; The example implements a callback if logging to elmah.io fails. How you choose to implement this is entirely up to your application and tech stack.","title":"Handle errors"},{"location":"logging-to-elmah-io-from-nlog/#error-filtering","text":"To ignore specific errors based on their content, you can use the OnFilter event when initializing the elmah.io target: elmahIoTarget.OnFilter = msg => { return msg.Title.Contains(\"trace\"); }; The example above ignores any log messages with the word trace in the title.","title":"Error filtering"},{"location":"logging-to-elmah-io-from-nlog/#include-http-context-in-aspnet-and-aspnet-core","text":"When logging through NLog from a web application, you may want to include HTTP contextual information like the current URL, status codes, server variables, etc. NLog provides two web-packages to include this information. For ASP.NET, MVC, and Web API you can install the NLog.Web NuGet package and include the following code in web.config : <system.webServer> <modules runAllManagedModulesForAllRequests=\"true\"> <add name=\"NLog\" type=\"NLog.Web.NLogHttpModule, NLog.Web\" /> </modules> </system.webServer> For ASP.NET Core you can install the NLog.Web.AspNetCore NuGet package. When installed, the elmah.io NLog target automatically picks up the HTTP context and fill in all possible fields on messages sent to elmah.io.","title":"Include HTTP context in ASP.NET and ASP.NET Core"},{"location":"logging-to-elmah-io-from-nlog/#troubleshooting","text":"Here are some things to try out if logging from NLog to elmah.io doesn't work: Make sure that you have the newest Elmah.Io.NLog and Elmah.Io.Client packages installed. Make sure to include all of the configuration from the example above. That includes both the <extensions> , <targets> , and <rules> element. Make sure that the API key is valid and allow the Messages | Write permission . Make sure to include a valid log ID. Make sure that you have sufficient log messages in your subscription and that you didn't disable logging to the log or include any ignore filters/rules. Always make sure to call LogManager.Shutdown() before exiting the application to make sure that all log messages are flushed. Extend the nlog element with internalLogLevel=\"Warn\" internalLogFile=\"c:\\temp\\nlog-internal.log and inspect that log file for any internal NLog errors.","title":"Troubleshooting"},{"location":"logging-to-elmah-io-from-orchard/","text":"Logging to elmah.io from Orchard CMS Orchard CMS is a free, open source community-focused content management system built on the ASP.NET MVC and ASP.NET Core platforms. This tutorial is written for the ASP.NET Core version of Orchard. If you want to log to elmah.io from the MVC version, you should follow our tutorial for MVC . To start logging to elmah.io, install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Install the Elmah.Io.AspNetCore NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore dotnet add package Elmah.Io.AspNetCore <PackageReference Include=\"Elmah.Io.AspNetCore\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore Then modify your Startup.cs file: public class Startup { public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); }); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... app.UseElmahIo(); // ... } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the id of the log ( Where is my log ID? ) where you want errors logged. Like with any other ASP.NET Core application, it's important to call the UseElmahIo -method after setting up other middleware handling exceptions (like UseDeveloperExceptionPage ). Orchard uses NLog as the internal logging framework. Hooking into this pipeline is a great way to log warnings and errors through NLog to elmah.io as well. Install the Elmah.Io.Nlog NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.NLog dotnet add package Elmah.Io.NLog <PackageReference Include=\"Elmah.Io.NLog\" Version=\"3.*\" /> paket add Elmah.Io.NLog Add the elmah.io target to the NLog.config -file: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog> <extensions> <!-- ... --> <add assembly=\"Elmah.Io.NLog\"/> </extensions> <targets> <!-- ... --> <target name=\"elmahio\" type=\"elmah.io\" apiKey=\"API_KEY\" logId=\"LOG_ID\"/> </targets> <rules> <!-- ... --> <logger name=\"*\" minlevel=\"Warn\" writeTo=\"elmahio\" /> </rules> </nlog> Make sure not to log Trace and Debug messages to elmah.io, which will quickly use up the included storage.","title":"Logging from Orchard"},{"location":"logging-to-elmah-io-from-orchard/#logging-to-elmahio-from-orchard-cms","text":"Orchard CMS is a free, open source community-focused content management system built on the ASP.NET MVC and ASP.NET Core platforms. This tutorial is written for the ASP.NET Core version of Orchard. If you want to log to elmah.io from the MVC version, you should follow our tutorial for MVC . To start logging to elmah.io, install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Install the Elmah.Io.AspNetCore NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore dotnet add package Elmah.Io.AspNetCore <PackageReference Include=\"Elmah.Io.AspNetCore\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore Then modify your Startup.cs file: public class Startup { public void ConfigureServices(IServiceCollection services) { // ... services.AddElmahIo(o => { o.ApiKey = \"API_KEY\"; o.LogId = new Guid(\"LOG_ID\"); }); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... app.UseElmahIo(); // ... } } Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the id of the log ( Where is my log ID? ) where you want errors logged. Like with any other ASP.NET Core application, it's important to call the UseElmahIo -method after setting up other middleware handling exceptions (like UseDeveloperExceptionPage ). Orchard uses NLog as the internal logging framework. Hooking into this pipeline is a great way to log warnings and errors through NLog to elmah.io as well. Install the Elmah.Io.Nlog NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.NLog dotnet add package Elmah.Io.NLog <PackageReference Include=\"Elmah.Io.NLog\" Version=\"3.*\" /> paket add Elmah.Io.NLog Add the elmah.io target to the NLog.config -file: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog> <extensions> <!-- ... --> <add assembly=\"Elmah.Io.NLog\"/> </extensions> <targets> <!-- ... --> <target name=\"elmahio\" type=\"elmah.io\" apiKey=\"API_KEY\" logId=\"LOG_ID\"/> </targets> <rules> <!-- ... --> <logger name=\"*\" minlevel=\"Warn\" writeTo=\"elmahio\" /> </rules> </nlog> Make sure not to log Trace and Debug messages to elmah.io, which will quickly use up the included storage.","title":"Logging to elmah.io from Orchard CMS"},{"location":"logging-to-elmah-io-from-powershell/","text":"Logging to elmah.io from PowerShell In order for you to be able to log to elmah.io from PowerShell, you will need the elmah.io.client NuGet package. This package contains the raw client libraries for communicating with the elmah.io API . First of all, you will need to include elmah.io.client.dll in your PowerShell script. How you do this is entirely up to you of course. You can place this assembly with your script or you can download it through NuGet on every execution. To download the elmah.io.client package through NuGet, you will need nuget.exe : $source = \"https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\" $target = \".\\nuget.exe\" Invoke-WebRequest $source -OutFile $target Set-Alias nuget $target -Scope Global This script will download the latest version of the NuGet command line tool and make it available through the command nuget . To install elmah.io.client, run nuget.exe : nuget install Elmah.Io.Client This will create a Elmah.Io.Client-version folder containing the latest stable version of the elmah.io.client package. Since you probably don't want to hardcode the path to the current version number, reference Elmah.Io.Client.dll and its dependencies using Get-ChildItem and a bit of recursive magic: $elmahIoClientPath = Get-ChildItem -Path . -Filter Elmah.Io.Client.dll -Recurse ` | Where-Object {$_.FullName -match \"net45\"} [Reflection.Assembly]::LoadFile($elmahIoClientPath.FullName) $restClientPath = Get-ChildItem -Path . -Filter Microsoft.Rest.ClientRuntime.dll -Recurse ` | Where-Object {$_.FullName -match \"net45\"} [Reflection.Assembly]::LoadFile($restClientPath.FullName) $jsonNetPath = Get-ChildItem -Path . -Filter Newtonsoft.Json.dll -Recurse ` | Where-Object {$_.FullName -match \"net45\" -and $_.FullName -notmatch \"portable\"} [Reflection.Assembly]::LoadFile($jsonNetPath.FullName) You now have Elmah.Io.Client.dll loaded into your shell and everything is set up in order to log to elmah.io. To do so, add try-catch around critical code: $logger = [Elmah.Io.Client.ElmahioAPI]::Create(\"API_KEY\") Try { # some code that may throw exceptions } Catch { $logger.Messages.Error([guid]::new(\"LOG_ID\"), $_.Exception, \"Oh no\") } In the first line, we create a new logger object with the API_KEY of the subscription we want to use ( Where is my API key? ). Then, in the Catch block, the catched exception is shipped off to the elmah.io log specified in LOG_ID ( Where is my log ID? ) together with a custom message.","title":"Logging from PowerShell"},{"location":"logging-to-elmah-io-from-powershell/#logging-to-elmahio-from-powershell","text":"In order for you to be able to log to elmah.io from PowerShell, you will need the elmah.io.client NuGet package. This package contains the raw client libraries for communicating with the elmah.io API . First of all, you will need to include elmah.io.client.dll in your PowerShell script. How you do this is entirely up to you of course. You can place this assembly with your script or you can download it through NuGet on every execution. To download the elmah.io.client package through NuGet, you will need nuget.exe : $source = \"https://dist.nuget.org/win-x86-commandline/latest/nuget.exe\" $target = \".\\nuget.exe\" Invoke-WebRequest $source -OutFile $target Set-Alias nuget $target -Scope Global This script will download the latest version of the NuGet command line tool and make it available through the command nuget . To install elmah.io.client, run nuget.exe : nuget install Elmah.Io.Client This will create a Elmah.Io.Client-version folder containing the latest stable version of the elmah.io.client package. Since you probably don't want to hardcode the path to the current version number, reference Elmah.Io.Client.dll and its dependencies using Get-ChildItem and a bit of recursive magic: $elmahIoClientPath = Get-ChildItem -Path . -Filter Elmah.Io.Client.dll -Recurse ` | Where-Object {$_.FullName -match \"net45\"} [Reflection.Assembly]::LoadFile($elmahIoClientPath.FullName) $restClientPath = Get-ChildItem -Path . -Filter Microsoft.Rest.ClientRuntime.dll -Recurse ` | Where-Object {$_.FullName -match \"net45\"} [Reflection.Assembly]::LoadFile($restClientPath.FullName) $jsonNetPath = Get-ChildItem -Path . -Filter Newtonsoft.Json.dll -Recurse ` | Where-Object {$_.FullName -match \"net45\" -and $_.FullName -notmatch \"portable\"} [Reflection.Assembly]::LoadFile($jsonNetPath.FullName) You now have Elmah.Io.Client.dll loaded into your shell and everything is set up in order to log to elmah.io. To do so, add try-catch around critical code: $logger = [Elmah.Io.Client.ElmahioAPI]::Create(\"API_KEY\") Try { # some code that may throw exceptions } Catch { $logger.Messages.Error([guid]::new(\"LOG_ID\"), $_.Exception, \"Oh no\") } In the first line, we create a new logger object with the API_KEY of the subscription we want to use ( Where is my API key? ). Then, in the Catch block, the catched exception is shipped off to the elmah.io log specified in LOG_ID ( Where is my log ID? ) together with a custom message.","title":"Logging to elmah.io from PowerShell"},{"location":"logging-to-elmah-io-from-serilog/","text":"Logging to elmah.io from Serilog Logging to elmah.io from Serilog Logging custom properties Message hooks Decorating log messages Handle errors Error filtering ASP.NET Core Config using appsettings.json Extended exception details with Serilog.Exceptions Remove sensitive data Serilog is a great addition to the flowering .NET logging community, described as \u201cA no-nonsense logging library for the NoSQL era\u201d on their project page. Serilog works just like other logging frameworks such as log4net and NLog, but offers a great fluent API and the concept of sinks (a bit like appenders in log4net). Sinks are superior to appenders, because they threat errors as objects rather than strings, a perfect fit for elmah.io which itself is built on NoSQL. Serilog already comes with native support for elmah.io, which makes it easy to integrate with any application using Serilog. In this example we\u2019ll use a ASP.NET MVC project as an example. Neither Serilog nor elmah.io are bound to log errors from web applications. Adding this type of logging to your windows and console applications is just as easy. Add the Serilog.Sinks.ElmahIo NuGet package to your project: Package Manager .NET CLI PackageReference Paket CLI Install-Package Serilog.Sinks.ElmahIo dotnet add package Serilog.Sinks.ElmahIo <PackageReference Include=\"Serilog.Sinks.ElmahIo\" Version=\"3.*\" /> paket add Serilog.Sinks.ElmahIo To configure Serilog, add the following code to the Application_Start method in global.asax.cs: var log = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\"))) .CreateLogger(); Log.Logger = log; Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). First, we create a new LoggerConfiguration and tell it to write to elmah.io. The log object can be used to log errors and you should register this in your IoC container. In this case, we don\u2019t use IoC, that is why the log object is set as the public static Logger property, which makes it accessible from everywhere. To log log exceptions to elmah.io through Serilog, is the Log class provided by Serilog: try { // Do some stuff which may cause an exception } catch (Exception e) { Log.Error(e, \"The actual error message\"); } The Error method tells Serilog to log the error in the configured sinks, which in our case logs to elmah.io. Simple and beautiful. Always call Log.CloseAndFlush(); before your program terminates. Logging custom properties Serilog support logging custom properties in three ways: As part of the log message, through enrichers and using LogContext . All three types of properties are implemented in the elmah.io sink as part of the Data dictionary to elmah.io. The following example shows how to log all three types of properties: var logger = new LoggerConfiguration() .Enrich.WithProperty(\"ApplicationIdentifier\", \"MyCoolApp\") .Enrich.FromLogContext() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\"))) .CreateLogger(); using (LogContext.PushProperty(\"ThreadId\", Thread.CurrentThread.ManagedThreadId)) { logger.Error(\"This is a message with {Type} properties\", \"custom\"); } Beneath the Data tab on the logged message details, the ApplicationIdentifier , ThreadId and Type properties can be found. Serilog.Sinks.ElmahIo provides a range of reserved property names, that can be used to fill in data in the correct fields on the elmah.io UI. Let's say you want to fill the User field using structured logging only: logger.Information(\"{Quote} from {User}\", \"Hasta la vista, baby\", \"Arnold Schwarzenegger\"); This will fill in the value Arnold Schwarzenegger in the User field, as well as add two key/value pairs (Quote and User) to the Data tab on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage . Message hooks Serilog.Sinks.ElmahIo provide message hooks similar to the integrations with ASP.NET and ASP.NET Core. Message hooks require Serilog.Sinks.ElmahIo version 3.3.0 or newer. Decorating log messages To include additional information on log messages, you can use the OnMessage event when initializing the elmah.io target: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { OnMessage = msg => { msg.Version = \"1.0.0\"; } }) .CreateLogger(); The example above includes a version number on all errors. Since the elmah.io sink also picks up encrichers specified with Serilog, this example could be implemented by enriching all log messages with a field named version . Handle errors To handle any errors happening while processing a log message, you can use the OnError event when initializing the elmah.io sink: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { OnError = (msg, ex) => { Console.Error.WriteLine(ex.Message); } }) .CreateLogger(); The example implements a callback if logging to elmah.io fails. How you choose to implement this is entirely up to your application and tech stack. Error filtering To ignore specific messages based on their content, you can use the OnFilter event when initializing the elmah.io sink: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { OnFilter = msg => { return msg.Title.Contains(\"trace\"); } }) .CreateLogger(); The example above ignores any log message with the word trace in the title. ASP.NET Core Serilog provides a package for ASP.NET Core, that routes log messages from inside core through Serilog. We recommend to use this package together with the elmah.io sink, in order to capture warnings and errors happening inside ASP.NET Core. To use this, install the following packages: Package Manager .NET CLI PackageReference Paket CLI Install-Package Serilog.AspNetCore Install-Package Serilog.Sinks.ElmahIo dotnet add package Serilog.AspNetCore dotnet add package Serilog.Sinks.ElmahIo <PackageReference Include=\"Serilog.AspNetCore\" Version=\"3.*\" /> <PackageReference Include=\"Serilog.Sinks.ElmahIo\" Version=\"3.*\" /> paket add Serilog.AspNetCore paket add Serilog.Sinks.ElmahIo Configure Serilog as usual: public static int Main(string[] args) { Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { MinimumLogEventLevel = Events.LogEventLevel.Warning }) .CreateLogger(); try { CreateWebHostBuilder(args).Build().Run(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly\"); return 1; } finally { Log.CloseAndFlush(); } } Finally, call the UseSerilog -method in BuildWebHost : public static IWebHost BuildWebHost(string[] args) => WebHost .CreateDefaultBuilder(args) .UseStartup<Startup>() .UseSerilog(); Now, all warnings, errors and fatals happening inside ASP.NET Core are logged to elmah.io. A common request is to include all of the HTTP contextual information you usually get logged when using a package like Elmah.Io.AspNetCore . We have developed a specialized NuGet package to include cookies, server variables, etc. when logging through Serilog from ASP.NET Core. To set it up, install the Elmah.Io.AspNetCore.Serilog NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.Serilog dotnet add package Elmah.Io.AspNetCore.Serilog <PackageReference Include=\"Elmah.Io.AspNetCore.Serilog\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.Serilog Then, call the UseElmahIoSerilog method in the Configure method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // ... Exception handling middleware app.UseElmahIoSerilog(); // ... UseMvc etc. } The middleware uses Serilog's LogContext feature to enrich each log message with additional properties. To turn on the log context, extend your Serilog config: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(/*...*/) .Enrich.FromLogContext() // <-- add this line .CreateLogger(); Config using appsettings.json While Serilog provides a great fluent C# API, some prefer to configure Serilog using an appsettings.json file. To configure the elmah.io sink this way, you will need to install the Serilog.Settings.Configuration NuGet package. Then configure elmah.io in your appsettings.json file: { // ... \"Serilog\":{ \"Using\":[ \"Serilog.Sinks.ElmahIo\" ], \"MinimumLevel\": \"Warning\", \"WriteTo\":[ { \"Name\": \"ElmahIo\", \"Args\":{ \"apiKey\": \"API_KEY\", \"logId\": \"LOG_ID\" } } ] } } Make sure to specify the apiKey and logId arguments with the first character in lowercase. Finally, tell Serilog to read the configuration from the appsettings.json file: var configuration = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\") .Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger(); Extended exception details with Serilog.Exceptions The more information you have on an error, the easier it is to find out what went wrong. Muhammad Rehan Saeed made a nice enrichment package for Serilog named Serilog.Exceptions . The package uses reflection on a logged exception to log additional information depending on the concrete exception type. You can install the package through NuGet: Package Manager .NET CLI PackageReference Paket CLI Install-Package Serilog.Exceptions dotnet add package Serilog.Exceptions <PackageReference Include=\"Serilog.Exceptions\" Version=\"5.*\" /> paket add Serilog.Exceptions And configure it in C# code: var logger = new LoggerConfiguration() .Enrich.WithExceptionDetails() .WriteTo.ElmahIo(/*...*/) .CreateLogger(); The elmah.io sink will automatically pick up the additional information and show them in the extended message details overlay. To navigate to this view, click an error on the search view. Then click the button in the upper right corner to open extended message details. The information logged by Serilog.Exceptions are available beneath the Data tab. Remove sensitive data Structured logging with Serilog is a great way to store a lot of contextual information about a log message. In some cases, it may result in sensitive data being stored in your log, though. We recommend you to remove any sensitive data from your log messages before storing them on elmah.io and anywhere else. To implement this, you can use the OnMessage event as already shown previously in the document: OnMessage = msg => { foreach (var d in msg.Data) { if (d.Key.Equals(\"Password\")) { d.Value = \"****\"; } } } An alternative to replacing sensitive values manually is to use a custom destructuring package for Serilog. The following example shows how to achieve this using the Destructurama.Attributed package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Destructurama.Attributed dotnet add package Destructurama.Attributed <PackageReference Include=\"Destructurama.Attributed\" Version=\"2.*\" /> paket add Destructurama.Attributed Set up destructuring from attributes: Log.Logger = new LoggerConfiguration() .Destructure.UsingAttributes() .WriteTo.ElmahIo(/*...*/) .CreateLogger(); Make sure to decorate any properties including sensitive data with the NotLogged attribute: public class LoginModel { public string Username { get; set; } [NotLogged] public string Password { get; set; } }","title":"Logging from Serilog"},{"location":"logging-to-elmah-io-from-serilog/#logging-to-elmahio-from-serilog","text":"Logging to elmah.io from Serilog Logging custom properties Message hooks Decorating log messages Handle errors Error filtering ASP.NET Core Config using appsettings.json Extended exception details with Serilog.Exceptions Remove sensitive data Serilog is a great addition to the flowering .NET logging community, described as \u201cA no-nonsense logging library for the NoSQL era\u201d on their project page. Serilog works just like other logging frameworks such as log4net and NLog, but offers a great fluent API and the concept of sinks (a bit like appenders in log4net). Sinks are superior to appenders, because they threat errors as objects rather than strings, a perfect fit for elmah.io which itself is built on NoSQL. Serilog already comes with native support for elmah.io, which makes it easy to integrate with any application using Serilog. In this example we\u2019ll use a ASP.NET MVC project as an example. Neither Serilog nor elmah.io are bound to log errors from web applications. Adding this type of logging to your windows and console applications is just as easy. Add the Serilog.Sinks.ElmahIo NuGet package to your project: Package Manager .NET CLI PackageReference Paket CLI Install-Package Serilog.Sinks.ElmahIo dotnet add package Serilog.Sinks.ElmahIo <PackageReference Include=\"Serilog.Sinks.ElmahIo\" Version=\"3.*\" /> paket add Serilog.Sinks.ElmahIo To configure Serilog, add the following code to the Application_Start method in global.asax.cs: var log = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\"))) .CreateLogger(); Log.Logger = log; Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with the ID of the log you want messages sent to ( Where is my log ID? ). First, we create a new LoggerConfiguration and tell it to write to elmah.io. The log object can be used to log errors and you should register this in your IoC container. In this case, we don\u2019t use IoC, that is why the log object is set as the public static Logger property, which makes it accessible from everywhere. To log log exceptions to elmah.io through Serilog, is the Log class provided by Serilog: try { // Do some stuff which may cause an exception } catch (Exception e) { Log.Error(e, \"The actual error message\"); } The Error method tells Serilog to log the error in the configured sinks, which in our case logs to elmah.io. Simple and beautiful. Always call Log.CloseAndFlush(); before your program terminates.","title":"Logging to elmah.io from Serilog"},{"location":"logging-to-elmah-io-from-serilog/#logging-custom-properties","text":"Serilog support logging custom properties in three ways: As part of the log message, through enrichers and using LogContext . All three types of properties are implemented in the elmah.io sink as part of the Data dictionary to elmah.io. The following example shows how to log all three types of properties: var logger = new LoggerConfiguration() .Enrich.WithProperty(\"ApplicationIdentifier\", \"MyCoolApp\") .Enrich.FromLogContext() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\"))) .CreateLogger(); using (LogContext.PushProperty(\"ThreadId\", Thread.CurrentThread.ManagedThreadId)) { logger.Error(\"This is a message with {Type} properties\", \"custom\"); } Beneath the Data tab on the logged message details, the ApplicationIdentifier , ThreadId and Type properties can be found. Serilog.Sinks.ElmahIo provides a range of reserved property names, that can be used to fill in data in the correct fields on the elmah.io UI. Let's say you want to fill the User field using structured logging only: logger.Information(\"{Quote} from {User}\", \"Hasta la vista, baby\", \"Arnold Schwarzenegger\"); This will fill in the value Arnold Schwarzenegger in the User field, as well as add two key/value pairs (Quote and User) to the Data tab on elmah.io. For a reference of all possible property names, check out the property names on CreateMessage .","title":"Logging custom properties"},{"location":"logging-to-elmah-io-from-serilog/#message-hooks","text":"Serilog.Sinks.ElmahIo provide message hooks similar to the integrations with ASP.NET and ASP.NET Core. Message hooks require Serilog.Sinks.ElmahIo version 3.3.0 or newer.","title":"Message hooks"},{"location":"logging-to-elmah-io-from-serilog/#decorating-log-messages","text":"To include additional information on log messages, you can use the OnMessage event when initializing the elmah.io target: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { OnMessage = msg => { msg.Version = \"1.0.0\"; } }) .CreateLogger(); The example above includes a version number on all errors. Since the elmah.io sink also picks up encrichers specified with Serilog, this example could be implemented by enriching all log messages with a field named version .","title":"Decorating log messages"},{"location":"logging-to-elmah-io-from-serilog/#handle-errors","text":"To handle any errors happening while processing a log message, you can use the OnError event when initializing the elmah.io sink: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { OnError = (msg, ex) => { Console.Error.WriteLine(ex.Message); } }) .CreateLogger(); The example implements a callback if logging to elmah.io fails. How you choose to implement this is entirely up to your application and tech stack.","title":"Handle errors"},{"location":"logging-to-elmah-io-from-serilog/#error-filtering","text":"To ignore specific messages based on their content, you can use the OnFilter event when initializing the elmah.io sink: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { OnFilter = msg => { return msg.Title.Contains(\"trace\"); } }) .CreateLogger(); The example above ignores any log message with the word trace in the title.","title":"Error filtering"},{"location":"logging-to-elmah-io-from-serilog/#aspnet-core","text":"Serilog provides a package for ASP.NET Core, that routes log messages from inside core through Serilog. We recommend to use this package together with the elmah.io sink, in order to capture warnings and errors happening inside ASP.NET Core. To use this, install the following packages: Package Manager .NET CLI PackageReference Paket CLI Install-Package Serilog.AspNetCore Install-Package Serilog.Sinks.ElmahIo dotnet add package Serilog.AspNetCore dotnet add package Serilog.Sinks.ElmahIo <PackageReference Include=\"Serilog.AspNetCore\" Version=\"3.*\" /> <PackageReference Include=\"Serilog.Sinks.ElmahIo\" Version=\"3.*\" /> paket add Serilog.AspNetCore paket add Serilog.Sinks.ElmahIo Configure Serilog as usual: public static int Main(string[] args) { Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(new ElmahIoSinkOptions(\"API_KEY\", new Guid(\"LOG_ID\")) { MinimumLogEventLevel = Events.LogEventLevel.Warning }) .CreateLogger(); try { CreateWebHostBuilder(args).Build().Run(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly\"); return 1; } finally { Log.CloseAndFlush(); } } Finally, call the UseSerilog -method in BuildWebHost : public static IWebHost BuildWebHost(string[] args) => WebHost .CreateDefaultBuilder(args) .UseStartup<Startup>() .UseSerilog(); Now, all warnings, errors and fatals happening inside ASP.NET Core are logged to elmah.io. A common request is to include all of the HTTP contextual information you usually get logged when using a package like Elmah.Io.AspNetCore . We have developed a specialized NuGet package to include cookies, server variables, etc. when logging through Serilog from ASP.NET Core. To set it up, install the Elmah.Io.AspNetCore.Serilog NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.AspNetCore.Serilog dotnet add package Elmah.Io.AspNetCore.Serilog <PackageReference Include=\"Elmah.Io.AspNetCore.Serilog\" Version=\"3.*\" /> paket add Elmah.Io.AspNetCore.Serilog Then, call the UseElmahIoSerilog method in the Configure method in the Startup.cs file: public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // ... Exception handling middleware app.UseElmahIoSerilog(); // ... UseMvc etc. } The middleware uses Serilog's LogContext feature to enrich each log message with additional properties. To turn on the log context, extend your Serilog config: Log.Logger = new LoggerConfiguration() .WriteTo.ElmahIo(/*...*/) .Enrich.FromLogContext() // <-- add this line .CreateLogger();","title":"ASP.NET Core"},{"location":"logging-to-elmah-io-from-serilog/#config-using-appsettingsjson","text":"While Serilog provides a great fluent C# API, some prefer to configure Serilog using an appsettings.json file. To configure the elmah.io sink this way, you will need to install the Serilog.Settings.Configuration NuGet package. Then configure elmah.io in your appsettings.json file: { // ... \"Serilog\":{ \"Using\":[ \"Serilog.Sinks.ElmahIo\" ], \"MinimumLevel\": \"Warning\", \"WriteTo\":[ { \"Name\": \"ElmahIo\", \"Args\":{ \"apiKey\": \"API_KEY\", \"logId\": \"LOG_ID\" } } ] } } Make sure to specify the apiKey and logId arguments with the first character in lowercase. Finally, tell Serilog to read the configuration from the appsettings.json file: var configuration = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\") .Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger();","title":"Config using appsettings.json"},{"location":"logging-to-elmah-io-from-serilog/#extended-exception-details-with-serilogexceptions","text":"The more information you have on an error, the easier it is to find out what went wrong. Muhammad Rehan Saeed made a nice enrichment package for Serilog named Serilog.Exceptions . The package uses reflection on a logged exception to log additional information depending on the concrete exception type. You can install the package through NuGet: Package Manager .NET CLI PackageReference Paket CLI Install-Package Serilog.Exceptions dotnet add package Serilog.Exceptions <PackageReference Include=\"Serilog.Exceptions\" Version=\"5.*\" /> paket add Serilog.Exceptions And configure it in C# code: var logger = new LoggerConfiguration() .Enrich.WithExceptionDetails() .WriteTo.ElmahIo(/*...*/) .CreateLogger(); The elmah.io sink will automatically pick up the additional information and show them in the extended message details overlay. To navigate to this view, click an error on the search view. Then click the button in the upper right corner to open extended message details. The information logged by Serilog.Exceptions are available beneath the Data tab.","title":"Extended exception details with Serilog.Exceptions"},{"location":"logging-to-elmah-io-from-serilog/#remove-sensitive-data","text":"Structured logging with Serilog is a great way to store a lot of contextual information about a log message. In some cases, it may result in sensitive data being stored in your log, though. We recommend you to remove any sensitive data from your log messages before storing them on elmah.io and anywhere else. To implement this, you can use the OnMessage event as already shown previously in the document: OnMessage = msg => { foreach (var d in msg.Data) { if (d.Key.Equals(\"Password\")) { d.Value = \"****\"; } } } An alternative to replacing sensitive values manually is to use a custom destructuring package for Serilog. The following example shows how to achieve this using the Destructurama.Attributed package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Destructurama.Attributed dotnet add package Destructurama.Attributed <PackageReference Include=\"Destructurama.Attributed\" Version=\"2.*\" /> paket add Destructurama.Attributed Set up destructuring from attributes: Log.Logger = new LoggerConfiguration() .Destructure.UsingAttributes() .WriteTo.ElmahIo(/*...*/) .CreateLogger(); Make sure to decorate any properties including sensitive data with the NotLogged attribute: public class LoginModel { public string Username { get; set; } [NotLogged] public string Password { get; set; } }","title":"Remove sensitive data"},{"location":"logging-to-elmah-io-from-servicestack/","text":"Logging to elmah.io from ServiceStack Logging errors to elmah.io from ServiceStack is almost as easy as installing in MVC and Web API. The folks over at ServiceStack provide you with a NuGet package named ServiceStack.Logging.Elmah. Like Web API you need to tell ServiceStack to use ELMAH as logging framework for errors, besides adding the standard ELMAH configuration in web.config. Start by installing both ServiceStack.Logging.Elmah and Elmah.Io into your ServiceStack web project: Package Manager .NET CLI PackageReference Paket CLI Install-Package ServiceStack.Logging.Elmah Install-Package Elmah.Io dotnet add package ServiceStack.Logging.Elmah dotnet add package Elmah.Io <PackageReference Include=\"ServiceStack.Logging.Elmah\" Version=\"5.*\" /> <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add ServiceStack.Logging.Elmah paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Once installed, add the following line to your AppHost: LogManager.LogFactory = new ElmahLogFactory(new NLogFactory()); The above example assumes that you are already using NLog as the existing framework for logging. Wrapping different logger factories in each other and actually makes it possible to log errors through ELMAH and other types of messages like warnings and info messages through another logging framework. If you don\u2019t need anything other than ELMAH logging, use the NullLogFactory instead of NLogFactory. That\u2019s it! By installing both the ServiceStack.Logging.Elmah and elmah.io packages, you should have sufficient configuration in your web.config to start logging like a pro.","title":"Logging from ServiceStack"},{"location":"logging-to-elmah-io-from-servicestack/#logging-to-elmahio-from-servicestack","text":"Logging errors to elmah.io from ServiceStack is almost as easy as installing in MVC and Web API. The folks over at ServiceStack provide you with a NuGet package named ServiceStack.Logging.Elmah. Like Web API you need to tell ServiceStack to use ELMAH as logging framework for errors, besides adding the standard ELMAH configuration in web.config. Start by installing both ServiceStack.Logging.Elmah and Elmah.Io into your ServiceStack web project: Package Manager .NET CLI PackageReference Paket CLI Install-Package ServiceStack.Logging.Elmah Install-Package Elmah.Io dotnet add package ServiceStack.Logging.Elmah dotnet add package Elmah.Io <PackageReference Include=\"ServiceStack.Logging.Elmah\" Version=\"5.*\" /> <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add ServiceStack.Logging.Elmah paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Once installed, add the following line to your AppHost: LogManager.LogFactory = new ElmahLogFactory(new NLogFactory()); The above example assumes that you are already using NLog as the existing framework for logging. Wrapping different logger factories in each other and actually makes it possible to log errors through ELMAH and other types of messages like warnings and info messages through another logging framework. If you don\u2019t need anything other than ELMAH logging, use the NullLogFactory instead of NLogFactory. That\u2019s it! By installing both the ServiceStack.Logging.Elmah and elmah.io packages, you should have sufficient configuration in your web.config to start logging like a pro.","title":"Logging to elmah.io from ServiceStack"},{"location":"logging-to-elmah-io-from-sitefinity/","text":"Logging to elmah.io from Sitefinity Sitefinity is a CMS from Telerik, implemented on top of ASP.NET. Like other content management systems build on top of ASP.NET, ELMAH is supported out of the box. To install elmah.io in a Sitefinity web-site, start by opening the web-site in Visual Studio by selecting File | Open Web Site... and navigate to the Sitefinity projects folder (something similar to this: C:\\Program Files (x86)\\Telerik\\Sitefinity\\Projects\\Default ). Right click the web site and install the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During installation you will be prompted for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). That's it! Uncaught errors in Sitefinity are logged to your elmah.io log. To test that the integration works, right click the web site and add a new Web Form named ELMAH.aspx. In the code behind file add the following code: protected void Page_Load(object sender, EventArgs e) { throw new ApplicationException(); } Start the web-site and navigate to the ELMAH.aspx page. If everything works as intended, you will see the yellow screen of death and a new error will pop up on elmah.io.","title":"Logging from Sitefinity"},{"location":"logging-to-elmah-io-from-sitefinity/#logging-to-elmahio-from-sitefinity","text":"Sitefinity is a CMS from Telerik, implemented on top of ASP.NET. Like other content management systems build on top of ASP.NET, ELMAH is supported out of the box. To install elmah.io in a Sitefinity web-site, start by opening the web-site in Visual Studio by selecting File | Open Web Site... and navigate to the Sitefinity projects folder (something similar to this: C:\\Program Files (x86)\\Telerik\\Sitefinity\\Projects\\Default ). Right click the web site and install the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During installation you will be prompted for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). That's it! Uncaught errors in Sitefinity are logged to your elmah.io log. To test that the integration works, right click the web site and add a new Web Form named ELMAH.aspx. In the code behind file add the following code: protected void Page_Load(object sender, EventArgs e) { throw new ApplicationException(); } Start the web-site and navigate to the ELMAH.aspx page. If everything works as intended, you will see the yellow screen of death and a new error will pop up on elmah.io.","title":"Logging to elmah.io from Sitefinity"},{"location":"logging-to-elmah-io-from-system-diagnostics/","text":"Logging to elmah.io from System.Diagnostics Logging through System.Diagnostics has been deprecated. Please use the Elmah.Io.Client package to log trace messages to elmah.io. .NET comes with its own tracing/logging feature located in the System.Diagnostics namespaces . A core part of System.Diagnostics is the Trace class, but that namespace contains utilities for performance counters, working with the event log and a lot of other features. In this article, we will focus on logging to elmah.io from System.Diagnostics.Trace . To start logging, install the Elmah.Io.Trace package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Trace dotnet add package Elmah.Io.Trace <PackageReference Include=\"Elmah.Io.Trace\" Version=\"3.*\" /> paket add Elmah.Io.Trace As default, Trace logs to the Win32 OutputDebugString function, but it is possible to log to multiple targets (like appenders in log4net). To do so, tell Trace about elmah.io: System.Diagnostics.Trace.Listeners.Add( new ElmahIoTraceListener(\"API_KEY\", new Guid(\"LOG_ID\"))); Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log id ( Where is my log ID? ). To start logging, call the Trace API: try { System.DIagnostics.Trace.Write(\"Starting something dangerous\"); // ... } catch (Exception e) { System.Diagnostics.Trace.Fail(e.Message, e.ToString()); } In the example, we write an information message with the message Starting something dangerous and logs any thrown exception to elmah.io.","title":"Logging from System.Diagnostics"},{"location":"logging-to-elmah-io-from-system-diagnostics/#logging-to-elmahio-from-systemdiagnostics","text":"Logging through System.Diagnostics has been deprecated. Please use the Elmah.Io.Client package to log trace messages to elmah.io. .NET comes with its own tracing/logging feature located in the System.Diagnostics namespaces . A core part of System.Diagnostics is the Trace class, but that namespace contains utilities for performance counters, working with the event log and a lot of other features. In this article, we will focus on logging to elmah.io from System.Diagnostics.Trace . To start logging, install the Elmah.Io.Trace package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Trace dotnet add package Elmah.Io.Trace <PackageReference Include=\"Elmah.Io.Trace\" Version=\"3.*\" /> paket add Elmah.Io.Trace As default, Trace logs to the Win32 OutputDebugString function, but it is possible to log to multiple targets (like appenders in log4net). To do so, tell Trace about elmah.io: System.Diagnostics.Trace.Listeners.Add( new ElmahIoTraceListener(\"API_KEY\", new Guid(\"LOG_ID\"))); Replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log id ( Where is my log ID? ). To start logging, call the Trace API: try { System.DIagnostics.Trace.Write(\"Starting something dangerous\"); // ... } catch (Exception e) { System.Diagnostics.Trace.Fail(e.Message, e.ToString()); } In the example, we write an information message with the message Starting something dangerous and logs any thrown exception to elmah.io.","title":"Logging to elmah.io from System.Diagnostics"},{"location":"logging-to-elmah-io-from-umbraco/","text":"Logging to elmah.io from Umbraco Logging to elmah.io from Umbraco Umbraco Cloud What's inside? Configuration Different environments Umbraco 7 Since Umbraco itself is written in ASP.NET, ELMAH works like a dream inside Umbraco. Besides logging uncaught errors, elmah.io also supports other types of messages like information and debug. In fact, all the log levels that you already know from log4net, NLog and Serilog, are supported on elmah.io as well. Logging in Umbraco CMS is based on Serilog, which elmah.io also support . We have brought all these pieces together into a NuGet package that we call: Elmah.Io.Umbraco . To start utilizing elmah.io from your Umbraco site, all you need to do is install the Elmah.Io.Umbraco package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco dotnet add package Elmah.Io.Umbraco <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.*\" /> paket add Elmah.Io.Umbraco During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Hit F5 and watch messages start flowing into elmah.io. Umbraco Cloud When using Umbraco Cloud, you may not have a local clone of the source code. To install elmah.io on Umbraco cloud, execute the following steps: Clone your Umbraco Cloud project to a local folder as explained here: Visual Studio Setup . Install Elmah.Io.Umbraco into your local clone. During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco dotnet add package Elmah.Io.Umbraco <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.*\" /> paket add Elmah.Io.Umbraco Commit and push all changes to the git respository. This will add elmah.io logging to your remote Umbraco Cloud project. In case you want logging to different elmah.io logs from each Umbraco Cloud environment, please check out Umbraco's support for config transformations here: Config transforms . What's inside? The Elmah.Io.Umbraco package basically installs and configures three things: The elmah.io Serilog sink (Warning and above) An Umbraco content finder for logging 404's ELMAH with elmah.io as error log All unhandled exceptions from both ASP.NET / MVC / Web API as well as 404's are logged automatically. Warnings, errors and fatal messages logged through Serilog are send to elmah.io as well. Configuration If you are running on the default Umbraco template, all nessecary configuration is added during installation of the Elmah.Io.Umbraco NuGet package. If your web.config file for some reason aren't updated during installation, you can configure elmah.io manually: Configure elmah.io manually . Likewise, the installer configure the elmah.io sink for Serilog in your config\\serilog.user.config file. Different environments You may have different environments like Staging and Production . At least you have two: Localhost and Production . If you want to log to different error logs depending on the current environment, check out Use multiple logs for different environments . Web.config transformations work on the Web.config file only but you may have other config files that need transformation as well. In terms of elmah.io, the serilog.user.config file also includes elmah.io configuration that you may want to disable on localhost and include on production. If you are running on Umbraco Cloud this is natively supported as explained here: Config Transforms . Even in self-hosted environments, you can achieve something similar using the SlowCheetah extension. Check out this question on Our for details: Deploying different umbracoSettings.config for different environments . Umbraco 7 We still support Umbraco 7 through the Elmah.Io.Umbraco package version 3.2.35 : Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco -Version 3.2.35 dotnet add package Elmah.Io.Umbraco --version 3.2.35 <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.2.35\" /> paket add Elmah.Io.Umbraco --version 3.2.35 New features will be added to the updated package for Umbraco 8 only.","title":"Logging from Umbraco"},{"location":"logging-to-elmah-io-from-umbraco/#logging-to-elmahio-from-umbraco","text":"Logging to elmah.io from Umbraco Umbraco Cloud What's inside? Configuration Different environments Umbraco 7 Since Umbraco itself is written in ASP.NET, ELMAH works like a dream inside Umbraco. Besides logging uncaught errors, elmah.io also supports other types of messages like information and debug. In fact, all the log levels that you already know from log4net, NLog and Serilog, are supported on elmah.io as well. Logging in Umbraco CMS is based on Serilog, which elmah.io also support . We have brought all these pieces together into a NuGet package that we call: Elmah.Io.Umbraco . To start utilizing elmah.io from your Umbraco site, all you need to do is install the Elmah.Io.Umbraco package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco dotnet add package Elmah.Io.Umbraco <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.*\" /> paket add Elmah.Io.Umbraco During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Hit F5 and watch messages start flowing into elmah.io.","title":"Logging to elmah.io from Umbraco"},{"location":"logging-to-elmah-io-from-umbraco/#umbraco-cloud","text":"When using Umbraco Cloud, you may not have a local clone of the source code. To install elmah.io on Umbraco cloud, execute the following steps: Clone your Umbraco Cloud project to a local folder as explained here: Visual Studio Setup . Install Elmah.Io.Umbraco into your local clone. During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco dotnet add package Elmah.Io.Umbraco <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.*\" /> paket add Elmah.Io.Umbraco Commit and push all changes to the git respository. This will add elmah.io logging to your remote Umbraco Cloud project. In case you want logging to different elmah.io logs from each Umbraco Cloud environment, please check out Umbraco's support for config transformations here: Config transforms .","title":"Umbraco Cloud"},{"location":"logging-to-elmah-io-from-umbraco/#whats-inside","text":"The Elmah.Io.Umbraco package basically installs and configures three things: The elmah.io Serilog sink (Warning and above) An Umbraco content finder for logging 404's ELMAH with elmah.io as error log All unhandled exceptions from both ASP.NET / MVC / Web API as well as 404's are logged automatically. Warnings, errors and fatal messages logged through Serilog are send to elmah.io as well.","title":"What's inside?"},{"location":"logging-to-elmah-io-from-umbraco/#configuration","text":"If you are running on the default Umbraco template, all nessecary configuration is added during installation of the Elmah.Io.Umbraco NuGet package. If your web.config file for some reason aren't updated during installation, you can configure elmah.io manually: Configure elmah.io manually . Likewise, the installer configure the elmah.io sink for Serilog in your config\\serilog.user.config file.","title":"Configuration"},{"location":"logging-to-elmah-io-from-umbraco/#different-environments","text":"You may have different environments like Staging and Production . At least you have two: Localhost and Production . If you want to log to different error logs depending on the current environment, check out Use multiple logs for different environments . Web.config transformations work on the Web.config file only but you may have other config files that need transformation as well. In terms of elmah.io, the serilog.user.config file also includes elmah.io configuration that you may want to disable on localhost and include on production. If you are running on Umbraco Cloud this is natively supported as explained here: Config Transforms . Even in self-hosted environments, you can achieve something similar using the SlowCheetah extension. Check out this question on Our for details: Deploying different umbracoSettings.config for different environments .","title":"Different environments"},{"location":"logging-to-elmah-io-from-umbraco/#umbraco-7","text":"We still support Umbraco 7 through the Elmah.Io.Umbraco package version 3.2.35 : Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Umbraco -Version 3.2.35 dotnet add package Elmah.Io.Umbraco --version 3.2.35 <PackageReference Include=\"Elmah.Io.Umbraco\" Version=\"3.2.35\" /> paket add Elmah.Io.Umbraco --version 3.2.35 New features will be added to the updated package for Umbraco 8 only.","title":"Umbraco 7"},{"location":"logging-to-elmah-io-from-wcf/","text":"Logging to elmah.io from WCF ELMAH and WCF isn't exactly known to go hand in hand. But, with a bit of custom code, logging exceptions from WCF to elmah.io is possible. Let's get started. Install elmah.io into your WCF project using NuGet: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Add a new class named HttpErrorHandler : public class HttpErrorHandler : IErrorHandler { public bool HandleError(Exception error) { return false; } public void ProvideFault(Exception error, MessageVersion version, ref Message fault) { if (error != null) { Elmah.ErrorSignal.FromCurrentContext().Raise(error); } } } This is an implementation of WCF's IErrorHandler that instructs WCF to log any errors to ELMAH, using the Raise -method on ErrorSignal . Then create an attribute named ServiceErrorBehaviourAttribute : public class ServiceErrorBehaviourAttribute : Attribute, IServiceBehavior { Type errorHandlerType; public ServiceErrorBehaviourAttribute(Type errorHandlerType) { this.errorHandlerType = errorHandlerType; } public void Validate(ServiceDescription description, ServiceHostBase serviceHostBase) { } public void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase) { IErrorHandler errorHandler; errorHandler = (IErrorHandler)Activator.CreateInstance(errorHandlerType); foreach (ChannelDispatcherBase channelDispatcherBase in serviceHostBase.ChannelDispatchers) { ChannelDispatcher channelDispatcher = channelDispatcherBase as ChannelDispatcher; channelDispatcher.ErrorHandlers.Add(errorHandler); } } } We'll use the ServiceErrorBehaviourAttribute class for decorating endpoints which we want logging uncaught errors to ELMAH. Add the new attribute to your service implementation like this: [ServiceErrorBehaviour(typeof(HttpErrorHandler))] public class Service1 : IService1 { // ... } That's it. Services decorated with the ServiceErrorBehaviourAttribute now logs exceptions to ELMAH.","title":"Logging from WCF"},{"location":"logging-to-elmah-io-from-wcf/#logging-to-elmahio-from-wcf","text":"ELMAH and WCF isn't exactly known to go hand in hand. But, with a bit of custom code, logging exceptions from WCF to elmah.io is possible. Let's get started. Install elmah.io into your WCF project using NuGet: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Add a new class named HttpErrorHandler : public class HttpErrorHandler : IErrorHandler { public bool HandleError(Exception error) { return false; } public void ProvideFault(Exception error, MessageVersion version, ref Message fault) { if (error != null) { Elmah.ErrorSignal.FromCurrentContext().Raise(error); } } } This is an implementation of WCF's IErrorHandler that instructs WCF to log any errors to ELMAH, using the Raise -method on ErrorSignal . Then create an attribute named ServiceErrorBehaviourAttribute : public class ServiceErrorBehaviourAttribute : Attribute, IServiceBehavior { Type errorHandlerType; public ServiceErrorBehaviourAttribute(Type errorHandlerType) { this.errorHandlerType = errorHandlerType; } public void Validate(ServiceDescription description, ServiceHostBase serviceHostBase) { } public void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase) { IErrorHandler errorHandler; errorHandler = (IErrorHandler)Activator.CreateInstance(errorHandlerType); foreach (ChannelDispatcherBase channelDispatcherBase in serviceHostBase.ChannelDispatchers) { ChannelDispatcher channelDispatcher = channelDispatcherBase as ChannelDispatcher; channelDispatcher.ErrorHandlers.Add(errorHandler); } } } We'll use the ServiceErrorBehaviourAttribute class for decorating endpoints which we want logging uncaught errors to ELMAH. Add the new attribute to your service implementation like this: [ServiceErrorBehaviour(typeof(HttpErrorHandler))] public class Service1 : IService1 { // ... } That's it. Services decorated with the ServiceErrorBehaviourAttribute now logs exceptions to ELMAH.","title":"Logging to elmah.io from WCF"},{"location":"logging-to-elmah-io-from-web-api/","text":"Logging to elmah.io from Web API Web API provides its own mechanism for handling errors, why ELMAH\u2019s modules and handlers doesn\u2019t work there. Luckily, Richard Dingwall created the Elmah.Contrib.WebApi NuGet package to fix this. We've built a package for ASP.NET Web API exclusively, which installs all the necessary packages. To start logging exceptions from Web API, install the Elmah.Io.WebApi NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.WebApi dotnet add package Elmah.Io.WebApi <PackageReference Include=\"Elmah.Io.WebApi\" Version=\"3.*\" /> paket add Elmah.Io.WebApi During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Web API 2.x Web API 1.x Add the following code to your WebApiConfig.cs file: public static class WebApiConfig { public static void Register(HttpConfiguration config) { // ... config.Services.Add(typeof(IExceptionLogger), new ElmahExceptionLogger()); // ... } } The registered IExceptionLogger intercepts all thrown exceptions, even errors in controller contructors and routing errors. Add the following code to your Global.asax.cs file: protected void Application_Start() { // ... GlobalConfiguration.Configuration.Filters.Add(new ElmahHandleErrorApiAttribute()); // ... } In this case you register a new global filter with Web API. The downside of this approach is, that only errors thrown in controller actions are logged. All uncaught exceptions in ASP.NET Web API are now logged to elmah.io Logging from exception/action filters It's a widely used Web API approach, to handle all exceptions in a global exception/action filter and return a nicely formatted JSON/XML error response to the client. This is a nice approach to avoid throwing internal server errors, but it also puts ELMAH out of the game. When catching any exception manually and converting it to a response message, errors won't be logged in elmah.io. To overcome this, errors should be logged manually from your global exception/action filter: public class NotImplExceptionFilterAttribute : ExceptionFilterAttribute { public override void OnException(HttpActionExecutedContext context) { ErrorSignal.FromCurrentContext().Raise(context.Exception); // Now generate the result to the client } }","title":"Logging from Web API"},{"location":"logging-to-elmah-io-from-web-api/#logging-to-elmahio-from-web-api","text":"Web API provides its own mechanism for handling errors, why ELMAH\u2019s modules and handlers doesn\u2019t work there. Luckily, Richard Dingwall created the Elmah.Contrib.WebApi NuGet package to fix this. We've built a package for ASP.NET Web API exclusively, which installs all the necessary packages. To start logging exceptions from Web API, install the Elmah.Io.WebApi NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.WebApi dotnet add package Elmah.Io.WebApi <PackageReference Include=\"Elmah.Io.WebApi\" Version=\"3.*\" /> paket add Elmah.Io.WebApi During the installation, you will be asked for your API key ( Where is my API key? ) and log ID ( Where is my log ID? ). Web API 2.x Web API 1.x Add the following code to your WebApiConfig.cs file: public static class WebApiConfig { public static void Register(HttpConfiguration config) { // ... config.Services.Add(typeof(IExceptionLogger), new ElmahExceptionLogger()); // ... } } The registered IExceptionLogger intercepts all thrown exceptions, even errors in controller contructors and routing errors. Add the following code to your Global.asax.cs file: protected void Application_Start() { // ... GlobalConfiguration.Configuration.Filters.Add(new ElmahHandleErrorApiAttribute()); // ... } In this case you register a new global filter with Web API. The downside of this approach is, that only errors thrown in controller actions are logged. All uncaught exceptions in ASP.NET Web API are now logged to elmah.io","title":"Logging to elmah.io from Web API"},{"location":"logging-to-elmah-io-from-web-api/#logging-from-exceptionaction-filters","text":"It's a widely used Web API approach, to handle all exceptions in a global exception/action filter and return a nicely formatted JSON/XML error response to the client. This is a nice approach to avoid throwing internal server errors, but it also puts ELMAH out of the game. When catching any exception manually and converting it to a response message, errors won't be logged in elmah.io. To overcome this, errors should be logged manually from your global exception/action filter: public class NotImplExceptionFilterAttribute : ExceptionFilterAttribute { public override void OnException(HttpActionExecutedContext context) { ErrorSignal.FromCurrentContext().Raise(context.Exception); // Now generate the result to the client } }","title":"Logging from exception/action filters"},{"location":"logging-to-multiple-elmah-logs/","text":"Logging to multiple ELMAH logs Unfortunately, ELMAH (the open source project) doesn\u2019t support multiple log targets like other logging frameworks like Serilog. This makes logging to multiple logs a bit tricky, but no way impossible. Let\u2019s say that you\u2019re using ELMAH in your web application and configured it to log everything in SQL Server. If you look through your web.config file, you will have code looking like this somewhere: <elmah> <errorLog type=\"Elmah.SqlErrorLog, Elmah\" connectionStringName=\"elmah\"/> </elmah> As you probably know, this tells ELMAH to log all unhandled errors in SQL Server with the connection string \u201celmah\u201d. You cannot add more <errorLog> elements, why logging to a second log seems impossible. Meet ELMAH\u2019s Logged event, which is a great hook to log to multiple targets. Install the Elmah.Io NuGet package and add the following code to your global.asax.cs file: void ErrorLog_Logged(object sender, Elmah.ErrorLoggedEventArgs args) { var elmahIoLog = new Elmah.Io.ErrorLog(ElmahioAPI.Create(\"API_KEY\"), new Guid(\"LOG_ID\")); elmahIoLog.Log(args.Entry.Error); } In the above code, we listen for the Logged event by simply declaring a method named ErrorLog_Logged . When called, we create a new (Elmah.Io.)ErrorLog instance with an IElmahioAPI object and the log ID. Remember to replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log ID ( Where is my log ID? ). You may want to share the ElmahioAPI object between requests by declaring it as a private member. Next, we simply call the Log method with a new Error object. Bam! The error is logged both in SQL Server and in elmah.io. If you only want to log certain types of errors in elmah.io, but everything to your normal log, you can extend your code like this: void ErrorLog_Logged(object sender, Elmah.ErrorLoggedEventArgs args) { if (args.Entry.Error.StatusCode == 500) { var elmahIoLog = new Elmah.Io.ErrorLog(/*...*/); elmahIoLog.Log(args.Entry.Error); } } This time we only begin logging to elmah.io, if the thrown exception is of type HttpException and contains an HTTP status code of 500 . This example only logs errors with status code 500 in elmah.io and all errors in your normal error log. If you want to create this filter on all logs, you should use the ErrorLog_Filtering method instead. This method is called before ErrorLog_Logged and before actually logging the error to your normal error log.","title":"Logging to multiple logs"},{"location":"logging-to-multiple-elmah-logs/#logging-to-multiple-elmah-logs","text":"Unfortunately, ELMAH (the open source project) doesn\u2019t support multiple log targets like other logging frameworks like Serilog. This makes logging to multiple logs a bit tricky, but no way impossible. Let\u2019s say that you\u2019re using ELMAH in your web application and configured it to log everything in SQL Server. If you look through your web.config file, you will have code looking like this somewhere: <elmah> <errorLog type=\"Elmah.SqlErrorLog, Elmah\" connectionStringName=\"elmah\"/> </elmah> As you probably know, this tells ELMAH to log all unhandled errors in SQL Server with the connection string \u201celmah\u201d. You cannot add more <errorLog> elements, why logging to a second log seems impossible. Meet ELMAH\u2019s Logged event, which is a great hook to log to multiple targets. Install the Elmah.Io NuGet package and add the following code to your global.asax.cs file: void ErrorLog_Logged(object sender, Elmah.ErrorLoggedEventArgs args) { var elmahIoLog = new Elmah.Io.ErrorLog(ElmahioAPI.Create(\"API_KEY\"), new Guid(\"LOG_ID\")); elmahIoLog.Log(args.Entry.Error); } In the above code, we listen for the Logged event by simply declaring a method named ErrorLog_Logged . When called, we create a new (Elmah.Io.)ErrorLog instance with an IElmahioAPI object and the log ID. Remember to replace API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log ID ( Where is my log ID? ). You may want to share the ElmahioAPI object between requests by declaring it as a private member. Next, we simply call the Log method with a new Error object. Bam! The error is logged both in SQL Server and in elmah.io. If you only want to log certain types of errors in elmah.io, but everything to your normal log, you can extend your code like this: void ErrorLog_Logged(object sender, Elmah.ErrorLoggedEventArgs args) { if (args.Entry.Error.StatusCode == 500) { var elmahIoLog = new Elmah.Io.ErrorLog(/*...*/); elmahIoLog.Log(args.Entry.Error); } } This time we only begin logging to elmah.io, if the thrown exception is of type HttpException and contains an HTTP status code of 500 . This example only logs errors with status code 500 in elmah.io and all errors in your normal error log. If you want to create this filter on all logs, you should use the ErrorLog_Filtering method instead. This method is called before ErrorLog_Logged and before actually logging the error to your normal error log.","title":"Logging to multiple ELMAH logs"},{"location":"managing-organisations-and-users/","text":"Managing Organizations and Users Managing Organizations and Users Adding existing users to an organization Invite new users to an organization Control security Chances are that you are not the only one needing to access your logs. Luckily, elmah.io offers great features to manage the users in your organization and to specify who should be allowed access to what. This guide is also available as a short video tutorial here: To manage access, you will need to know about the concepts of users and organizations . A user represents a person wanting to access one or more logs. Each user has its login using username/password or a social provider of choice. A user can be added to one or more organizations. Each user has an access level within the organization as well as an access level on each log. The access level on the organization and the logs doesn't need to be the same. An organization is a collection of users and their role inside the organization. You will typically only need a single organization, representing all of the users in your company needing to access one or more logs on elmah.io. Your elmah.io subscription is attached your organization and everyone with administrator access to the organization, will be able to manage the subscription. Adding existing users to an organization To assign users to a log, you will need to add them to the organization first. When hovering the organization name in either the left menu or on the dashboard, you will see a small gear icon. When clicking the icon, you will be taken to the organization settings page: At first, the user creating the organization will be the only one in the list. To add a new user to the list, click the Add user button and input the user's email or name in the textbox. The dropdown will show a list of users on elmah.io matching your query. Each user needs to sign up on elmah.io before being visible through Add user . Read on to learn how to invite new users. When the new user is visible in the dropdown, click the user and select an access level. The chosen access level decides what the new user is allowed to do inside the organization. Read users are only allowed to view the organization, while Administrator users are allowed to add new users and delete the entire organization and all logs beneath it. The access level set for the user in the organization, will become the user's access level on all new logs inside that organization as well. Let's add a new user to the organization: To change the access level on an already added user, click one of the grouped buttons to the right of the user's name. Changing a user's access level on the organization won't change the users access level on each log. To delete a user from the organization, click the red delete button to the far right. When a user is added to an organization, the user will automatically have access to all new logs created in that organization. For security reasons, a new user added to the organization, will not have access to existing logs in the organization. To assign the new user to existing logs, assign an access level on each log shown beneath the user. The list of logs can be opened by clicking the dropdown button to the right of the user. Awarding a user Administrator on a log, doesn't give them Administrator rights on the organization. To assign a user to all logs, click the None , Read , Write or Administrator buttons in the table header above the list of logs. Invite new users to an organization If someone not already created as a user on elmah.io needs access to your organization, you can use the Invite feature. Inviting users will send them an email telling them to sign up for elmah.io and automatically add them to your organization. To invite a user click the Invite user button and input the new users email. Select an organization access level and click the green Invite user button. This will add the new user to the organization and display it as \"Invited\" until the user sign up. Control security You may have requirements of using two-factor authentication or against using social logins in your company. These requirements can be configured on elmah.io as well. Click the Security button above the users list to set it up: The toggles are documented through the UI. Here's an explanation for reference: Enforce two-factor authentication When enabling this toggle, all users in your organization will be required to set up two-factor authentication. Requiring two-factor authentication will also disallow social accounts since we have no way of knowing if a user signing up with a social account has enabled two-factor authentication or not. Disallow social login When enabling this toggle, all users in your organization will need to be signed up with a username and password. The icon next to each user's name on the list of users shows the bug icon if the user signed up with a username and password.","title":"Managing Organisations and Users"},{"location":"managing-organisations-and-users/#managing-organizations-and-users","text":"Managing Organizations and Users Adding existing users to an organization Invite new users to an organization Control security Chances are that you are not the only one needing to access your logs. Luckily, elmah.io offers great features to manage the users in your organization and to specify who should be allowed access to what. This guide is also available as a short video tutorial here: To manage access, you will need to know about the concepts of users and organizations . A user represents a person wanting to access one or more logs. Each user has its login using username/password or a social provider of choice. A user can be added to one or more organizations. Each user has an access level within the organization as well as an access level on each log. The access level on the organization and the logs doesn't need to be the same. An organization is a collection of users and their role inside the organization. You will typically only need a single organization, representing all of the users in your company needing to access one or more logs on elmah.io. Your elmah.io subscription is attached your organization and everyone with administrator access to the organization, will be able to manage the subscription.","title":"Managing Organizations and Users"},{"location":"managing-organisations-and-users/#adding-existing-users-to-an-organization","text":"To assign users to a log, you will need to add them to the organization first. When hovering the organization name in either the left menu or on the dashboard, you will see a small gear icon. When clicking the icon, you will be taken to the organization settings page: At first, the user creating the organization will be the only one in the list. To add a new user to the list, click the Add user button and input the user's email or name in the textbox. The dropdown will show a list of users on elmah.io matching your query. Each user needs to sign up on elmah.io before being visible through Add user . Read on to learn how to invite new users. When the new user is visible in the dropdown, click the user and select an access level. The chosen access level decides what the new user is allowed to do inside the organization. Read users are only allowed to view the organization, while Administrator users are allowed to add new users and delete the entire organization and all logs beneath it. The access level set for the user in the organization, will become the user's access level on all new logs inside that organization as well. Let's add a new user to the organization: To change the access level on an already added user, click one of the grouped buttons to the right of the user's name. Changing a user's access level on the organization won't change the users access level on each log. To delete a user from the organization, click the red delete button to the far right. When a user is added to an organization, the user will automatically have access to all new logs created in that organization. For security reasons, a new user added to the organization, will not have access to existing logs in the organization. To assign the new user to existing logs, assign an access level on each log shown beneath the user. The list of logs can be opened by clicking the dropdown button to the right of the user. Awarding a user Administrator on a log, doesn't give them Administrator rights on the organization. To assign a user to all logs, click the None , Read , Write or Administrator buttons in the table header above the list of logs.","title":"Adding existing users to an organization"},{"location":"managing-organisations-and-users/#invite-new-users-to-an-organization","text":"If someone not already created as a user on elmah.io needs access to your organization, you can use the Invite feature. Inviting users will send them an email telling them to sign up for elmah.io and automatically add them to your organization. To invite a user click the Invite user button and input the new users email. Select an organization access level and click the green Invite user button. This will add the new user to the organization and display it as \"Invited\" until the user sign up.","title":"Invite new users to an organization"},{"location":"managing-organisations-and-users/#control-security","text":"You may have requirements of using two-factor authentication or against using social logins in your company. These requirements can be configured on elmah.io as well. Click the Security button above the users list to set it up: The toggles are documented through the UI. Here's an explanation for reference: Enforce two-factor authentication When enabling this toggle, all users in your organization will be required to set up two-factor authentication. Requiring two-factor authentication will also disallow social accounts since we have no way of knowing if a user signing up with a social account has enabled two-factor authentication or not. Disallow social login When enabling this toggle, all users in your organization will need to be signed up with a username and password. The icon next to each user's name on the list of users shows the bug icon if the user signed up with a username and password.","title":"Control security"},{"location":"missing-server-side-information-on-uptime-errors/","text":"Missing server side information on uptime errors To decorate uptime errors with server side error information, you will need a few things: The monitored website should be configured to log errors to elmah.io. The uptime check needs to be created on the same log as the monitored website. Update the BotBuster app. When installed in a previous version, errors generated by Uptime Monitoring are ignored (since Uptime Monitoring is in fact a bot). To update, uninstall the BotBuster app and then re-install it.","title":"Missing server side information on uptime errors"},{"location":"missing-server-side-information-on-uptime-errors/#missing-server-side-information-on-uptime-errors","text":"To decorate uptime errors with server side error information, you will need a few things: The monitored website should be configured to log errors to elmah.io. The uptime check needs to be created on the same log as the monitored website. Update the BotBuster app. When installed in a previous version, errors generated by Uptime Monitoring are ignored (since Uptime Monitoring is in fact a bot). To update, uninstall the BotBuster app and then re-install it.","title":"Missing server side information on uptime errors"},{"location":"query-messages-using-full-text-search/","text":"Query messages using full-text search All messages sent to elmah.io, are indexed in Elasticsearch. Storing messages in a database like Elasticsearch, opens up a world of possibilities. This article explains how to query your log messages using full-text search, Search Filters and Lucene Query Syntax. Query messages using full-text search Full-text search Search Filters Lucene Query Syntax Full-text search The easiest approach to start searching your log messages, is by inputting search terms in the Search field on elmah.io: We don't want to get into too much details on how full-text work in Elasticsearch. In short, Elasticsearch breaks the query into the terms implement and icontroller and tries to match all log messages including those terms. Full-text search work on analyzed fields in Elasticsearch, which means that wildcards and other constructs are fully supported. Full-text queries work great. when you want to do a quick search for some keywords like part of an exception message or stacktrace. Remember that the entire log message is search, why a search for 500 would hit both log messages with status code 500 and the term 500 in the stacktrace. Search Filters Search filters are built exclusively for elmah.io. They are built on top of Lucene Query Syntax (which we'll discuss in a minute), but much easier to write. Search filters are available through either the Add filter button below the search field or using various links and icons on the elmah.io UI. Let's say we want to find all errors with a status code of 500: Adding the two filters is possible using a few clicks. As mentioned previously, search filters are available througout the UI too. In this example, a filter is used to find messages not matching a specified URL: Search filters can be used in combination with full-text queries for greater flexibility. Lucene Query Syntax Elasticsearch is implemented on top of Lucene; a high-performance search engine, written entirely in Java. While Elasticsearch supports a lot of nice abstractions on top of Lucene, sometime you just want close to the metal. This is when we need to introduce you to Lucene Query Syntax. The query syntax is a query language similar to the WHERE part of a SQL statement. Unlike SQL, the query syntax supports both filters (similar to SQL) and full-text queries. Basically all Lucene queries are made up of strings containing one or more terms and operators: term AND term OR (term AND NOT term) Instead of AND , OR , and NOT you can use operators known from C#: term && term || (term && !term) While AND , OR , and NOT speaks for itself, terms needs a bit of explanation. A term can be a single term or a phrase. We've already seen two single terms in the full-text search example. The query in the example corresponds to this Lucene query: implement AND IController Looking at term phrases, things get really interesting. With phrases, you can query on specific fields, perform range queries and much more. Examples are worth a thousand words, why the rest of this document is examples of frequently used queries. If you think that examples are missing or have a problem with a custom queries, let us know. We will extend this tutorial with the examples you need. Find messages with type type:\"System.Web.HttpException\" Find messages with status codes statusCode:[500 TO 599] Find messages with URL and method url:\"/tester/\" AND method:get Find messages with URL starting with url:\\/.well-known* Forward slash in the beginning needs to be escaped, since Lucene will understand it as the start of a regex otherwise. Find messages by IP remoteAddr:192.168.0.1 Find messages by IP's remoteAddr:192.68.0.* The examples above can be achieved using Search Filters as well. We recommend using Search Filters where possible and fall back to Lucene Query Syntax when something isn't supported through filters. An example is using OR which currently isn't possible using filters.","title":"Query messages using full-text search"},{"location":"query-messages-using-full-text-search/#query-messages-using-full-text-search","text":"All messages sent to elmah.io, are indexed in Elasticsearch. Storing messages in a database like Elasticsearch, opens up a world of possibilities. This article explains how to query your log messages using full-text search, Search Filters and Lucene Query Syntax. Query messages using full-text search Full-text search Search Filters Lucene Query Syntax","title":"Query messages using full-text search"},{"location":"query-messages-using-full-text-search/#full-text-search","text":"The easiest approach to start searching your log messages, is by inputting search terms in the Search field on elmah.io: We don't want to get into too much details on how full-text work in Elasticsearch. In short, Elasticsearch breaks the query into the terms implement and icontroller and tries to match all log messages including those terms. Full-text search work on analyzed fields in Elasticsearch, which means that wildcards and other constructs are fully supported. Full-text queries work great. when you want to do a quick search for some keywords like part of an exception message or stacktrace. Remember that the entire log message is search, why a search for 500 would hit both log messages with status code 500 and the term 500 in the stacktrace.","title":"Full-text search"},{"location":"query-messages-using-full-text-search/#search-filters","text":"Search filters are built exclusively for elmah.io. They are built on top of Lucene Query Syntax (which we'll discuss in a minute), but much easier to write. Search filters are available through either the Add filter button below the search field or using various links and icons on the elmah.io UI. Let's say we want to find all errors with a status code of 500: Adding the two filters is possible using a few clicks. As mentioned previously, search filters are available througout the UI too. In this example, a filter is used to find messages not matching a specified URL: Search filters can be used in combination with full-text queries for greater flexibility.","title":"Search Filters"},{"location":"query-messages-using-full-text-search/#lucene-query-syntax","text":"Elasticsearch is implemented on top of Lucene; a high-performance search engine, written entirely in Java. While Elasticsearch supports a lot of nice abstractions on top of Lucene, sometime you just want close to the metal. This is when we need to introduce you to Lucene Query Syntax. The query syntax is a query language similar to the WHERE part of a SQL statement. Unlike SQL, the query syntax supports both filters (similar to SQL) and full-text queries. Basically all Lucene queries are made up of strings containing one or more terms and operators: term AND term OR (term AND NOT term) Instead of AND , OR , and NOT you can use operators known from C#: term && term || (term && !term) While AND , OR , and NOT speaks for itself, terms needs a bit of explanation. A term can be a single term or a phrase. We've already seen two single terms in the full-text search example. The query in the example corresponds to this Lucene query: implement AND IController Looking at term phrases, things get really interesting. With phrases, you can query on specific fields, perform range queries and much more. Examples are worth a thousand words, why the rest of this document is examples of frequently used queries. If you think that examples are missing or have a problem with a custom queries, let us know. We will extend this tutorial with the examples you need. Find messages with type type:\"System.Web.HttpException\" Find messages with status codes statusCode:[500 TO 599] Find messages with URL and method url:\"/tester/\" AND method:get Find messages with URL starting with url:\\/.well-known* Forward slash in the beginning needs to be escaped, since Lucene will understand it as the start of a regex otherwise. Find messages by IP remoteAddr:192.168.0.1 Find messages by IP's remoteAddr:192.68.0.* The examples above can be achieved using Search Filters as well. We recommend using Search Filters where possible and fall back to Lucene Query Syntax when something isn't supported through filters. An example is using OR which currently isn't possible using filters.","title":"Lucene Query Syntax"},{"location":"remove-sensitive-form-data/","text":"Remove sensitive form data You may have something like usernames and passwords in form posts on your website. Since elmah.io automatically logs the content of a failing form POST, sensitive data potentially ends up in your log. No one else but you and your company should really get to look inside your log, but remember that everyone connected to the Internet, is a potential hacking victim. In this example, we hide the value of a form value named SomeSecretFormField . Add the following code in the Application_Start method in the global.asax.cs file: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = Elmah.Io.ErrorLog.Client; logger.OnMessage += (sender, args) => { var form = args.Message.Form.FirstOrDefault(f => f.Key == \"SomeSecretFormField\"); if (form != null) { form.Value = \"***hidden***\"; } };","title":"Remove sensitive form data"},{"location":"remove-sensitive-form-data/#remove-sensitive-form-data","text":"You may have something like usernames and passwords in form posts on your website. Since elmah.io automatically logs the content of a failing form POST, sensitive data potentially ends up in your log. No one else but you and your company should really get to look inside your log, but remember that everyone connected to the Internet, is a potential hacking victim. In this example, we hide the value of a form value named SomeSecretFormField . Add the following code in the Application_Start method in the global.asax.cs file: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = Elmah.Io.ErrorLog.Client; logger.OnMessage += (sender, args) => { var form = args.Message.Form.FirstOrDefault(f => f.Key == \"SomeSecretFormField\"); if (form != null) { form.Value = \"***hidden***\"; } };","title":"Remove sensitive form data"},{"location":"roslyn-analyzers-for-elmah-io-and-aspnet-core/","text":"Roslyn analyzers for elmah.io and ASP.NET Core Roslyn analyzers for elmah.io and ASP.NET Core Installation and usage EIO1000 ConfigureServices must call AddElmahIo EIO1001 Configure must call UseElmahIo EIO1002 UseElmahIo must be called before/after Use* To help to install elmah.io in ASP.NET Core (by using the Elmah.Io.AspNetCore NuGet package) we have developed a range of Roslyn analyzers. Analyzers run inside Visual Studio and make it possible to validate your Startup.cs file during development. Installation and usage To install the analyzers, navigate to Extensions | Manage extensions | Online and search for Elmah.Io.AspNetCore.Analyzers . Then click the Download button and restart Visual Studio. As an alternative, you can download the extension directly from the Visual Studio Marketplace. Once installed, analyzers will help you add or move elmah.io-related set up code: All issues are listed as warnings in the Error list as well. The following is an explanation of possible warnings. EIO1000 ConfigureServices must call AddElmahIo AddElmahIo needs to be added as part of the ConfigureServices method: public void ConfigureServices(IServiceCollection services) { services.AddElmahIo(/*...*/); //\ud83d\udc48 } EIO1001 Configure must call UseElmahIo UseElmahIo needs to be added as part of the Configure method: public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseElmahIo(); //\ud83d\udc48 } EIO1002 UseElmahIo must be called before/after Use* UseElmahIo needs to be called after any calls to UseDeveloperExceptionPage , UseExceptionHandler , UseAuthorization , and UseAuthentication but before any calls to UseEndpoints and UseMvc : public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(/*...*/); } app.UseAuthentication(); app.UseAuthorization(); app.UseElmahIo(); //\ud83d\udc48 app.UseEndpoints(); app.UseMvc(/*...*/); }","title":"Roslyn analyzers for elmah.io and ASP.NET Core"},{"location":"roslyn-analyzers-for-elmah-io-and-aspnet-core/#roslyn-analyzers-for-elmahio-and-aspnet-core","text":"Roslyn analyzers for elmah.io and ASP.NET Core Installation and usage EIO1000 ConfigureServices must call AddElmahIo EIO1001 Configure must call UseElmahIo EIO1002 UseElmahIo must be called before/after Use* To help to install elmah.io in ASP.NET Core (by using the Elmah.Io.AspNetCore NuGet package) we have developed a range of Roslyn analyzers. Analyzers run inside Visual Studio and make it possible to validate your Startup.cs file during development.","title":"Roslyn analyzers for elmah.io and ASP.NET Core"},{"location":"roslyn-analyzers-for-elmah-io-and-aspnet-core/#installation-and-usage","text":"To install the analyzers, navigate to Extensions | Manage extensions | Online and search for Elmah.Io.AspNetCore.Analyzers . Then click the Download button and restart Visual Studio. As an alternative, you can download the extension directly from the Visual Studio Marketplace. Once installed, analyzers will help you add or move elmah.io-related set up code: All issues are listed as warnings in the Error list as well. The following is an explanation of possible warnings.","title":"Installation and usage"},{"location":"roslyn-analyzers-for-elmah-io-and-aspnet-core/#eio1000-configureservices-must-call-addelmahio","text":"AddElmahIo needs to be added as part of the ConfigureServices method: public void ConfigureServices(IServiceCollection services) { services.AddElmahIo(/*...*/); //\ud83d\udc48 }","title":"EIO1000 ConfigureServices must call AddElmahIo"},{"location":"roslyn-analyzers-for-elmah-io-and-aspnet-core/#eio1001-configure-must-call-useelmahio","text":"UseElmahIo needs to be added as part of the Configure method: public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseElmahIo(); //\ud83d\udc48 }","title":"EIO1001 Configure must call UseElmahIo"},{"location":"roslyn-analyzers-for-elmah-io-and-aspnet-core/#eio1002-useelmahio-must-be-called-beforeafter-use","text":"UseElmahIo needs to be called after any calls to UseDeveloperExceptionPage , UseExceptionHandler , UseAuthorization , and UseAuthentication but before any calls to UseEndpoints and UseMvc : public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(/*...*/); } app.UseAuthentication(); app.UseAuthorization(); app.UseElmahIo(); //\ud83d\udc48 app.UseEndpoints(); app.UseMvc(/*...*/); }","title":"EIO1002 UseElmahIo must be called before/after Use*"},{"location":"setup-deployment-tracking/","text":"Set Up Deployment Tracking Set Up Deployment Tracking Generate a new API key Tell elmah.io when you release Decorate your messages with a version number Versioning Different Services Deployment tracking creates an overview of the different versions of your software and show you how well each version performed. With this integration in place, you will be able to see when you released and if some of your releases caused more errors than others. While most pages on elmah.io supports everything from verbose to fatal messages, the context on deployment tracking is around warnings and errors. To set up deployment tracking, you will need to tell elmah.io when you release, using our REST API or one of the integrations: PowerShell Octopus Deploy Azure DevOps GitHub Actions Umbraco Cloud Bitbucket Pipelines Bamboo Deployments are as default created on all of your logs, but this can be tweaked. More about this later. For a complete overview of the possibilities with deployment tracking, watch this video tutorial: Generate a new API key While you can use the same API key for everything, we recommend you to create an API key specific for deployment tracking. To do so, go to the organization settings page by clicking the gears icon next to the organization name on either the dashboard or in the left menu. Select the API Keys tabs and click Add API Key . Fill in a name of choice and enable the Deployments > Write permission only: Click the save button and copy the API key for later use. Tell elmah.io when you release When you create a release of your software either manually or with the help from a tool like Octopus, you need to tell elmah.io about it. The elmah.io REST API v3 , provides an endpoint named deployments , which you can call when creating releases. After calling the endpoint, all new messages to your logs, will automatically be decorated with the most recent version number. If you release your software manually, creating the new release manually is easy using Swagger UI. Swagger UI is a graphical client for calling a Swagger enabled endpoint (much like Postman). Navigate to https://api.elmah.io/swagger/ui/index , expand the Deployments node and click the POST request: To create the release, input your API key ( Where is my API key? ) in the top right corner and click the JSON beneath Model Schema . This copies the example JSON to the deployment parameter. A minimal deployment would look like the following, but adding more information makes the experience within elmah.io even better: { \"version\": \"1.42.7\" } The version string in the example conforms to SemVer, but the content can be anything. The date of the release is automatically added if not specified in the JSON body. Click the Try it out! button and the deployment is created. We support a range of different integrations to avoid you manually having to use Swagger UI every time you release. Click one of the products below for instructions: PowerShell Octopus Deploy Kudu Azure DevOps Pipelines Azure DevOps Releases GitHub Actions Umbraco Cloud Bitbucket Pipelines Atlassian Bamboo Decorate your messages with a version number As default, all messages are decorated with the most recent deployment version. If you want to override this behavior, check out Adding Version Information for details. Versioning Different Services Chances are that your software consists of multiple services released independently and with different version numbers. This is a common pattern when splitting up a software system in microservices. How you choose to split your elmah.io logs are entirely up to you, but we almost always recommend having a separate log for each service. When doing so, you only want deployment tracking to show the releases from the service you are currently looking at. The problem here is that deployments on elmah.io are shown on all logs as default. To make sure that only deployments related to the service you are looking at are shown, you need to decorate each deployment with the log ID where it belong. The deployments API support this through an optional logId property. If set, the new deployment is only shown on the specified log.","title":"Set up Deployment Tracking"},{"location":"setup-deployment-tracking/#set-up-deployment-tracking","text":"Set Up Deployment Tracking Generate a new API key Tell elmah.io when you release Decorate your messages with a version number Versioning Different Services Deployment tracking creates an overview of the different versions of your software and show you how well each version performed. With this integration in place, you will be able to see when you released and if some of your releases caused more errors than others. While most pages on elmah.io supports everything from verbose to fatal messages, the context on deployment tracking is around warnings and errors. To set up deployment tracking, you will need to tell elmah.io when you release, using our REST API or one of the integrations: PowerShell Octopus Deploy Azure DevOps GitHub Actions Umbraco Cloud Bitbucket Pipelines Bamboo Deployments are as default created on all of your logs, but this can be tweaked. More about this later. For a complete overview of the possibilities with deployment tracking, watch this video tutorial:","title":"Set Up Deployment Tracking"},{"location":"setup-deployment-tracking/#generate-a-new-api-key","text":"While you can use the same API key for everything, we recommend you to create an API key specific for deployment tracking. To do so, go to the organization settings page by clicking the gears icon next to the organization name on either the dashboard or in the left menu. Select the API Keys tabs and click Add API Key . Fill in a name of choice and enable the Deployments > Write permission only: Click the save button and copy the API key for later use.","title":"Generate a new API key"},{"location":"setup-deployment-tracking/#tell-elmahio-when-you-release","text":"When you create a release of your software either manually or with the help from a tool like Octopus, you need to tell elmah.io about it. The elmah.io REST API v3 , provides an endpoint named deployments , which you can call when creating releases. After calling the endpoint, all new messages to your logs, will automatically be decorated with the most recent version number. If you release your software manually, creating the new release manually is easy using Swagger UI. Swagger UI is a graphical client for calling a Swagger enabled endpoint (much like Postman). Navigate to https://api.elmah.io/swagger/ui/index , expand the Deployments node and click the POST request: To create the release, input your API key ( Where is my API key? ) in the top right corner and click the JSON beneath Model Schema . This copies the example JSON to the deployment parameter. A minimal deployment would look like the following, but adding more information makes the experience within elmah.io even better: { \"version\": \"1.42.7\" } The version string in the example conforms to SemVer, but the content can be anything. The date of the release is automatically added if not specified in the JSON body. Click the Try it out! button and the deployment is created. We support a range of different integrations to avoid you manually having to use Swagger UI every time you release. Click one of the products below for instructions: PowerShell Octopus Deploy Kudu Azure DevOps Pipelines Azure DevOps Releases GitHub Actions Umbraco Cloud Bitbucket Pipelines Atlassian Bamboo","title":"Tell elmah.io when you release"},{"location":"setup-deployment-tracking/#decorate-your-messages-with-a-version-number","text":"As default, all messages are decorated with the most recent deployment version. If you want to override this behavior, check out Adding Version Information for details.","title":"Decorate your messages with a version number"},{"location":"setup-deployment-tracking/#versioning-different-services","text":"Chances are that your software consists of multiple services released independently and with different version numbers. This is a common pattern when splitting up a software system in microservices. How you choose to split your elmah.io logs are entirely up to you, but we almost always recommend having a separate log for each service. When doing so, you only want deployment tracking to show the releases from the service you are currently looking at. The problem here is that deployments on elmah.io are shown on all logs as default. To make sure that only deployments related to the service you are looking at are shown, you need to decorate each deployment with the log ID where it belong. The deployments API support this through an optional logId property. If set, the new deployment is only shown on the specified log.","title":"Versioning Different Services"},{"location":"setup-heartbeats/","text":"Set up Heartbeats Set up Heartbeats Additional properties Reason Application and Version elmah.io Heartbeats complements the Error Logging and Uptime Monitoring features already available on elmah.io. Where Uptime Monitoring is based on us pinging your public HTTP endpoints, Heartbeats is the other way around. When configured, your services, scheduled tasks, and websites ping the elmah.io in a specified interval. We call these ping Heartbeats, hence the name of the feature. Whether you should use Uptime Monitoring or Heartbeats to monitor your code, depends on a range of variables. Uptime Monitoring is great at making sure that your public endpoints can be reached from multiple locations. Scheduled tasks and services typically don't have public endpoints and are expected to run at a specified interval. With Heartbeats, setting up monitoring on this kind of services is extremely easy, since elmah.io will automatically detect when an unhealthy heartbeat is received or if no heartbeat is received. Click one of the integrations below or continue reading to learn more about Heartbeats: ASP.NET Core Functions PowerShell cURL Umbraco Hangfire Worker Services AWS Lambda To better understand Heartbeats, let's create a simple example. For detailed instructions on how to set up Heartbeats in different languages and frameworks, select one of the specific articles in the left menu. In this example, we will extend a C# console application, executed as a Windows Scheduled task, with a heartbeat. The scheduled task is run every 30 minutes. Open a log on elmah.io and navigate to the Heartbeats tab: Click the Add Heartbeat button and fill in a name. For Interval we are selecting 30 minutes since the task is scheduled to run every 30 minutes. For Grace , we select 5 minutes to give the task a chance to complete. Selecting 30 and 5 minutes means that elmah.io will log an error if more than 35 minutes pass since we last heard from the task: In order to create heartbeats from our task, we will need an API key, a log ID and a heartbeat ID. Let's start with the API key. Go to the organization settings page and click the API Keys tab. Add a new API key and check the Heartbeats - Write permission only: Copy and store the API key somewhere. Navigate back to your log and click the Instructions link on the newly created Heartbeat. This will reveal the log ID and heartbeat ID. Copy and store both values since we will need them in a minute. Time to do the integration. Like mentioned before, there are multiple ways of invoking the API. For this example, we'll use C#. Install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Extend your C# with the following code: using Elmah.Io.Client; using Elmah.Io.Client.Models; public class Program { public static void Main() { var logId = new Guid(\"LOG_ID\"); var api = ElmahioAPI.Create(\"API_KEY\"); try { // Your task code goes here api.Heartbeats.Healthy(logId, \"HEARTBEAT_ID\"); } catch (Exception e) { api.Heartbeats.Unhealthy(logId, \"HEARTBEAT_ID\"); } } } Replace LOG_ID , API_KEY , and HEARTBEAT_ID with the values stored in the previous steps. When the code runs without throwing an exception, your task now creates a Healthy heartbeat. If an exception occurs, the code creates an Unhealthy heartbeat and uses the exception text as the reason. There's an additional method named Degraded for logging a degraded heartbeat. Depending on the heartbeat status, a log message can be created in the configured log. Log messages are only created on state changes. This means that if logging two Unhealthy requests, only the first request triggers a new error. If logging a Healthy heartbeat after logging an Unhealthy heartbeat, an information message will be logged. Transitioning to Degraded logs a warning. Additional properties Reason The Healthy , Unhealthy , and Degraded methods (or the CreateHeartbeat class when using the raw Create method) accepts an additional parameter named reason . reason can be used to specify why a heartbeat check is either Degraded or Unhealthy . If your service throws an exception, the full exception including its stack trace is a good candidate for the reason parameter. When using integrations like the one with ASP.NET Core Health Checks, the health check report is used as the reason of the failing heartbeat. Application and Version When logging errors through one or more of the integrations, you may already use the Application and/or Version fields to set an application name and software version on all messages logged to elmah.io. Since Heartbeats will do the actual logging of messages in this case, you can configure it to use the same application name and/or version number as your remaining integrations. api.Heartbeats.Unhealthy(logId, \"HEARTBEAT_ID\", application: \"MyApp\", version: \"1.0.0\"); If application name is not configured, all messages logged from Heartbeats will get a default value of Heartbeats . If no version number is configured, log messages from Heartbeats will be assigned the latest version created through Deployment Tracking .","title":"Set up Heartbeats"},{"location":"setup-heartbeats/#set-up-heartbeats","text":"Set up Heartbeats Additional properties Reason Application and Version elmah.io Heartbeats complements the Error Logging and Uptime Monitoring features already available on elmah.io. Where Uptime Monitoring is based on us pinging your public HTTP endpoints, Heartbeats is the other way around. When configured, your services, scheduled tasks, and websites ping the elmah.io in a specified interval. We call these ping Heartbeats, hence the name of the feature. Whether you should use Uptime Monitoring or Heartbeats to monitor your code, depends on a range of variables. Uptime Monitoring is great at making sure that your public endpoints can be reached from multiple locations. Scheduled tasks and services typically don't have public endpoints and are expected to run at a specified interval. With Heartbeats, setting up monitoring on this kind of services is extremely easy, since elmah.io will automatically detect when an unhealthy heartbeat is received or if no heartbeat is received. Click one of the integrations below or continue reading to learn more about Heartbeats: ASP.NET Core Functions PowerShell cURL Umbraco Hangfire Worker Services AWS Lambda To better understand Heartbeats, let's create a simple example. For detailed instructions on how to set up Heartbeats in different languages and frameworks, select one of the specific articles in the left menu. In this example, we will extend a C# console application, executed as a Windows Scheduled task, with a heartbeat. The scheduled task is run every 30 minutes. Open a log on elmah.io and navigate to the Heartbeats tab: Click the Add Heartbeat button and fill in a name. For Interval we are selecting 30 minutes since the task is scheduled to run every 30 minutes. For Grace , we select 5 minutes to give the task a chance to complete. Selecting 30 and 5 minutes means that elmah.io will log an error if more than 35 minutes pass since we last heard from the task: In order to create heartbeats from our task, we will need an API key, a log ID and a heartbeat ID. Let's start with the API key. Go to the organization settings page and click the API Keys tab. Add a new API key and check the Heartbeats - Write permission only: Copy and store the API key somewhere. Navigate back to your log and click the Instructions link on the newly created Heartbeat. This will reveal the log ID and heartbeat ID. Copy and store both values since we will need them in a minute. Time to do the integration. Like mentioned before, there are multiple ways of invoking the API. For this example, we'll use C#. Install the Elmah.Io.Client NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io.Client dotnet add package Elmah.Io.Client <PackageReference Include=\"Elmah.Io.Client\" Version=\"3.*\" /> paket add Elmah.Io.Client Extend your C# with the following code: using Elmah.Io.Client; using Elmah.Io.Client.Models; public class Program { public static void Main() { var logId = new Guid(\"LOG_ID\"); var api = ElmahioAPI.Create(\"API_KEY\"); try { // Your task code goes here api.Heartbeats.Healthy(logId, \"HEARTBEAT_ID\"); } catch (Exception e) { api.Heartbeats.Unhealthy(logId, \"HEARTBEAT_ID\"); } } } Replace LOG_ID , API_KEY , and HEARTBEAT_ID with the values stored in the previous steps. When the code runs without throwing an exception, your task now creates a Healthy heartbeat. If an exception occurs, the code creates an Unhealthy heartbeat and uses the exception text as the reason. There's an additional method named Degraded for logging a degraded heartbeat. Depending on the heartbeat status, a log message can be created in the configured log. Log messages are only created on state changes. This means that if logging two Unhealthy requests, only the first request triggers a new error. If logging a Healthy heartbeat after logging an Unhealthy heartbeat, an information message will be logged. Transitioning to Degraded logs a warning.","title":"Set up Heartbeats"},{"location":"setup-heartbeats/#additional-properties","text":"","title":"Additional properties"},{"location":"setup-heartbeats/#reason","text":"The Healthy , Unhealthy , and Degraded methods (or the CreateHeartbeat class when using the raw Create method) accepts an additional parameter named reason . reason can be used to specify why a heartbeat check is either Degraded or Unhealthy . If your service throws an exception, the full exception including its stack trace is a good candidate for the reason parameter. When using integrations like the one with ASP.NET Core Health Checks, the health check report is used as the reason of the failing heartbeat.","title":"Reason"},{"location":"setup-heartbeats/#application-and-version","text":"When logging errors through one or more of the integrations, you may already use the Application and/or Version fields to set an application name and software version on all messages logged to elmah.io. Since Heartbeats will do the actual logging of messages in this case, you can configure it to use the same application name and/or version number as your remaining integrations. api.Heartbeats.Unhealthy(logId, \"HEARTBEAT_ID\", application: \"MyApp\", version: \"1.0.0\"); If application name is not configured, all messages logged from Heartbeats will get a default value of Heartbeats . If no version number is configured, log messages from Heartbeats will be assigned the latest version created through Deployment Tracking .","title":"Application and Version"},{"location":"setup-uptime-monitoring/","text":"Set Up Uptime Monitoring Set Up Uptime Monitoring Uptime checks SSL certificate expire checks Domain name expire checks elmah.io Uptime Monitoring is the perfect companion for error logging. When your websites log errors, you are notified through elmah.io. But in the case where your website doesn't even respond to web requests, you will need something else to tell you that something is wrong. This is where Uptime Monitoring comes in. When set up, uptime monitoring automatically ping your websites from 5 different locations every 5 minutes. For a complete overview of the possibilities with uptime monitoring, watch this video tutorial: Uptime checks Uptime checks are automatic HTTP requests that you may already know from Azure, Pingdom, or a similar service. Uptime checks are created from the Uptime tab, directly on each log: SSL certificate expire checks Expiring SSL certificates causes errors in your users browser. If you ever tried forgetting to renew a SSL certificate, you know how many problems it can cause. With the SSL check option available when creating a new uptime check, elmah.io automatically validates your SSL certificates daily. When your SSL certificate is up for renewal, we start notifying you through the error logs. Domain name expire checks Much like SSL checks, Domain name expire checks, will notify you through your log, when your domain names are about to expire. To enable this feature, enable the Domain Expiration toggle when creating a new uptime check.","title":"Set up Uptime Monitoring"},{"location":"setup-uptime-monitoring/#set-up-uptime-monitoring","text":"Set Up Uptime Monitoring Uptime checks SSL certificate expire checks Domain name expire checks elmah.io Uptime Monitoring is the perfect companion for error logging. When your websites log errors, you are notified through elmah.io. But in the case where your website doesn't even respond to web requests, you will need something else to tell you that something is wrong. This is where Uptime Monitoring comes in. When set up, uptime monitoring automatically ping your websites from 5 different locations every 5 minutes. For a complete overview of the possibilities with uptime monitoring, watch this video tutorial:","title":"Set Up Uptime Monitoring"},{"location":"setup-uptime-monitoring/#uptime-checks","text":"Uptime checks are automatic HTTP requests that you may already know from Azure, Pingdom, or a similar service. Uptime checks are created from the Uptime tab, directly on each log:","title":"Uptime checks"},{"location":"setup-uptime-monitoring/#ssl-certificate-expire-checks","text":"Expiring SSL certificates causes errors in your users browser. If you ever tried forgetting to renew a SSL certificate, you know how many problems it can cause. With the SSL check option available when creating a new uptime check, elmah.io automatically validates your SSL certificates daily. When your SSL certificate is up for renewal, we start notifying you through the error logs.","title":"SSL certificate expire checks"},{"location":"setup-uptime-monitoring/#domain-name-expire-checks","text":"Much like SSL checks, Domain name expire checks, will notify you through your log, when your domain names are about to expire. To enable this feature, enable the Domain Expiration toggle when creating a new uptime check.","title":"Domain name expire checks"},{"location":"specify-api-key-and-log-id-through-appsettings/","text":"Specify API key and log ID through appSettings When integrating to elmah.io from ASP.NET, MVC, Web API and similar, we use the open source project ELMAH to log uncaught exceptions. ELMAH requires configuration in web.config , which in the case of elmah.io could look something like this: <elmah> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> </elmah> You'd normally use web.config Transformations to specify different API keys and log IDs for different environments (see Use multiple logs for different environments ). When hosting on Microsoft Azure (and other cloud-based offerings), a better approach is to specify configuration in the appSettings element and overwrite values through the web app settings in the Portal. The elmah.io clients built for ASP.NET based web frameworks support this scenario through additional attributes on the <errorLog> element: <appSettings> <add key=\"apiKeyRef\" value=\"API_KEY\" /> <add key=\"logIdRef\" value=\"LOG_ID\" /> </appSettings> <!-- ... --> <elmah> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKeyKey=\"apiKeyRef\" logIdKey=\"logIdRef\" /> </elmah> Unlike the first example, the term Key has been appended to both the apiKey and logId attributes. The values of those attributes needs to match a key specified in appSettings (in this example apiKeyRef and logIdRef ). How you choose to name these keys is entirely up to you, as long as the names match. elmah.io now picks up your API key ( Where is my API key? ) and log ID ( Where is my log ID? ) from the appSettings element and can be overwritten on your production site on Azure.","title":"Specify API key and log ID through appSettings"},{"location":"specify-api-key-and-log-id-through-appsettings/#specify-api-key-and-log-id-through-appsettings","text":"When integrating to elmah.io from ASP.NET, MVC, Web API and similar, we use the open source project ELMAH to log uncaught exceptions. ELMAH requires configuration in web.config , which in the case of elmah.io could look something like this: <elmah> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> </elmah> You'd normally use web.config Transformations to specify different API keys and log IDs for different environments (see Use multiple logs for different environments ). When hosting on Microsoft Azure (and other cloud-based offerings), a better approach is to specify configuration in the appSettings element and overwrite values through the web app settings in the Portal. The elmah.io clients built for ASP.NET based web frameworks support this scenario through additional attributes on the <errorLog> element: <appSettings> <add key=\"apiKeyRef\" value=\"API_KEY\" /> <add key=\"logIdRef\" value=\"LOG_ID\" /> </appSettings> <!-- ... --> <elmah> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKeyKey=\"apiKeyRef\" logIdKey=\"logIdRef\" /> </elmah> Unlike the first example, the term Key has been appended to both the apiKey and logId attributes. The values of those attributes needs to match a key specified in appSettings (in this example apiKeyRef and logIdRef ). How you choose to name these keys is entirely up to you, as long as the names match. elmah.io now picks up your API key ( Where is my API key? ) and log ID ( Where is my log ID? ) from the appSettings element and can be overwritten on your production site on Azure.","title":"Specify API key and log ID through appSettings"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/","text":"Tips and tricks to stay below your message limit Tips and tricks to stay below your message limit Ignore Rules Filters Ignore future messages like this Disable logs Client-side message filtering Monitor current usage Fix bugs Purchase a top-up Upgrading to the next plan Each plan on elmah.io include a maximum number of messages per month. The number of messages are calculated from how many times your applications have called our API and successfully stored a message (in most cases messages equals errors). Deleting messages either one by one or in batches are fully supported, but do not result in a decrease in the current message count. Our costs are primarily around receiving, indexing and notifying about messages, why we cannot allow someone on a lower plan like the Small Business, to log millions and yet millions of messages and then just clean up regularly. We're sure that everyone understand the challenge here. With that said, we want to help you stay within your message limits. Luckily, there's a lot of ways to limit messages. This article contains a list of the most common tactics to staying below your message limit. Ignore Rules The easiest way to limit logged messages, is by ignoring some of them. Ignored messages do not count towards the message limit. Message rules can be configured through the Rules tab on the Log Settings view. Rules consist of a query and an action. The query can either be a full-text query or written using Lucene Query Syntax. To create a new ignore rule, input a query on the Rules tab: All new rules are created with an ignore action as default, why you don't need to click the Then link for this type of rules. The example above, ignore all messages with a status code of 404 . For more information about the possibilities with rules, check out Creating Rules to Perform Actions on Messages . Filters Filters are basically Ignore Rules in disguise. With Filters we have collected the most common ignore rules and made them available as a set of checkboxes. To ignore all message matching a specific filter, enable one of the checkboxes on the Filters tab on Log Settings: If your website is available for everyone to access, ignoring known crawlers, bots and spiders is a good idea in most cases. Filtering below warning can also be a good idea, unless you are using elmah.io to log all log severities from a logging framework like NLog or Serilog. If staying within the message limit is more important than getting the full picture of the errors generated by your website, there are a couple of filters that will help you with that. The Filter Known filter will make sure that only one instance of each error is logged. If you still want to log multiple instances but stop at some point, the Filter Burst filter will stop logging after 50 instances logged. Finally, you can set a limit on how many errors you want logged to a specific log each month, by inputting a number in the Filter Limit filter. Please notice that using any of these last three filters, will cause inconsistent results in different graphs and features (like the spike detection). They can solve the problem of logging too much, but it is a sign that you are logging more data than included in your plan. A perfectly valid solution is to purchase a larger plan, get your logging under control (maybe even fix some errors?) and then downgrade when you are ready. Ignore future messages like this Sometimes you may find yourself on the Search tab with a search result thinking: \"I don't really care about these messages\". By clicking the caret next to the query filters, an Ignore future messages like this option is revealed: Clicking this option automatically ignore any future messages matching your current search result. Disable logs Each log can be disabled from Log Settings: Disables logs are shown as semi transparent on the dashboard, to help you remember that you disabled a log. Client-side message filtering Most of our clients support client filtering. All of the filtering options described above, filters messages server-side. This means that your application still communicates with elmah.io's API and need to wait for that to answer (even fore ignored messages). Filtering client-side from ASP.NET, MVC, Web API and other frameworks built on top of ASP.NET, can be done using ELMAH's (the open source project) filtering feature. To filter message, create a method named ErrorLog_Filtering in the Global.asax.cs file: void ErrorLog_Filtering(object sender, ExceptionFilterEventArgs args) { var httpContext = args.Context as HttpContext; if (httpContext.Response.StatusCode == 404) { args.Dismiss(); } } If you're using ASP.NET Core, our client supports the OnFilter action: services.AddElmahIo(o => { // ... o.OnFilter = message => { return message.StatusCode == 404; }; }); Monitor current usage We send you an email when you have used 90% of your limit and again when reaching the limit. Monitoring your usage is a good supplement to the emails, since you are able to react early on (by upgrading, ignoring errors or something else). There's a usage graph on the Organisation Settings view: By clicking the question mark next to the counter, you will be able to see which logs that are taking up space: Fix bugs Seeing the same error over and over again? Maybe the best idea is to fix it :) I mean, that's the whole purpose of elmah.io: to help you fix bugs. And remember, the less bugs you have, the cheaper elmah.io gets. The ultimate motivation! Purchase a top-up Sometimes, a spike in errors can be caused by unexpected events like a blackhat bot deciding to bombard your site with requests or a junior dev on your team accidentally enabling verbose logging. In these cases, purchasing a top-up may be a better solution than permanently upgrading your plan. Top-ups can be purchased from your subscription, when you reach 90% of your included messages. Top-ups are purchased in bundles of 25,000 messages, valid for the rest of the calendar month. Upgrading to the next plan If you constantly go over the limit, you have probably reached a point where you will need to upgrade to a larger plan. You can upgrade and downgrade at any time, why upgrading a few months (until you get errors under control) and then downgrade again, is perfectly fine.","title":"Tips and tricks to stay below your message limit"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#tips-and-tricks-to-stay-below-your-message-limit","text":"Tips and tricks to stay below your message limit Ignore Rules Filters Ignore future messages like this Disable logs Client-side message filtering Monitor current usage Fix bugs Purchase a top-up Upgrading to the next plan Each plan on elmah.io include a maximum number of messages per month. The number of messages are calculated from how many times your applications have called our API and successfully stored a message (in most cases messages equals errors). Deleting messages either one by one or in batches are fully supported, but do not result in a decrease in the current message count. Our costs are primarily around receiving, indexing and notifying about messages, why we cannot allow someone on a lower plan like the Small Business, to log millions and yet millions of messages and then just clean up regularly. We're sure that everyone understand the challenge here. With that said, we want to help you stay within your message limits. Luckily, there's a lot of ways to limit messages. This article contains a list of the most common tactics to staying below your message limit.","title":"Tips and tricks to stay below your message limit"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#ignore-rules","text":"The easiest way to limit logged messages, is by ignoring some of them. Ignored messages do not count towards the message limit. Message rules can be configured through the Rules tab on the Log Settings view. Rules consist of a query and an action. The query can either be a full-text query or written using Lucene Query Syntax. To create a new ignore rule, input a query on the Rules tab: All new rules are created with an ignore action as default, why you don't need to click the Then link for this type of rules. The example above, ignore all messages with a status code of 404 . For more information about the possibilities with rules, check out Creating Rules to Perform Actions on Messages .","title":"Ignore Rules"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#filters","text":"Filters are basically Ignore Rules in disguise. With Filters we have collected the most common ignore rules and made them available as a set of checkboxes. To ignore all message matching a specific filter, enable one of the checkboxes on the Filters tab on Log Settings: If your website is available for everyone to access, ignoring known crawlers, bots and spiders is a good idea in most cases. Filtering below warning can also be a good idea, unless you are using elmah.io to log all log severities from a logging framework like NLog or Serilog. If staying within the message limit is more important than getting the full picture of the errors generated by your website, there are a couple of filters that will help you with that. The Filter Known filter will make sure that only one instance of each error is logged. If you still want to log multiple instances but stop at some point, the Filter Burst filter will stop logging after 50 instances logged. Finally, you can set a limit on how many errors you want logged to a specific log each month, by inputting a number in the Filter Limit filter. Please notice that using any of these last three filters, will cause inconsistent results in different graphs and features (like the spike detection). They can solve the problem of logging too much, but it is a sign that you are logging more data than included in your plan. A perfectly valid solution is to purchase a larger plan, get your logging under control (maybe even fix some errors?) and then downgrade when you are ready.","title":"Filters"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#ignore-future-messages-like-this","text":"Sometimes you may find yourself on the Search tab with a search result thinking: \"I don't really care about these messages\". By clicking the caret next to the query filters, an Ignore future messages like this option is revealed: Clicking this option automatically ignore any future messages matching your current search result.","title":"Ignore future messages like this"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#disable-logs","text":"Each log can be disabled from Log Settings: Disables logs are shown as semi transparent on the dashboard, to help you remember that you disabled a log.","title":"Disable logs"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#client-side-message-filtering","text":"Most of our clients support client filtering. All of the filtering options described above, filters messages server-side. This means that your application still communicates with elmah.io's API and need to wait for that to answer (even fore ignored messages). Filtering client-side from ASP.NET, MVC, Web API and other frameworks built on top of ASP.NET, can be done using ELMAH's (the open source project) filtering feature. To filter message, create a method named ErrorLog_Filtering in the Global.asax.cs file: void ErrorLog_Filtering(object sender, ExceptionFilterEventArgs args) { var httpContext = args.Context as HttpContext; if (httpContext.Response.StatusCode == 404) { args.Dismiss(); } } If you're using ASP.NET Core, our client supports the OnFilter action: services.AddElmahIo(o => { // ... o.OnFilter = message => { return message.StatusCode == 404; }; });","title":"Client-side message filtering"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#monitor-current-usage","text":"We send you an email when you have used 90% of your limit and again when reaching the limit. Monitoring your usage is a good supplement to the emails, since you are able to react early on (by upgrading, ignoring errors or something else). There's a usage graph on the Organisation Settings view: By clicking the question mark next to the counter, you will be able to see which logs that are taking up space:","title":"Monitor current usage"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#fix-bugs","text":"Seeing the same error over and over again? Maybe the best idea is to fix it :) I mean, that's the whole purpose of elmah.io: to help you fix bugs. And remember, the less bugs you have, the cheaper elmah.io gets. The ultimate motivation!","title":"Fix bugs"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#purchase-a-top-up","text":"Sometimes, a spike in errors can be caused by unexpected events like a blackhat bot deciding to bombard your site with requests or a junior dev on your team accidentally enabling verbose logging. In these cases, purchasing a top-up may be a better solution than permanently upgrading your plan. Top-ups can be purchased from your subscription, when you reach 90% of your included messages. Top-ups are purchased in bundles of 25,000 messages, valid for the rest of the calendar month.","title":"Purchase a top-up"},{"location":"tips-and-tricks-to-stay-below-your-message-limit/#upgrading-to-the-next-plan","text":"If you constantly go over the limit, you have probably reached a point where you will need to upgrade to a larger plan. You can upgrade and downgrade at any time, why upgrading a few months (until you get errors under control) and then downgrade again, is perfectly fine.","title":"Upgrading to the next plan"},{"location":"upgrade-elmah-io-from-v2-to-v3/","text":"Upgrade elmah.io from v2 to v3 When we launched the new version of our API ( v3 ), we used the jump in major version to fix some issues that would require major changes in our client. One of them being a move to netstandard, which makes the new client usable from .NET Core. With interface changes in the client, upgrading from 2.x to 3.x requires more than simply upgrading the NuGet package. This is a guide to upgrading the Elmah.Io package. If you are logging to elmah.io from ASP.NET Core, you are already using the 3.x client. Updating the NuGet package First, you need to upgrade the Elmah.Io NuGet package: Update-Package Elmah.Io This installs the latest 3.x client. After doing so, we recommend to update to the latest Elmah.Io.Client package as well (updating Elmah.Io already updated Elmah.Io.Client, but to the lowest possible version): Update-Package Elmah.Io.Client The elmah.io.core package is no longer needed and can be uninstalled: Uninstall-Package elmah.io.core Next, you will need to add your API key to your web.config . Where the 2.x client only required a log ID in order to log messages to elmah.io, the new API improves security by introducing API keys ( Where is my API key? ). Copy your API key and extend the errorLog -element in web.config : <elmah> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> </elmah> If you didn't utilize elmah.io's code from C#, you are ready to rock and roll. Code changes The 3.x client is auto generated from our new Swagger endpoint. This means that the code doesn't work like previously. We have tried to create extension methods to make some of the API work like previously, but since the client now supports both Messages, Logs and Deployments, code changes are needed. If you are using the ErrorSignal class from ELMAH (the open source project) to log exceptions manually, everything works as previously. If you are using methods from the Elmah.Io.Client package, there's a new API documented here: Logging from Console . Elmah.Io.Mvc and Elmah.Io.WebApi When launching the packages for 3.x, we also decided to create two new proxy packages: Elmah.Io.Mvc and Elmah.Io.WebApi. The reason I call them proxy packages is, that they do nothing more than simply install the dependencies needed to log from each framework. The packages are intended for new installs only, so if your code already logs exceptions to elmah.io, there is no need to install any of these packages.","title":"Upgrade elmah.io from v2 to v3"},{"location":"upgrade-elmah-io-from-v2-to-v3/#upgrade-elmahio-from-v2-to-v3","text":"When we launched the new version of our API ( v3 ), we used the jump in major version to fix some issues that would require major changes in our client. One of them being a move to netstandard, which makes the new client usable from .NET Core. With interface changes in the client, upgrading from 2.x to 3.x requires more than simply upgrading the NuGet package. This is a guide to upgrading the Elmah.Io package. If you are logging to elmah.io from ASP.NET Core, you are already using the 3.x client.","title":"Upgrade elmah.io from v2 to v3"},{"location":"upgrade-elmah-io-from-v2-to-v3/#updating-the-nuget-package","text":"First, you need to upgrade the Elmah.Io NuGet package: Update-Package Elmah.Io This installs the latest 3.x client. After doing so, we recommend to update to the latest Elmah.Io.Client package as well (updating Elmah.Io already updated Elmah.Io.Client, but to the lowest possible version): Update-Package Elmah.Io.Client The elmah.io.core package is no longer needed and can be uninstalled: Uninstall-Package elmah.io.core Next, you will need to add your API key to your web.config . Where the 2.x client only required a log ID in order to log messages to elmah.io, the new API improves security by introducing API keys ( Where is my API key? ). Copy your API key and extend the errorLog -element in web.config : <elmah> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> </elmah> If you didn't utilize elmah.io's code from C#, you are ready to rock and roll.","title":"Updating the NuGet package"},{"location":"upgrade-elmah-io-from-v2-to-v3/#code-changes","text":"The 3.x client is auto generated from our new Swagger endpoint. This means that the code doesn't work like previously. We have tried to create extension methods to make some of the API work like previously, but since the client now supports both Messages, Logs and Deployments, code changes are needed. If you are using the ErrorSignal class from ELMAH (the open source project) to log exceptions manually, everything works as previously. If you are using methods from the Elmah.Io.Client package, there's a new API documented here: Logging from Console .","title":"Code changes"},{"location":"upgrade-elmah-io-from-v2-to-v3/#elmahiomvc-and-elmahiowebapi","text":"When launching the packages for 3.x, we also decided to create two new proxy packages: Elmah.Io.Mvc and Elmah.Io.WebApi. The reason I call them proxy packages is, that they do nothing more than simply install the dependencies needed to log from each framework. The packages are intended for new installs only, so if your code already logs exceptions to elmah.io, there is no need to install any of these packages.","title":"Elmah.Io.Mvc and Elmah.Io.WebApi"},{"location":"use-extended-user-details-without-email-as-id/","text":"Use Extended User Details without Email as Id Most of our integrations automatically logs the user identity as part of the error. To make that happen, packages typically use the identity object on the current thread, which gets set by most authentication frameworks for .NET (like ASP.NET Membership Provider and ASP.NET Core Identity). You may use the user's email as key or a database identifier. If you are using an email, you are already covered and able to see Extended User Details. If not, you need to provide elmah.io with a little help. In order to tell elmah.io about the user's email and still keeping the identifier in the user field, you can enrich the message with a piece of custom data, before sending it off to elmah.io. By putting the user's email in a Data item named X-ELMAHIO-USEREMAIL Extended User Details will pick this up and show the correct user. How you set the Data item is dependent of the elmah.io NuGet package you are using. For ASP.NET, MVC, or Web API, the code could look like this: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { if (string.IsNullOrWhiteSpace(args.Message.User)) return; var db = /*...*/; var user = db.GetById<User>(args.Message.User); args.Message.Data.Add(new Item {Key = \"X-ELMAHIO-USEREMAIL\", Value = user.Email}); } For ASP.NET Core the code could look like this: services.AddElmahIo(o => { // ... o.OnMessage = message => { if (string.IsNullOrWhiteSpace(message.User)) return; var db = /*...*/; var user = db.GetById<User>(message.User); message.Data.Add(new Item {Key = \"X-ELMAHIO-USEREMAIL\", Value = user.Email}); }; }); OnMessage event handlers are executed just before a message is send to elmah.io. In the body of the event handler, the user's email is fetched from the database by calling the GetById method. How you will be able to convert the user ID to an email depends on your tech stack, but you get the picture. That's it! A few lines of code and you are able to watch every little details about the users experiencing problems on your website:","title":"Use Extended User Details without Email as Id"},{"location":"use-extended-user-details-without-email-as-id/#use-extended-user-details-without-email-as-id","text":"Most of our integrations automatically logs the user identity as part of the error. To make that happen, packages typically use the identity object on the current thread, which gets set by most authentication frameworks for .NET (like ASP.NET Membership Provider and ASP.NET Core Identity). You may use the user's email as key or a database identifier. If you are using an email, you are already covered and able to see Extended User Details. If not, you need to provide elmah.io with a little help. In order to tell elmah.io about the user's email and still keeping the identifier in the user field, you can enrich the message with a piece of custom data, before sending it off to elmah.io. By putting the user's email in a Data item named X-ELMAHIO-USEREMAIL Extended User Details will pick this up and show the correct user. How you set the Data item is dependent of the elmah.io NuGet package you are using. For ASP.NET, MVC, or Web API, the code could look like this: Elmah.ErrorLog.GetDefault(null); // Forces creation of logger client var logger = ErrorLog.Client; logger.OnMessage += (sender, args) => { if (string.IsNullOrWhiteSpace(args.Message.User)) return; var db = /*...*/; var user = db.GetById<User>(args.Message.User); args.Message.Data.Add(new Item {Key = \"X-ELMAHIO-USEREMAIL\", Value = user.Email}); } For ASP.NET Core the code could look like this: services.AddElmahIo(o => { // ... o.OnMessage = message => { if (string.IsNullOrWhiteSpace(message.User)) return; var db = /*...*/; var user = db.GetById<User>(message.User); message.Data.Add(new Item {Key = \"X-ELMAHIO-USEREMAIL\", Value = user.Email}); }; }); OnMessage event handlers are executed just before a message is send to elmah.io. In the body of the event handler, the user's email is fetched from the database by calling the GetById method. How you will be able to convert the user ID to an email depends on your tech stack, but you get the picture. That's it! A few lines of code and you are able to watch every little details about the users experiencing problems on your website:","title":"Use Extended User Details without Email as Id"},{"location":"use-multiple-logs-for-different-environments/","text":"Use multiple logs for different environments We bet that you use at least two environments for hosting your website: localhost and a production environment. You probably need to log website errors on all your environments, but you don\u2019t want to mix errors from different environments in the same error log. Lucky for you, Microsoft provides a great way of differentiating configuration for different environments called Web Config transformation . To avoid spending numerous hours of debugging, remember that Web Config transformations are only run on deploy and not on build. In other words, deploy your website using Visual Studio, MSBuild or third for the transformations to replace the right ELMAH config. Whether or not you want errors from localhost logged on elmah.io, start by installing the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io Then choose one of the two paths below. Logging to elmah.io from both localhost and production Create two new logs at the elmah.io website called something like \u201cMy website\u201d and \u201cMy website development\u201d. The naming isn\u2019t really important, so pick something telling. During installation of the elmah.io package, NuGet will ask you for your elmah.io log id. In this dialog input the log id from the log named \u201cMy website development\u201d. The default configuration is used when running your website locally. When installed open the web.release.config file and add the following code: <elmah xdt:Transform=\"Replace\"> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> <security allowRemoteAccess=\"false\" /> </elmah> Replace the API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log ID ( Where is my log ID? ). For more information about Web.config transformations, check out the blog post Web.config transformations - The definitive syntax guide . For help debugging problems, we have created the Web.config Transformation Tester . That\u2019s it! You can now build and deploy your website using different configurations. When nothing is changed, Visual Studio will build your website using the Debug configuration. This configuration looks for the ELMAH code in the web.debug.config file. We didn\u2019t add any ELMAH configuration to this file, why the default values from web.config are used. When selecting the Release configuration, Web. Config transformations will replace the default values in web.config with the new ELMAH configuration from web.release.config . Logging to elmah.io from production only During the installation, NuGet will ask you for your elmah.io log id. You don't need to write anything in this dialog, since we will remove the default elmah.io config in a moment. When installed open the web.config file and locate the <elmah> element. Remove the <errorLog> element and set the allowRemoveAccess attribute to true . Your configuration should look like this now: <elmah> <security allowRemoteAccess=\"true\" /> </elmah> Open the web.release.config file and insert the following code: <elmah xdt:Transform=\"Replace\"> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> <security allowRemoteAccess=\"false\" /> </elmah> Like above, replace API_KEY and LOG_ID with the correct values. Errors happening on your local machine will be logged using ELMAH's default error logger (in-memory) and errors happening in production will be logged to elmah.io.","title":"Use multiple logs for different environments"},{"location":"use-multiple-logs-for-different-environments/#use-multiple-logs-for-different-environments","text":"We bet that you use at least two environments for hosting your website: localhost and a production environment. You probably need to log website errors on all your environments, but you don\u2019t want to mix errors from different environments in the same error log. Lucky for you, Microsoft provides a great way of differentiating configuration for different environments called Web Config transformation . To avoid spending numerous hours of debugging, remember that Web Config transformations are only run on deploy and not on build. In other words, deploy your website using Visual Studio, MSBuild or third for the transformations to replace the right ELMAH config. Whether or not you want errors from localhost logged on elmah.io, start by installing the Elmah.Io NuGet package: Package Manager .NET CLI PackageReference Paket CLI Install-Package Elmah.Io dotnet add package Elmah.Io <PackageReference Include=\"Elmah.Io\" Version=\"3.*\" /> paket add Elmah.Io Then choose one of the two paths below.","title":"Use multiple logs for different environments"},{"location":"use-multiple-logs-for-different-environments/#logging-to-elmahio-from-both-localhost-and-production","text":"Create two new logs at the elmah.io website called something like \u201cMy website\u201d and \u201cMy website development\u201d. The naming isn\u2019t really important, so pick something telling. During installation of the elmah.io package, NuGet will ask you for your elmah.io log id. In this dialog input the log id from the log named \u201cMy website development\u201d. The default configuration is used when running your website locally. When installed open the web.release.config file and add the following code: <elmah xdt:Transform=\"Replace\"> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> <security allowRemoteAccess=\"false\" /> </elmah> Replace the API_KEY with your API key ( Where is my API key? ) and LOG_ID with your log ID ( Where is my log ID? ). For more information about Web.config transformations, check out the blog post Web.config transformations - The definitive syntax guide . For help debugging problems, we have created the Web.config Transformation Tester . That\u2019s it! You can now build and deploy your website using different configurations. When nothing is changed, Visual Studio will build your website using the Debug configuration. This configuration looks for the ELMAH code in the web.debug.config file. We didn\u2019t add any ELMAH configuration to this file, why the default values from web.config are used. When selecting the Release configuration, Web. Config transformations will replace the default values in web.config with the new ELMAH configuration from web.release.config .","title":"Logging to elmah.io from both localhost and production"},{"location":"use-multiple-logs-for-different-environments/#logging-to-elmahio-from-production-only","text":"During the installation, NuGet will ask you for your elmah.io log id. You don't need to write anything in this dialog, since we will remove the default elmah.io config in a moment. When installed open the web.config file and locate the <elmah> element. Remove the <errorLog> element and set the allowRemoveAccess attribute to true . Your configuration should look like this now: <elmah> <security allowRemoteAccess=\"true\" /> </elmah> Open the web.release.config file and insert the following code: <elmah xdt:Transform=\"Replace\"> <errorLog type=\"Elmah.Io.ErrorLog, Elmah.Io\" apiKey=\"API_KEY\" logId=\"LOG_ID\" /> <security allowRemoteAccess=\"false\" /> </elmah> Like above, replace API_KEY and LOG_ID with the correct values. Errors happening on your local machine will be logged using ELMAH's default error logger (in-memory) and errors happening in production will be logged to elmah.io.","title":"Logging to elmah.io from production only"},{"location":"using-different-logs-per-environment-in-aspnet-core/","text":"Using different logs per environment in ASP.NET Core We are often asked the question: Should I create a log per environment and how do I set it up with ASP.NET Core. Creating a log per environment (staging, production, etc.) is a good idea since you probably want different notification rules and/or user access depending on the environment. We usually recommend a log per environment and disabling logging when running on localhost. There can be advantages in logging errors from developer machines, but every error counts against your monthly quota. This document provides a range of possibilities for setting up a log per environment. Using appsettings.{Environment}.json All ASP.NET Core websites read an environment variable named ASPNETCORE_ENVIRONMENT . The value can be used to set config variables depending on the current environment. The feature works a bit like Web.config transformations that you may remember from the good old ASP.NET days. The value of ASPNETCORE_ENVIRONMENT can be tailored to your need but the following three values are provided out of the box: Development , Staging , and Production . To only add elmah.io when on staging or production, you can add the following code when setting up the elmah.io middleware: public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... if (env.IsProduction() || env.IsStaging()) { app.UseElmahIo(); } // ... } To create errors in different logs depending on the current environment, create two new files: appsettings.staging.json and appsettings.production.json . Add the ElmahIo config section to both files: { \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Inside each file, replace API_KEY with your API key and LOG_ID with the different log IDs. The downside of this approach is that you have your production API key and log ID in source control. Using Azure Application settings If you are hosting on Azure (other cloud hosting platforms have a similar feature), you can utilize the built-in Application settings feature to avoid adding API keys and log IDs to source control. Using application settings requires you to specify your elmah.io configuration in the appsettings.json file or one of the environment-specific files as shown above. To replace the values inside the ApiKey and LogId properties, use the colon syntax as shown here: (replace API_KEY and LOG_ID with your staging or production values depending on which environment you are configuring)","title":"Using different logs per environment in ASP.NET Core"},{"location":"using-different-logs-per-environment-in-aspnet-core/#using-different-logs-per-environment-in-aspnet-core","text":"We are often asked the question: Should I create a log per environment and how do I set it up with ASP.NET Core. Creating a log per environment (staging, production, etc.) is a good idea since you probably want different notification rules and/or user access depending on the environment. We usually recommend a log per environment and disabling logging when running on localhost. There can be advantages in logging errors from developer machines, but every error counts against your monthly quota. This document provides a range of possibilities for setting up a log per environment.","title":"Using different logs per environment in ASP.NET Core"},{"location":"using-different-logs-per-environment-in-aspnet-core/#using-appsettingsenvironmentjson","text":"All ASP.NET Core websites read an environment variable named ASPNETCORE_ENVIRONMENT . The value can be used to set config variables depending on the current environment. The feature works a bit like Web.config transformations that you may remember from the good old ASP.NET days. The value of ASPNETCORE_ENVIRONMENT can be tailored to your need but the following three values are provided out of the box: Development , Staging , and Production . To only add elmah.io when on staging or production, you can add the following code when setting up the elmah.io middleware: public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // ... if (env.IsProduction() || env.IsStaging()) { app.UseElmahIo(); } // ... } To create errors in different logs depending on the current environment, create two new files: appsettings.staging.json and appsettings.production.json . Add the ElmahIo config section to both files: { \"ElmahIo\": { \"ApiKey\": \"API_KEY\", \"LogId\": \"LOG_ID\" } } Inside each file, replace API_KEY with your API key and LOG_ID with the different log IDs. The downside of this approach is that you have your production API key and log ID in source control.","title":"Using appsettings.{Environment}.json"},{"location":"using-different-logs-per-environment-in-aspnet-core/#using-azure-application-settings","text":"If you are hosting on Azure (other cloud hosting platforms have a similar feature), you can utilize the built-in Application settings feature to avoid adding API keys and log IDs to source control. Using application settings requires you to specify your elmah.io configuration in the appsettings.json file or one of the environment-specific files as shown above. To replace the values inside the ApiKey and LogId properties, use the colon syntax as shown here: (replace API_KEY and LOG_ID with your staging or production values depending on which environment you are configuring)","title":"Using Azure Application settings"},{"location":"using-the-elmah-io-extension-for-visual-studio/","text":"Using the elmah.io extension for Visual Studio Being able to focus on .NET developers makes it possible to do all kinds of cool things. Like building an elmah.io extension for Visual Studio. That's exactly what we've done and here's how to use it. Installation Download the elmah.io extension from the Visual Studio Marketplace. Don't use the Extensions and Updates feature inside Visual Studio, since Visual Studio causes a problem with installing extensions in previous versions. Double/click the downloaded VSIX and enable elmah.io in the versions of Visual Studio of your choice. The extension supports Visual Studio 2015, 2017 and 2019. Usage Inside Visual Studio navigate to View | Other Windows | elmah.io or simply search for elmah.io in the Quick Launcher ( Ctrl + Q ). You'll see the elmah.io window somewhere. Click the Sign In button and sign in with a username/password or one of the social providers: If you are part of multiple elmah.io organizations, select the one you want to access: If this is the first time someone is browsing the chosen organization from Visual Studio, authorize the creation of a new API key: Once logged in, the list of logs is populated with all of your logs defined at elmah.io. Select a log and click the search icon: Log messages can be filtered by date range, full-text search and using Lucene query language as already known from the elmah.io UI. To inspect a single message, double-click it and the message details window will open: The toolbar in the top provides a couple of options: View the message on elmah.io, hide the message and delete the message.","title":"Using the elmah.io extension for Visual Studio"},{"location":"using-the-elmah-io-extension-for-visual-studio/#using-the-elmahio-extension-for-visual-studio","text":"Being able to focus on .NET developers makes it possible to do all kinds of cool things. Like building an elmah.io extension for Visual Studio. That's exactly what we've done and here's how to use it.","title":"Using the elmah.io extension for Visual Studio"},{"location":"using-the-elmah-io-extension-for-visual-studio/#installation","text":"Download the elmah.io extension from the Visual Studio Marketplace. Don't use the Extensions and Updates feature inside Visual Studio, since Visual Studio causes a problem with installing extensions in previous versions. Double/click the downloaded VSIX and enable elmah.io in the versions of Visual Studio of your choice. The extension supports Visual Studio 2015, 2017 and 2019.","title":"Installation"},{"location":"using-the-elmah-io-extension-for-visual-studio/#usage","text":"Inside Visual Studio navigate to View | Other Windows | elmah.io or simply search for elmah.io in the Quick Launcher ( Ctrl + Q ). You'll see the elmah.io window somewhere. Click the Sign In button and sign in with a username/password or one of the social providers: If you are part of multiple elmah.io organizations, select the one you want to access: If this is the first time someone is browsing the chosen organization from Visual Studio, authorize the creation of a new API key: Once logged in, the list of logs is populated with all of your logs defined at elmah.io. Select a log and click the search icon: Log messages can be filtered by date range, full-text search and using Lucene query language as already known from the elmah.io UI. To inspect a single message, double-click it and the message details window will open: The toolbar in the top provides a couple of options: View the message on elmah.io, hide the message and delete the message.","title":"Usage"},{"location":"using-the-rest-api/","text":"Using the REST API Using the REST API Security Messages Creating messages Getting a message Searching messages Deleting a message Deleting messages Hiding a message Under the hood, everything related to communicating with elmah.io happens through our REST API. In this article, we will present the possibilities using the API in a use case driven approach. For a details reference of the various endpoints, visit the API V3 documentation . Security Security is implemented using API keys ( Where is my API key? ). When creating a new organization, a default API key is automatically created. You can create new keys and revoke an existing key, if you suspect that the key has been compromised. The API key acts as a secret and should not be available to people outside your team/organization. All requests to the elmah.io API needs the API key as either a HTTP header or query string parameter named api_key like this: GET https://api.elmah.io/v3/messages/LOG_ID?api_key=MY_API_KEY Messages Creating messages Before doing anything, we will need some messages to play with. The Create Message endpoint does just that. To create a simple message, POST to: POST https://api.elmah.io/v3/messages/LOG_ID with a JSON body: { \"title\": \"This is a test message\" } (replace LOG_ID with your log ID): The title field is the only required field on a message, but fields for specifying severity, timestamp etc. are there. For more information, check out the documentation . If everything where successful, the API returns a HTTP status code of 201 and a location to where to fetch the new message. If the endpoint fails, the response will contain a description of what went wrong. Forgetting to set Content-Length , Content-Type and similar, will result in an invalid request. Getting a message In the example above, the API returned the URL for getting the newly created message: GET https://api.elmah.io/v3/messages/LOG_ID/81C7C282C9FDAEA3 By making a GET request to this URL, we get back the message details: { \"id\": \"99CDEA3D6A631F09\", \"title\": \"This is a test message\", \"dateTime\": \"2016-07-03T14:25:46.087857Z\", \"severity\": \"Information\" } As shown in the returned body, elmah.io automatically inserted some missing fields like a timestamp and a severity. If no severity is specified during creating, a message is threated as information. Searching messages For the demo, we have inserted a couple of additional messages, which leads us to the next endpoint: searching messages. The search endpoint shares the root path with the get message endpoint, but only take a log ID. The simplest possible configuration, queries the API for a list of the 15 most recent messages by calling: GET https://api.elmah.io/v3/messages/LOG_ID The response body looks like this: { \"messages\": [ { \"id\": \"81C7C282C9FDAEA3\", \"title\": \"This is another test message\", \"dateTime\": \"2016-07-03T14:31:45.053851Z\", \"severity\": \"Information\" }, { \"id\": \"99CDEA3D6A631F09\", \"title\": \"This is a test message\", \"dateTime\": \"2016-07-03T14:25:46.087857Z\", \"severity\": \"Information\" }, // ... ], \"total\": 42 } For simplicity, the response has been simplified by not showing all of the results. The important thing to notice here, is the list of messages and the total count. messages contain 15 messages, which is the default page size in the search endpoint. To increase the number of returned messages, set the pagesize parameter in the URL (max 100 messages per request). The total count tells you, if there are more messages matching your search. To select messages from the next page, use the pageindex parameter. Returning all messages may be fine, but being able to search by terms is even more fun. To search, use the query , from and to parameters as shown here: GET https://api.elmah.io/v3/messages/LOG_ID?query=another Searching for another will return the following response: { \"messages\": [ { \"id\": \"81C7C282C9FDAEA3\", \"title\": \"This is another test message\", \"dateTime\": \"2016-07-03T14:25:46.087857Z\", \"severity\": \"Information\" } ], \"total\": 1 } Now only 81C7C282C9FDAEA3 shows up, since that message contains the text another in the title field. Like specifying the query parameter, you can limit the number of messages using the from , to and pagesize parameters. Deleting a message When fixing the bug causing an error logged at elmah.io, you may want to delete the error. Deleting a single error is as easy as fetching it. Create a DELETE request to the errors unique URL: DELETE https://api.elmah.io/v3/messages/LOG_ID/81C7C282C9FDAEA3 When successfully deleted, the delete endpoint returns a HTTP status code of 200 . Deleting messages Deleting messages one by one can be tedious work. To delete multiple errors, you can utilize the Delete Messages endpoint by creating a DELETE request to: DELETE https://api.elmah.io/v3/messages/LOG_ID The request must contain a body with at least a query: { \"query\": \"test\" } An option for deleting messages by date range is available as well. Check out the API documentation for details. Hiding a message Depending on your use case, you may want to hide a message, rather than deleting it. Hidden messages are not shown as default through neither the UI, nor the REST API. But you will be able to search for them by enabling the Hidden checkbox on the UI. To hide a message, use the _hide endpoints like this: POST https://api.elmah.io/v3/messages/LOG_ID/99CDEA3D6A631F09/_hide If successful, the endpoint returns a HTTP status code of 200 .","title":"Using the REST API"},{"location":"using-the-rest-api/#using-the-rest-api","text":"Using the REST API Security Messages Creating messages Getting a message Searching messages Deleting a message Deleting messages Hiding a message Under the hood, everything related to communicating with elmah.io happens through our REST API. In this article, we will present the possibilities using the API in a use case driven approach. For a details reference of the various endpoints, visit the API V3 documentation .","title":"Using the REST API"},{"location":"using-the-rest-api/#security","text":"Security is implemented using API keys ( Where is my API key? ). When creating a new organization, a default API key is automatically created. You can create new keys and revoke an existing key, if you suspect that the key has been compromised. The API key acts as a secret and should not be available to people outside your team/organization. All requests to the elmah.io API needs the API key as either a HTTP header or query string parameter named api_key like this: GET https://api.elmah.io/v3/messages/LOG_ID?api_key=MY_API_KEY","title":"Security"},{"location":"using-the-rest-api/#messages","text":"","title":"Messages"},{"location":"using-the-rest-api/#creating-messages","text":"Before doing anything, we will need some messages to play with. The Create Message endpoint does just that. To create a simple message, POST to: POST https://api.elmah.io/v3/messages/LOG_ID with a JSON body: { \"title\": \"This is a test message\" } (replace LOG_ID with your log ID): The title field is the only required field on a message, but fields for specifying severity, timestamp etc. are there. For more information, check out the documentation . If everything where successful, the API returns a HTTP status code of 201 and a location to where to fetch the new message. If the endpoint fails, the response will contain a description of what went wrong. Forgetting to set Content-Length , Content-Type and similar, will result in an invalid request.","title":"Creating messages"},{"location":"using-the-rest-api/#getting-a-message","text":"In the example above, the API returned the URL for getting the newly created message: GET https://api.elmah.io/v3/messages/LOG_ID/81C7C282C9FDAEA3 By making a GET request to this URL, we get back the message details: { \"id\": \"99CDEA3D6A631F09\", \"title\": \"This is a test message\", \"dateTime\": \"2016-07-03T14:25:46.087857Z\", \"severity\": \"Information\" } As shown in the returned body, elmah.io automatically inserted some missing fields like a timestamp and a severity. If no severity is specified during creating, a message is threated as information.","title":"Getting a message"},{"location":"using-the-rest-api/#searching-messages","text":"For the demo, we have inserted a couple of additional messages, which leads us to the next endpoint: searching messages. The search endpoint shares the root path with the get message endpoint, but only take a log ID. The simplest possible configuration, queries the API for a list of the 15 most recent messages by calling: GET https://api.elmah.io/v3/messages/LOG_ID The response body looks like this: { \"messages\": [ { \"id\": \"81C7C282C9FDAEA3\", \"title\": \"This is another test message\", \"dateTime\": \"2016-07-03T14:31:45.053851Z\", \"severity\": \"Information\" }, { \"id\": \"99CDEA3D6A631F09\", \"title\": \"This is a test message\", \"dateTime\": \"2016-07-03T14:25:46.087857Z\", \"severity\": \"Information\" }, // ... ], \"total\": 42 } For simplicity, the response has been simplified by not showing all of the results. The important thing to notice here, is the list of messages and the total count. messages contain 15 messages, which is the default page size in the search endpoint. To increase the number of returned messages, set the pagesize parameter in the URL (max 100 messages per request). The total count tells you, if there are more messages matching your search. To select messages from the next page, use the pageindex parameter. Returning all messages may be fine, but being able to search by terms is even more fun. To search, use the query , from and to parameters as shown here: GET https://api.elmah.io/v3/messages/LOG_ID?query=another Searching for another will return the following response: { \"messages\": [ { \"id\": \"81C7C282C9FDAEA3\", \"title\": \"This is another test message\", \"dateTime\": \"2016-07-03T14:25:46.087857Z\", \"severity\": \"Information\" } ], \"total\": 1 } Now only 81C7C282C9FDAEA3 shows up, since that message contains the text another in the title field. Like specifying the query parameter, you can limit the number of messages using the from , to and pagesize parameters.","title":"Searching messages"},{"location":"using-the-rest-api/#deleting-a-message","text":"When fixing the bug causing an error logged at elmah.io, you may want to delete the error. Deleting a single error is as easy as fetching it. Create a DELETE request to the errors unique URL: DELETE https://api.elmah.io/v3/messages/LOG_ID/81C7C282C9FDAEA3 When successfully deleted, the delete endpoint returns a HTTP status code of 200 .","title":"Deleting a message"},{"location":"using-the-rest-api/#deleting-messages","text":"Deleting messages one by one can be tedious work. To delete multiple errors, you can utilize the Delete Messages endpoint by creating a DELETE request to: DELETE https://api.elmah.io/v3/messages/LOG_ID The request must contain a body with at least a query: { \"query\": \"test\" } An option for deleting messages by date range is available as well. Check out the API documentation for details.","title":"Deleting messages"},{"location":"using-the-rest-api/#hiding-a-message","text":"Depending on your use case, you may want to hide a message, rather than deleting it. Hidden messages are not shown as default through neither the UI, nor the REST API. But you will be able to search for them by enabling the Hidden checkbox on the UI. To hide a message, use the _hide endpoints like this: POST https://api.elmah.io/v3/messages/LOG_ID/99CDEA3D6A631F09/_hide If successful, the endpoint returns a HTTP status code of 200 .","title":"Hiding a message"},{"location":"where-is-my-api-key/","text":"Where is my API key? API keys are a new concept introduced with version 3.x of our API . API keys are located on the organization settings page. To open organization settings, click the gears icon next to your organization name on either the left menu or through the dashboard: When on the organization settings page, click the API Keys tab and copy your API key: This view also lets you generate new API keys and revoke an existing key, if you believe that the key is compromised.","title":"Where is my API key"},{"location":"where-is-my-api-key/#where-is-my-api-key","text":"API keys are a new concept introduced with version 3.x of our API . API keys are located on the organization settings page. To open organization settings, click the gears icon next to your organization name on either the left menu or through the dashboard: When on the organization settings page, click the API Keys tab and copy your API key: This view also lets you generate new API keys and revoke an existing key, if you believe that the key is compromised.","title":"Where is my API key?"},{"location":"where-is-my-invoice-receipt/","text":"Where is my invoice/receipt? Invoices are located on the organization settings page. To open organization settings, click the gears icon next to your organization name on either the left menu or through the dashboard: When on the organization settings page, click the Invoices tab: There's a row per invoice in the table on this page. You can open or download the invoice using the links to the right. If you want invoices emailed to you (or your accountant) every time a payment is made, click the Email invoices button and input an email address.","title":"Where is my invoice / receipt"},{"location":"where-is-my-invoice-receipt/#where-is-my-invoicereceipt","text":"Invoices are located on the organization settings page. To open organization settings, click the gears icon next to your organization name on either the left menu or through the dashboard: When on the organization settings page, click the Invoices tab: There's a row per invoice in the table on this page. You can open or download the invoice using the links to the right. If you want invoices emailed to you (or your accountant) every time a payment is made, click the Email invoices button and input an email address.","title":"Where is my invoice/receipt?"},{"location":"where-is-my-log-id/","text":"Where is my log ID? A log ID represents a log on elmah.io. A log is a container for log messages. How you choose to split up your logs is totally up to you, but creating a log per application/service is what most users do. The log ID is located on the log settings page. To open log settings, click the gears icon next to the log name in the menu or in the log box on the dashboard: When clicking on the icon, you are taken directly to the Install tab:","title":"Where is my log ID"},{"location":"where-is-my-log-id/#where-is-my-log-id","text":"A log ID represents a log on elmah.io. A log is a container for log messages. How you choose to split up your logs is totally up to you, but creating a log per application/service is what most users do. The log ID is located on the log settings page. To open log settings, click the gears icon next to the log name in the menu or in the log box on the dashboard: When clicking on the icon, you are taken directly to the Install tab:","title":"Where is my log ID?"},{"location":"IntegrateWith/HipChat/","text":"Integrate with HipChat Before we dig into the details of elmah.io, you should sign up or log into HipChat. Create a new room for your team and go to the API page. Create a new token with the Notification type and label it something meaningful: We will need the generated token in a minute, so keep that tab open. On elmah.io, go to the Rules tab beneath your log settings. In this example we want a message on HipChat every time a new error is logged in our elmah.io log. To do this, name your rule and input a query like illustrated on the following screenshot: Hit the Then link and select HTTP request. Input the following values (remember to replace YOUR_TOKEN and YOUR_ROOM): Field Value Method POST URL https://api.hipchat.com/v1/rooms/message?format=json&auth_token=YOUR_TOKEN Content Type application/x-www-form-urlencoded Body room_id=YOUR_ROOM&from=elmah.io&message=$message The final result should look like this: Click the OK button and add the new rule by clicking Add. This configuration tells elmah.io, to make a HTTP request against the HipChat API, every time a new error is logged. The message at elmah.io is shown as the chat message inside HipChat:","title":"Integrate with HipChat"},{"location":"IntegrateWith/HipChat/#integrate-with-hipchat","text":"Before we dig into the details of elmah.io, you should sign up or log into HipChat. Create a new room for your team and go to the API page. Create a new token with the Notification type and label it something meaningful: We will need the generated token in a minute, so keep that tab open. On elmah.io, go to the Rules tab beneath your log settings. In this example we want a message on HipChat every time a new error is logged in our elmah.io log. To do this, name your rule and input a query like illustrated on the following screenshot: Hit the Then link and select HTTP request. Input the following values (remember to replace YOUR_TOKEN and YOUR_ROOM): Field Value Method POST URL https://api.hipchat.com/v1/rooms/message?format=json&auth_token=YOUR_TOKEN Content Type application/x-www-form-urlencoded Body room_id=YOUR_ROOM&from=elmah.io&message=$message The final result should look like this: Click the OK button and add the new rule by clicking Add. This configuration tells elmah.io, to make a HTTP request against the HipChat API, every time a new error is logged. The message at elmah.io is shown as the chat message inside HipChat:","title":"Integrate with HipChat"},{"location":"IntegrateWith/Slack/","text":"","title":"Slack"},{"location":"IntegrateWith/Zapier/","text":"Integrate with Zapier In short Zapier is the place to go, if you need to integrate two or more online systems. In this article we use an integration point provided by elmah.io and Zapier called a trigger. A trigger is (as the name suggest) something that triggers an action in Zapier. In case of elmah.io, the trigger available is when new messages are logged to your log. Actions exists on the other side of the integration and tells Zapier what to do every time a trigger is fired. Hundreds of actions exists, in this example we use the GitHub action to create a new issue every time a new message is logged. Create a new account on Zapier.com. Then click the Make a New Zap button. The create new Zap page is shown: Select elmah.io in the Choose a Trigger app\u2026 dropdown and then select New Error in the Choose a Trigger\u2026 dropdown. In the Choose an Action app\u2026 select GitHub and select Create Issue in the Choose an Action\u2026 dropdown. This configuration tells Zapier to create a new issue at GitHub, every time a new error is logged in elmah.io. The action could be one of the hundreds of other integrations available at Zapier. Click Continue. In section 2 select the Connect a different elmah.io Account and input a name and the log id of the log you want to integrate: Authorize your GitHub account (or whatever integration you\u2019ve selected in the action step) and click Continue . Step 4 isn\u2019t mandatory, but here you will be able to setup additional constraints to the Zap. If you\u2019re using elmah.io for other than errors, you can tell Zapier only to create a new GitHub issue when the message is an actual error: In step 5 you specify how the new issue should create created. In this example I\u2019ve chosen the GitHub project for our open source client. For the title, I use two of the variables available from the elmah.io action. For a complete list of variables, click the Insert button next to each textbox. The variable will look something like this \u201cMyApp: An error occurred\u201d. The issue body contains the detail of the error (typically a stacktrace). Finally I\u2019ve selected bug as a label. Test the Zap an hit Continue : Finally, name your Zap and click the Turn Zap on button: When future errors are logged in your elmah.io log, a GitHub issue is automatically created. How awesome is that!","title":"Integrate with Zapier"},{"location":"IntegrateWith/Zapier/#integrate-with-zapier","text":"In short Zapier is the place to go, if you need to integrate two or more online systems. In this article we use an integration point provided by elmah.io and Zapier called a trigger. A trigger is (as the name suggest) something that triggers an action in Zapier. In case of elmah.io, the trigger available is when new messages are logged to your log. Actions exists on the other side of the integration and tells Zapier what to do every time a trigger is fired. Hundreds of actions exists, in this example we use the GitHub action to create a new issue every time a new message is logged. Create a new account on Zapier.com. Then click the Make a New Zap button. The create new Zap page is shown: Select elmah.io in the Choose a Trigger app\u2026 dropdown and then select New Error in the Choose a Trigger\u2026 dropdown. In the Choose an Action app\u2026 select GitHub and select Create Issue in the Choose an Action\u2026 dropdown. This configuration tells Zapier to create a new issue at GitHub, every time a new error is logged in elmah.io. The action could be one of the hundreds of other integrations available at Zapier. Click Continue. In section 2 select the Connect a different elmah.io Account and input a name and the log id of the log you want to integrate: Authorize your GitHub account (or whatever integration you\u2019ve selected in the action step) and click Continue . Step 4 isn\u2019t mandatory, but here you will be able to setup additional constraints to the Zap. If you\u2019re using elmah.io for other than errors, you can tell Zapier only to create a new GitHub issue when the message is an actual error: In step 5 you specify how the new issue should create created. In this example I\u2019ve chosen the GitHub project for our open source client. For the title, I use two of the variables available from the elmah.io action. For a complete list of variables, click the Insert button next to each textbox. The variable will look something like this \u201cMyApp: An error occurred\u201d. The issue body contains the detail of the error (typically a stacktrace). Finally I\u2019ve selected bug as a label. Test the Zap an hit Continue : Finally, name your Zap and click the Turn Zap on button: When future errors are logged in your elmah.io log, a GitHub issue is automatically created. How awesome is that!","title":"Integrate with Zapier"}]}